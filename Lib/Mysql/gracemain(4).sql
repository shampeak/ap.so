-- phpMyAdmin SQL Dump
-- version phpStudy 2014
-- http://www.phpmyadmin.net
--
-- 主机: localhost
-- 生成日期: 2015 年 09 月 18 日 18:09
-- 服务器版本: 5.5.40
-- PHP 版本: 5.4.33

SET SQL_MODE="NO_AUTO_VALUE_ON_ZERO";
SET time_zone = "+00:00";


/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8 */;

--
-- 数据库: `gracemain`
--

-- --------------------------------------------------------

--
-- 表的结构 `dy_user`
--

CREATE TABLE IF NOT EXISTS `dy_user` (
  `uid` int(11) NOT NULL AUTO_INCREMENT,
  `uname` varchar(32) NOT NULL,
  `tname` varchar(32) DEFAULT NULL,
  `pwd` varchar(32) DEFAULT NULL,
  `groupid` int(11) DEFAULT '0',
  `authkey` varchar(64) DEFAULT NULL,
  `accessToken` varchar(64) DEFAULT NULL,
  `logtime` int(11) DEFAULT NULL,
  `logip` varchar(32) DEFAULT NULL,
  `enable` tinyint(1) DEFAULT '1',
  `regtime` int(11) DEFAULT NULL,
  PRIMARY KEY (`uid`),
  KEY `enable` (`enable`),
  KEY `groupid` (`groupid`),
  KEY `uname` (`uname`)
) ENGINE=MyISAM  DEFAULT CHARSET=utf8 AUTO_INCREMENT=31 ;

--
-- 转存表中的数据 `dy_user`
--

INSERT INTO `dy_user` (`uid`, `uname`, `tname`, `pwd`, `groupid`, `authkey`, `accessToken`, `logtime`, `logip`, `enable`, `regtime`) VALUES
(16, 'irones', '杨俊', 'irones', 0, '', '', 192168, '192.168.1.200', 1, 1438588854),
(17, 'iron123', '', 'iron2es', 0, '', '', 0, '', 1, 1436146751),
(18, 'Avatarar', '', 'avatarar', 0, '', '', 1436322516, '192.168.1.200', 1, 1436147014),
(19, 'irones2', '洋洋2', 'irones2', 0, NULL, NULL, NULL, NULL, 1, NULL),
(20, '12', '12', '123123123', 0, NULL, NULL, NULL, NULL, 1, NULL),
(21, '12123', '12', '123123123', 0, NULL, NULL, NULL, NULL, 1, NULL),
(28, 'tetetete', 'tetetete23333', 'tetetete', 34, NULL, NULL, NULL, NULL, 1, NULL),
(29, 'tetetete2', 'tetetete2', 'tetetete', 33, NULL, NULL, NULL, NULL, 1, NULL),
(30, '123123123', NULL, '123123123', 999, NULL, NULL, NULL, NULL, 1, 1438766218);

-- --------------------------------------------------------

--
-- 表的结构 `g_accessrules`
--

CREATE TABLE IF NOT EXISTS `g_accessrules` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `uname` varchar(64) NOT NULL,
  `rid` int(11) NOT NULL,
  `deny` int(2) NOT NULL,
  `allow` int(2) NOT NULL,
  PRIMARY KEY (`id`),
  KEY `uname` (`uname`),
  KEY `rid` (`rid`)
) ENGINE=MyISAM  DEFAULT CHARSET=utf8 AUTO_INCREMENT=4 ;

--
-- 转存表中的数据 `g_accessrules`
--

INSERT INTO `g_accessrules` (`id`, `uname`, `rid`, `deny`, `allow`) VALUES
(1, 'irones', 1, 1, 1),
(2, '2', 2, 2, 0),
(3, '2', 2, 2, 2);

-- --------------------------------------------------------

--
-- 表的结构 `g_basicmsg`
--

CREATE TABLE IF NOT EXISTS `g_basicmsg` (
  `ID` int(11) NOT NULL AUTO_INCREMENT,
  `NO` int(11) NOT NULL,
  `NAME` varchar(45) DEFAULT NULL,
  `SEX` char(1) DEFAULT 'F',
  `AGE` tinyint(3) DEFAULT '0',
  `FLAG` tinyint(4) DEFAULT '0',
  `starttime` datetime DEFAULT '2000-01-01 00:00:01',
  `stoptime` datetime DEFAULT '2000-01-01 00:00:01',
  `allbeat` int(11) DEFAULT '0',
  `maxHR` smallint(3) DEFAULT '0',
  `minHR` smallint(3) DEFAULT '0',
  `meanHR` smallint(3) DEFAULT '0',
  `validbeat` int(11) DEFAULT '0',
  `invalidbeat` int(11) DEFAULT '0',
  `diag1` int(11) DEFAULT '0',
  `diag2` int(11) DEFAULT '0',
  `diag3` int(11) DEFAULT '0',
  `diag4` int(11) DEFAULT '0',
  `diag5` int(11) DEFAULT '0',
  `diag6` int(11) DEFAULT '0',
  `diag7` int(11) DEFAULT '0',
  `diag8` int(11) DEFAULT '0',
  `diag9` int(11) DEFAULT '0',
  `diag10` int(11) DEFAULT '0',
  `diag11` int(11) DEFAULT '0',
  `diag12` int(11) DEFAULT '0',
  `diag13` int(11) DEFAULT '0',
  `diag14` int(11) DEFAULT '0',
  `diag15` int(11) DEFAULT '0',
  PRIMARY KEY (`ID`)
) ENGINE=MyISAM  DEFAULT CHARSET=utf8 AUTO_INCREMENT=7 ;

--
-- 转存表中的数据 `g_basicmsg`
--

INSERT INTO `g_basicmsg` (`ID`, `NO`, `NAME`, `SEX`, `AGE`, `FLAG`, `starttime`, `stoptime`, `allbeat`, `maxHR`, `minHR`, `meanHR`, `validbeat`, `invalidbeat`, `diag1`, `diag2`, `diag3`, `diag4`, `diag5`, `diag6`, `diag7`, `diag8`, `diag9`, `diag10`, `diag11`, `diag12`, `diag13`, `diag14`, `diag15`) VALUES
(1, 1111111, 'wang', 'F', 33, 100, '2015-07-16 01:01:01', '2015-07-18 01:01:01', 200000, 111, 44, 77, 190000, 10000, 44, 6, 7, 4, 44, 44, 55, 88, 8, 9, 1, 3, 4, 4, 6),
(2, 2222222, 'li', 'M', 22, 1, '2015-07-16 01:01:01', '2015-07-16 21:01:01', 80000, 222, 33, 55, 70000, 10000, 5, 7, 9, 0, 7, 5, 7, 7, 7, 7, 7, 7, 7, 7, 7),
(3, 2222223, 'ZHAO', 'M', 22, 1, '2015-07-16 01:01:01', '2015-07-16 21:01:01', 80000, 222, 33, 55, 70000, 10000, 5, 7, 9, 0, 7, 5, 7, 7, 7, 7, 7, 7, 7, 7, 7),
(4, 2222224, 'Cccc', 'M', 22, 1, '2015-07-16 01:01:01', '2015-07-16 21:01:01', 80000, 222, 33, 55, 70000, 10000, 5, 7, 9, 0, 7, 5, 7, 7, 7, 7, 7, 7, 7, 7, 7),
(5, 333333, 'Cccc', 'F', 0, 0, '2000-01-01 00:00:01', '2000-01-01 00:00:01', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);

-- --------------------------------------------------------

--
-- 表的结构 `g_book`
--

CREATE TABLE IF NOT EXISTS `g_book` (
  `bookid` int(11) NOT NULL AUTO_INCREMENT,
  `bookname` varchar(16) DEFAULT NULL,
  `enable` tinyint(1) NOT NULL DEFAULT '1',
  PRIMARY KEY (`bookid`)
) ENGINE=MyISAM  DEFAULT CHARSET=utf8 AUTO_INCREMENT=12 ;

--
-- 转存表中的数据 `g_book`
--

INSERT INTO `g_book` (`bookid`, `bookname`, `enable`) VALUES
(1, '基础', 1),
(2, 'Grace', 1),
(3, '构架', 1),
(4, 'Pyramid', 1),
(5, 'PHP相关', 1),
(6, 'Linux', 0),
(7, 'Mysql', 0),
(8, 'Bootstrap', 0),
(9, 'Jquery', 0),
(10, '框架', 0),
(11, '概念', 1);

-- --------------------------------------------------------

--
-- 表的结构 `g_booknode`
--

CREATE TABLE IF NOT EXISTS `g_booknode` (
  `nodeid` int(11) NOT NULL AUTO_INCREMENT,
  `bookid` int(11) DEFAULT NULL,
  `preid` int(11) NOT NULL DEFAULT '0',
  `title` varchar(64) DEFAULT NULL,
  `nr` text,
  `nrcode` text,
  `type` varchar(255) DEFAULT NULL,
  `sort` int(11) DEFAULT '0',
  `enable` tinyint(1) NOT NULL DEFAULT '1',
  PRIMARY KEY (`nodeid`)
) ENGINE=MyISAM  DEFAULT CHARSET=utf8 AUTO_INCREMENT=209 ;

--
-- 转存表中的数据 `g_booknode`
--

INSERT INTO `g_booknode` (`nodeid`, `bookid`, `preid`, `title`, `nr`, `nrcode`, `type`, `sort`, `enable`) VALUES
(1, 1, 0, '开发环境', '<p>关于开发环境的部分说明</p>\r\n\r\n<p>本机设置了</p>\r\n\r\n<ul>\r\n	<li>固定ip 192.168.0.10</li>\r\n	<li>主调试地址 : http://m.so</li>\r\n</ul>\r\n\r\n<p>开发环境的相关账号</p>\r\n\r\n<ul>\r\n	<li>Mysql : gracemain / gracemain</li>\r\n	<li>Mysqlroot : root / root</li>\r\n	<li>后台登录地址 :</li>\r\n</ul>\r\n', '关于开发环境的部分说明\r\n\r\n', 'con', 99, 1),
(27, 2, 29, '版本', '<p>版本</p>\r\n', '版本', 'con', 9, 1),
(28, 2, 29, '版权', '<p>版权</p>\r\n', '版权', 'con', 9, 1),
(29, 2, 0, '概要', '<p>为适应敏捷开发和快速开发所开发的一套框架</p>\r\n\r\n<p>特点</p>\r\n\r\n<ul>\r\n	<li>简单</li>\r\n	<li>丰富的控制器扩展</li>\r\n	<li>抛弃前端模板,嵌入php语句</li>\r\n	<li>分层规划明确</li>\r\n	<li>代码优雅</li>\r\n</ul>\r\n', '\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n', 'cla', 99, 1),
(2, 1, 15, '对象', '<p>发多少法伤的发生大事的发生地方发多少法伤的发生大事的发生地方发多少法伤的发生大事的发生地方发多少法伤的发生大事的发生地方发多少法伤的发生大事的发生地方发多少法伤的发生大事的发生地方发多少法伤的发生大事的发生地方发多少法伤的发生大事的发生地方发多少法伤的发生大事的发生地方发多少法伤的发生大事的发生地方发多少法伤的发生大事的发生地方发多少法伤的发生大事的发生地方发多少法伤的发生大事的发生地方发多少法伤的发生大事的发生地方发多少法伤的发生大事的发生地方</p>\r\n', '>PSR-0 autoloader\r\n\r\n    public static function registerAutoloader()\r\n    {\r\n        spl_autoload_register(__NAMESPACE__ . "\\\\Seter::autoload");\r\n    }\r\n\r\n    public static function autoload($className)\r\n    {\r\n        $thisClass = str_replace(__NAMESPACE__ . ''\\\\'', '''', __CLASS__);\r\n        $baseDir = __DIR__;\r\n        if (substr($baseDir, -strlen($thisClass)) === $thisClass) {\r\n            $baseDir = substr($baseDir, 0, -strlen($thisClass));\r\n        }\r\n        $className = ltrim($className, ''\\\\'');\r\n        $fileName = $baseDir;\r\n        $namespace = '''';\r\n        if ($lastNsPos = strripos($className, ''\\\\'')) {\r\n            $namespace = substr($className, 0, $lastNsPos);\r\n            $className = substr($className, $lastNsPos + 1);\r\n            $fileName .= str_replace(''\\\\'', DIRECTORY_SEPARATOR, $namespace) . DIRECTORY_SEPARATOR;\r\n        }\r\n        $fileName .= str_replace(''_'', DIRECTORY_SEPARATOR, $className) . ''.php'';\r\n        if (file_exists($fileName)) {\r\n            require $fileName;\r\n        }\r\n    }\r\n\r\n>调用\r\n\r\n    \\Seter\\Seter::registerAutoloader();     //PSR-0', 'con', 0, 1),
(3, 1, 16, '数据存储', '<ul>\r\n	<li>Mysql</li>\r\n	<li>Mongodb</li>\r\n</ul>\r\n', '    Mysql\r\n    Mongodb', 'con', 0, 1),
(4, 1, 16, '框架选型', '<ul>\r\n	<li>YII框架</li>\r\n	<li>CI框架</li>\r\n</ul>\r\n', '    YII框架\r\n    CI框架', 'con', 0, 1),
(5, 1, 16, '组件安装', '<ul>\r\n	<li>PEAR</li>\r\n	<li>XCACHE</li>\r\n</ul>\r\n', '    PEAR\r\n    XCACHE', 'con', 0, 1),
(6, 1, 16, 'Php配置', '<p>开启模块 :</p>\r\n\r\n<p>&nbsp;</p>\r\n', '开启模块 :\r\n\r\n', 'con', 0, 1),
(7, 1, 16, 'PhpStudy', '<p>开发环境用PhpStudy快速搭建</p>\r\n\r\n<p>下载地址 :http://www.phpstudy.net/</p>\r\n\r\n<p>版本选择 Apache + PHP5.4n</p>\r\n\r\n<p>&nbsp;</p>\r\n', '开发环境用PhpStudy快速搭建', 'con', 0, 1),
(8, 1, 1, 'PhpStudy', '<p>PhpStudy</p>\r\n\r\n<p>站点</p>\r\n\r\n<p>http://www.phpstudy.net/</p>\r\n', 'PhpStudy', 'con', 0, 1),
(9, 1, 1, '其他相关工具', '<ul>\r\n	<li>Git</li>\r\n	<li>Onenote</li>\r\n</ul>', ' Git\r\n Onenote\r\n\r\n ', 'con', 0, 1),
(10, 1, 1, 'IDE', '<p>Editplus v3.50</p>\r\n\r\n<p>PhpStorm 9.0</p>\r\n\r\n<p>Dreamweaver 12.0</p>\r\n\r\n<p>Office 2010</p>\r\n', 'Editplus v3.50\r\n\r\nPhpStorm 9.0\r\n\r\nDreamweaver 12.0\r\n\r\nOffice 2010', 'con', 0, 1),
(11, 1, 1, 'Markdown', '<p>本系统采用markdown语法</p>\r\n\r\n<p>详细markdown语法请参考 <a href="http://baike.baidu.com/view/2311114.htm">http://baike.baidu.com/view/2311114.htm</a></p>\r\n', '####本系统采用markdown语法\r\n\r\n\r\n详细markdown语法请参考 \r\nhttp://baike.baidu.com/view/2311114.htm', 'fun', 1, 1),
(12, 2, 29, '相关', '', '', 'con', 7, 1),
(13, 2, 29, '参考', '<p>参考</p>\r\n', '参考', 'con', 8, 1),
(14, 2, 26, '路由', '<p>123nr</p>\r\n', '123code', 'con', 0, 1),
(15, 1, 0, '其他', '<p>123nr</p>\r\n', '123code', 'con', 0, 1),
(16, 1, 0, 'PHP环境', '<p>版本要求</p>\r\n\r\n<p>PHP 5.4+</p>\r\n', '##版本要求\r\n\r\nPHP 5.4+', 'con', 0, 1),
(17, 2, 0, 'Seter容器', '<p>123nr</p>\r\n', '123code', 'con', 55, 1),
(18, 2, 26, '配置', '', '', 'con', 0, 1),
(19, 2, 29, '目录结构', '<h1>目录结构</h1>\r\n', '目录结构', 'con', 1, 1),
(20, 2, 29, 'Hello Word', '', '123code', 'con', 0, 1),
(21, 2, 26, '数据库表', '<p>123nr</p>\r\n', '123code', 'con', 0, 1),
(22, 2, 26, '控制器', '<p>123nr</p>\r\n', '123code', 'con', 0, 1),
(23, 2, 26, '视图', '<p>123nr</p>\r\n', '123code', 'con', 0, 1),
(24, 2, 26, '数据库', '<p>123nr</p>\r\n', '123code', 'con', 0, 1),
(25, 2, 0, '进阶', '<p>123nr</p>\r\n', '123code', 'con', 77, 1),
(26, 2, 0, '基础', '<p>123nr</p>\r\n', '123code', 'con', 88, 1),
(30, 2, 25, '控制器扩展2', '9', '9', 'con', 9, 1),
(31, 2, 25, '路由扩展', '', '', 'con', 0, 1),
(32, 2, 25, '内部对象', '', '', 'con', 0, 1),
(33, 2, 26, '自动加载', '', '', 'con', 0, 1),
(50, 5, 0, 'PSR规范', '<p>PSR原本有四个规范，分别是：</p>\r\n\r\n<ul>\r\n	<li>PSR-0 自动加载</li>\r\n	<li>PSR-1 基本代码规范</li>\r\n	<li>PSR-2 代码样式</li>\r\n	<li>PSR-3 日志接口</li>\r\n</ul>\r\n\r\n<p>2013年底，新出了第5个规范&mdash;&mdash;PSR-4。</p>\r\n', '', NULL, -100, 1),
(51, 5, 50, 'PSR-0 自动加载 [作废]', '<p>&gt; **已弃用** - 截止到2014年10月21日，PSR-0已被弃用。 推荐替代使用[PSR-4](http://www.php-fig.org/psr/psr-4/)。</p>\r\n\r\n<p>下文描述了若要使用一个通用的自动加载器(autoloader)，你所需要遵守的规范：</p>\r\n\r\n<p><br />\r\n规范<br />\r\n---------</p>\r\n\r\n<p>* 一个完全标准的命名空间(namespace)和类(class)的结构是这样的：<br />\r\n`\\\\(\\)*`<br />\r\n* 每个命名空间(namespace)都必须有一个顶级的空间名(namespace)(&quot;组织名(Vendor Name)&quot;)。<br />\r\n* 每个命名空间(namespace)中可以根据需要使用任意数量的子命名空间(sub-namespace)。<br />\r\n* 从文件系统中加载源文件时，空间名(namespace)中的分隔符将被转换为 DIRECTORY_SEPARATOR。<br />\r\n* 类名(class name)中的每个下划线_都将被转换为一个DIRECTORY_SEPARATOR。下划线_在空间名(namespace)中没有什么特殊的意义。<br />\r\n* 完全标准的命名空间(namespace)和类(class)从文件系统加载源文件时将会加上.php后缀。<br />\r\n* 组织名(vendor name)，空间名(namespace)，类名(class name)都由大小写字母组合而成。</p>\r\n\r\n<p>&nbsp;</p>\r\n', '\r\n\r\n\r\n\r\n\r\n示例\r\n--------\r\n\r\n	* \\Doctrine\\Common\\IsolatedClassLoader => /path/to/project/lib/vendor/Doctrine/Common/IsolatedClassLoader.php\r\n	* \\Symfony\\Core\\Request => /path/to/project/lib/vendor/Symfony/Core/Request.php\r\n	* \\Zend\\Acl => /path/to/project/lib/vendor/Zend/Acl.php\r\n	* \\Zend\\Mail\\Message => /path/to/project/lib/vendor/Zend/Mail/Message.php\r\n    \r\n\r\n空间名(namespace)和类名(class name)中的下划线\r\n\r\n-----------------------------------------\r\n\r\n	* \\namespace\\package\\Class_Name` => /path/to/project/lib/vendor/namespace/package/Class/Name.php\r\n	* \\namespace\\package_name\\Class_Name` => /path/to/project/lib/vendor/namespace/package_name/Class/Name.php\r\n\r\n以上是我们为实现通用的自动加载而制定的最低标准。你可以利用能够自动加载PHP 5.3类的SplClassLoader来测试你的代码是否符合这些标准。\r\n\r\n\r\n实例\r\n----------------------\r\n\r\n下面是一个怎样利用上述标准来实现自动加载的示例函数。\r\n\r\n```php\r\n	<?php\r\n\r\n	function autoload($className)\r\n	{\r\n	    $className = ltrim($className, ''\\\\'');\r\n	    $fileName  = '''';\r\n	    $namespace = '''';\r\n	    if ($lastNsPos = strrpos($className, ''\\\\'')) {\r\n		$namespace = substr($className, 0, $lastNsPos);\r\n		$className = substr($className, $lastNsPos + 1);\r\n		$fileName  = str_replace(''\\\\'', DIRECTORY_SEPARATOR, $namespace) . DIRECTORY_SEPARATOR;\r\n	    }\r\n	    $fileName .= str_replace(''_'', DIRECTORY_SEPARATOR, $className) . ''.php'';\r\n\r\n	    require $fileName;\r\n	}\r\n```\r\n\r\n\r\n`SplClassLoader`实现\r\n\r\n-----------------------------\r\n\r\n下面的gist是一个按照上面建议的标准来自动加载类的SplClassLoader实例。这是依据这些标准来加载PHP 5.3类的推荐方案。\r\n\r\n* [http://gist.github.com/221634](http://gist.github.com/221634)\r\n\r\n\r\n', NULL, 9, 1),
(52, 5, 50, 'PSR-1 基本代码规范', '<p>基本代码规范<br />\r\n=====================</p>\r\n\r\n<p>本节我们将会讨论一些基本的代码规范问题，以此作为将来讨论更高级别的代码分享和技术互用的基础。</p>\r\n\r\n<p>[RFC 2119][]中的`必须(MUST)`，`不可(MUST NOT)`，`建议(SHOULD)`，`不建议(SHOULD NOT)`，`可以/可能(MAY)`等关键词将在本节用来做一些解释性的描述。</p>\r\n\r\n<p>[RFC 2119]: http://www.ietf.org/rfc/rfc2119.txt<br />\r\n[PSR-0]: https://github.com/hfcorriez/fig-standards/blob/zh_CN/接受/PSR-0.md</p>\r\n', '基本代码规范\r\n=====================\r\n\r\n本节我们将会讨论一些基本的代码规范问题，以此作为将来讨论更高级别的代码分享和技术互用的基础。\r\n\r\n[RFC 2119][]中的必须(MUST)，不可(MUST NOT)，建议(SHOULD)，不建议(SHOULD NOT)，可以/可能(MAY)等关键词将在本节用来做一些解释性的描述。\r\n\r\n[RFC 2119]: http://www.ietf.org/rfc/rfc2119.txt\r\n[PSR-0]: https://github.com/hfcorriez/fig-standards/blob/zh_CN/接受/PSR-0.md\r\n\r\n\r\n1. 概述\r\n-----------\r\n\r\n- 源文件必须只使用 <?php 和 <?= 这两种标签。\r\n\r\n- 源文件中php代码的编码格式必须只使用不带字节顺序标记(BOM)的UTF-8。\r\n\r\n- 一个源文件建议只用来做声明（类(class)，函数(function)，常量(constant)等）或者只用来做一些引起副作用的操作（例如：输出信息，修改.ini配置等）,但不建议同时做这两件事。\r\n\r\n- 命名空间(namespace)和类(class)必须遵守[PSR-0][]标准。\r\n\r\n- 类名(class name)必须使用骆驼式(StudlyCaps)写法 (译者注：驼峰式(cameCase)的一种变种，后文将直接用StudlyCaps表示)。\r\n\r\n- 类(class)中的常量必须只由大写字母和下划线(_)组成。\r\n\r\n- 方法名(method name)必须使用驼峰式(cameCase)写法(译者注：后文将直接用camelCase表示)。\r\n\r\n\r\n2. 文件\r\n--------\r\n\r\n## 2.1. PHP标签\r\n\r\nPHP代码必须只使用长标签(<?php ?>)或者短输出式标签(<?= ?>)；而不可使用其他标签。\r\n\r\n## 2.2. 字符编码\r\n\r\nPHP代码的编码格式必须只使用不带字节顺序标记(BOM)的UTF-8。\r\n\r\n## 2.3. 副作用\r\n\r\n一个源文件建议只用来做声明（类(class)，函数(function)，常量(constant)等）或者只用来做一些引起副作用的操作（例如：输出信息，修改.ini配置等）,但不建议同时做这两件事。\r\n\r\n短语副作用(side effects)的意思是 *在包含文件时* 所执行的逻辑与所声明的类(class)，函数(function)，常量(constant)等没有直接的关系。\r\n\r\n副作用(side effects)包含但不局限于：产生输出，显式地使用require或include，连接外部服务，修改ini配置，触发错误或异常，修改全局或者静态变量，读取或修改文件等等\r\n\r\n下面是一个既包含声明又有副作用的示例文件；即应避免的例子：\r\n\r\n```php\r\n\r\n	<?php\r\n	// 副作用：修改了ini配置\r\n	ini_set(''error_reporting'', E_ALL);\r\n\r\n	// 副作用：载入了文件\r\n	include "file.php";\r\n\r\n	// 副作用：产生了输出\r\n	echo "<html>\\n";\r\n\r\n	// 声明\r\n	function foo()\r\n	{\r\n	    // 函数体\r\n	}\r\n```\r\n\r\n下面是一个仅包含声明的示例文件；即应提倡的例子：\r\n\r\n```php\r\n\r\n	<?php\r\n	// 声明\r\n	function foo()\r\n	{\r\n	    // 函数体\r\n	}\r\n\r\n	// 条件式声明不算做是副作用\r\n	if (! function_exists(''bar'')) {\r\n	    function bar()\r\n	    {\r\n		// 函数体\r\n	    }\r\n	}\r\n    \r\n```\r\n\r\n\r\n\r\n3. 空间名(namespace)和类名(class name)\r\n----------------------------\r\n\r\n命名空间(namespace)和类(class)必须遵守 [PSR-0][].\r\n\r\n这意味着一个源文件中只能有一个类(class)，并且每个类(class)至少要有一级空间名（namespace）：即一个顶级的组织名(vendor name)。\r\n\r\n类名(class name)必须使用StudlyCaps写法。\r\n\r\nPHP5.3之后的代码必须使用正式的命名空间(namespace)\r\n例子：\r\n\r\n```php\r\n\r\n	<?php\r\n	// PHP 5.3 及之后:\r\n	namespace Vendor\\Model;\r\n\r\n	class Foo\r\n	{\r\n	}\r\n    \r\n```\r\n\r\n\r\nPHP5.2.x之前的代码建议用伪命名空间Vendor_作为类名(class name)的前缀\r\n\r\n```php\r\n\r\n	<?php\r\n	// PHP 5.2.x 及之前:\r\n	class Vendor_Model_Foo\r\n	{\r\n	}\r\n    \r\n```\r\n\r\n4. 类的常量、属性和方法\r\n-------------------------------------------\r\n\r\n术语类(class)指所有的类(class)，接口(interface)和特性(trait)`\r\n\r\n## 4.1. 常量\r\n\r\n类常量必须只由大写字母和下划线(_)组成。\r\n例子：\r\n\r\n```php\r\n\r\n	<?php\r\n	namespace Vendor\\Model;\r\n\r\n	class Foo\r\n	{\r\n	    const VERSION = ''1.0'';\r\n	    const DATE_APPROVED = ''2012-06-01'';\r\n	}\r\n    \r\n```\r\n\r\n## 4.2. 属性\r\n\r\n本指南中故意不对$StulyCaps，$camelCase或者$unser_score中的某一种风格作特别推荐，完全由读者依据个人喜好决定属性名的命名风格。\r\n\r\n但是不管你如何定义属性名，建议在一个合理的范围内保持一致。这个范围可能是组织(vendor)级别的，包(package)级别的，类(class)级别的，或者方法(method)级别的。\r\n\r\n##4.3. 方法\r\n\r\n方法名则必须使用camelCase()风格来声明。\r\n', NULL, 8, 1),
(53, 5, 50, 'PSR-2 代码风格指南', '<p>代码风格指南<br />\r\n==================</p>\r\n\r\n<p>本手册是基础代码规范([PSR-1][])的继承和扩展。</p>\r\n\r\n<p>为了尽可能的提升阅读其他人代码时的效率，下面例举了一系列的通用规则，特别是有关于PHP代码风格的。</p>\r\n\r\n<p>各个成员项目间的共性组成了这组代码规范。当开发者们在多个项目中合作时，本指南将会成为所有这些项目中共用的一组代码规范。 因此，本指南的益处不在于这些规则本身，而在于在所有项目中共用这些规则。</p>\r\n\r\n<p>[RFC 2119][]中的必须(MUST)，不可(MUST NOT)，建议(SHOULD)，不建议(SHOULD NOT)，可以/可能(MAY)等关键词将在本节用来做一些解释性的描述。</p>\r\n\r\n<p>[RFC 2119]: http://www.ietf.org/rfc/rfc2119.txt<br />\r\n[PSR-0]: https://github.com/hfcorriez/fig-standards/blob/zh_CN/接受/PSR-0.md<br />\r\n[PSR-1]: https://github.com/hfcorriez/fig-standards/blob/zh_CN/接受/PSR-1-basic-coding-standard.md</p>\r\n', '1. 概述\r\n-----------\r\n\r\n- 代码必须遵守 [PSR-1][]。\r\n\r\n- 代码必须使用4个空格来进行缩进，而不是用制表符。\r\n\r\n- 一行代码的长度不建议有硬限制；软限制必须为120个字符，建议每行代码80个字符或者更少。\r\n\r\n- 在命名空间(namespace)的声明下面必须有一行空行，并且在导入(use)的声明下面也必须有一行空行。\r\n\r\n- 类(class)的左花括号必须放到其声明下面自成一行，右花括号则必须放到类主体下面自成一行。\r\n\r\n- 方法(method)的左花括号必须放到其声明下面自成一行，右花括号则必须放到方法主体的下一行。\r\n\r\n- 所有的属性(property)和方法(method) 必须有可见性声明；抽象(abstract)和终结(final)声明必须在可见性声明之前；而静态(static)声明必须在可见性声明之后。\r\n\r\n- 在控制结构关键字的后面必须有一个空格；而方法(method)和函数(function)的关键字的后面不可有空格。\r\n\r\n- 控制结构的左花括号必须跟其放在同一行，右花括号必须放在该控制结构代码主体的下一行。\r\n\r\n- 控制结构的左括号之后不可有空格，右括号之前也不可有空格。\r\n\r\n## 1.1. 示例\r\n\r\n这个示例中简单展示了上文中提到的一些规则：\r\n\r\n```php\r\n\r\n	<?php\r\n	namespace Vendor\\Package;\r\n\r\n	use FooInterface;\r\n	use BarClass as Bar;\r\n	use OtherVendor\\OtherPackage\\BazClass;\r\n\r\n	class Foo extends Bar implements FooInterface\r\n	{\r\n	    public function sampleFunction($a, $b = null)\r\n	    {\r\n		if ($a === $b) {\r\n		    bar();\r\n		} elseif ($a > $b) {\r\n		    $foo->bar($arg1);\r\n		} else {\r\n		    BazClass::bar($arg2, $arg3);\r\n		}\r\n	    }\r\n\r\n	    final public static function bar()\r\n	    {\r\n		// 方法主体\r\n	    }\r\n	}\r\n\r\n```\r\n\r\n2. 通则\r\n----------\r\n\r\n## 2.1 基础代码规范\r\n\r\n代码必须遵守 [PSR-1][] 中的所有规则。\r\n\r\n## 2.2 源文件\r\n\r\n所有的PHP源文件必须使用Unix LF(换行)作为行结束符。\r\n\r\n所有PHP源文件必须以一个空行结束。\r\n\r\n纯PHP代码源文件的关闭标签?> 必须省略。\r\n\r\n## 2.3. 行\r\n\r\n行长度不可有硬限制。\r\n\r\n行长度的软限制必须是120个字符；对于软限制，代码风格检查器必须警告但不可报错。\r\n\r\n一行代码的长度不建议超过80个字符；较长的行建议拆分成多个不超过80个字符的子行。\r\n\r\n在非空行后面不可有空格。\r\n\r\n空行可以用来增强可读性和区分相关代码块。\r\n\r\n一行不可多于一个语句。\r\n\r\n## 2.4. 缩进\r\n\r\n代码必须使用4个空格，且不可使用制表符来作为缩进。\r\n\r\n> 注意：代码中只使用空格，且不和制表符混合使用，将会对避免代码差异，补丁，历史和注解中的一些问题有帮助。空格的使用还可以使通过调整细微的缩进来改进行间对齐变得更加的简单。\r\n\r\n## 2.5. 关键字和 True/False/Null\r\n\r\nPHP关键字([keywords][])必须使用小写字母。\r\n\r\nPHP常量true, false和null 必须使用小写字母。\r\n\r\n[keywords]: http://php.net/manual/en/reserved.keywords.php\r\n\r\n\r\n3. 命名空间(Namespace)和导入(Use)声明\r\n---------------------------------\r\n\r\n命名空间(namespace)的声明后面必须有一行空行。\r\n\r\n所有的导入(use)声明必须放在命名空间(namespace)声明的下面。\r\n\r\n一句声明中，必须只有一个导入(use)关键字。\r\n\r\n在导入(use)声明代码块后面必须有一行空行。\r\n\r\n示例：\r\n\r\n```php\r\n\r\n	<?php\r\n	namespace Vendor\\Package;\r\n\r\n	use FooClass;\r\n	use BarClass as Bar;\r\n	use OtherVendor\\OtherPackage\\BazClass;\r\n\r\n	// ... 其它PHP代码 ...\r\n\r\n```\r\n\r\n\r\n4. 类(class)，属性(property)和方法(method)\r\n-----------------------------------\r\n\r\n术语“类”指所有的类(class)，接口(interface)和特性(trait)。\r\n\r\n## 4.1. 扩展(extend)和实现(implement)\r\n\r\n一个类的扩展(extend)和实现(implement)关键词必须和类名(class name)在同一行。\r\n\r\n类(class)的左花括号必须放在下面自成一行；右花括号必须放在类(class)主体的后面自成一行。\r\n\r\n\r\n```php\r\n\r\n	<?php\r\n	namespace Vendor\\Package;\r\n\r\n	use FooClass;\r\n	use BarClass as Bar;\r\n	use OtherVendor\\OtherPackage\\BazClass;\r\n\r\n	class ClassName extends ParentClass implements \\ArrayAccess, \\Countable\r\n	{\r\n	    // 常量、属性、方法\r\n	}\r\n\r\n```\r\n\r\n实现(implement)列表可以被拆分为多个缩进了一次的子行。如果要拆成多个子行，列表的第一项必须要放在下一行，并且每行必须只有一个接口(interface)。\r\n\r\n```php\r\n\r\n	<?php\r\n	namespace Vendor\\Package;\r\n\r\n	use FooClass;\r\n	use BarClass as Bar;\r\n	use OtherVendor\\OtherPackage\\BazClass;\r\n\r\n	class ClassName extends ParentClass implements\r\n	    \\ArrayAccess,\r\n	    \\Countable,\r\n	    \\Serializable\r\n	{\r\n	    // 常量、属性、方法\r\n	}\r\n\r\n```\r\n\r\n## 4.2. 属性(property)\r\n\r\n所有的属性(property)都必须声明其可见性。\r\n\r\n变量(var)关键字不可用来声明一个属性(property)。\r\n\r\n一条语句不可声明多个属性(property)。\r\n\r\n属性名(property name) 不推荐用单个下划线作为前缀来表明其保护(protected)或私有(private)的可见性。\r\n\r\n一个属性(property)声明看起来应该像下面这样。\r\n\r\n```php\r\n\r\n	<?php\r\n	namespace Vendor\\Package;\r\n\r\n	class ClassName\r\n	{\r\n	    public $foo = null;\r\n	}\r\n\r\n```\r\n\r\n## 4.3. 方法(method)\r\n\r\n所有的方法(method)都必须声明其可见性。\r\n\r\n方法名(method name) 不推荐用单个下划线作为前缀来表明其保护(protected)或私有(private)的可见性。\r\n\r\n方法名(method name)在其声明后面不可有空格跟随。其左花括号必须放在下面自成一行，且右花括号必须放在方法主体的下面自成一行。左括号后面不可有空格，且右括号前面也不可有空格。\r\n\r\n一个方法(method)声明看来应该像下面这样。 注意括号，逗号，空格和花括号的位置：\r\n\r\n```php\r\n\r\n	<?php\r\n	namespace Vendor\\Package;\r\n\r\n	class ClassName\r\n	{\r\n	    public function fooBarBaz($arg1, &$arg2, $arg3 = [])\r\n	    {\r\n		// 方法主体部分\r\n	    }\r\n	}\r\n\r\n```\r\n\r\n## 4.4. 方法(method)的参数\r\n\r\n在参数列表中，逗号之前不可有空格，而逗号之后则必须要有一个空格。\r\n\r\n方法(method)中有默认值的参数必须放在参数列表的最后面。\r\n\r\n```php\r\n\r\n	<?php\r\n	namespace Vendor\\Package;\r\n\r\n	class ClassName\r\n	{\r\n	    public function foo($arg1, &$arg2, $arg3 = [])\r\n	    {\r\n		// 方法主体部分\r\n	    }\r\n	}\r\n\r\n```\r\n\r\n参数列表可以被拆分为多个缩进了一次的子行。如果要拆分成多个子行，参数列表的第一项必须放在下一行，并且每行必须只有一个参数。\r\n\r\n当参数列表被拆分成多个子行，右括号和左花括号之间必须又一个空格并且自成一行。\r\n\r\n```php\r\n\r\n	<?php\r\n	namespace Vendor\\Package;\r\n\r\n	class ClassName\r\n	{\r\n	    public function aVeryLongMethodName(\r\n		ClassTypeHint $arg1,\r\n		&$arg2,\r\n		array $arg3 = []\r\n	    ) {\r\n		// 方法主体部分\r\n	    }\r\n	}\r\n\r\n```\r\n\r\n## 4.5. 抽象(abstract)，终结(final)和 静态(static)\r\n\r\n当用到抽象(abstract)和终结(final)来做类声明时，它们必须放在可见性声明的前面。\r\n\r\n而当用到静态(static)来做类声明时，则必须放在可见性声明的后面。\r\n\r\n```php\r\n\r\n	<?php\r\n	namespace Vendor\\Package;\r\n\r\n	abstract class ClassName\r\n	{\r\n	    protected static $foo;\r\n\r\n	    abstract protected function zim();\r\n\r\n	    final public static function bar()\r\n	    {\r\n		// 方法主体部分\r\n	    }\r\n	}\r\n\r\n```\r\n\r\n## 4.6. 调用方法和函数\r\n\r\n调用一个方法或函数时，在方法名或者函数名和左括号之间不可有空格，左括号之后不可有空格，右括号之前也不可有空格。参数列表中，逗号之前不可有空格，逗号之后则必须有一个空格。\r\n\r\n```php\r\n\r\n	<?php\r\n	bar();\r\n	$foo->bar($arg1);\r\n	Foo::bar($arg2, $arg3);\r\n\r\n```\r\n\r\n参数列表可以被拆分成多个缩进了一次的子行。如果拆分成子行，列表中的第一项必须放在下一行，并且每一行必须只能有一个参数。\r\n\r\n```php\r\n\r\n	<?php\r\n	$foo->bar(\r\n	    $longArgument,\r\n	    $longerArgument,\r\n	    $muchLongerArgument\r\n	);\r\n\r\n```\r\n\r\n5. 控制结构\r\n---------------------\r\n\r\n下面是对于控制结构代码风格的概括：\r\n\r\n- 控制结构的关键词之后必须有一个空格。\r\n- 控制结构的左括号之后不可有空格。\r\n- 控制结构的右括号之前不可有空格。\r\n- 控制结构的右括号和左花括号之间必须有一个空格。\r\n- 控制结构的代码主体必须进行一次缩进。\r\n- 控制结构的右花括号必须主体的下一行。\r\n\r\n每个控制结构的代码主体必须被括在花括号里。这样可是使代码看上去更加标准化，并且加入新代码的时候还可以因此而减少引入错误的可能性。\r\n\r\n## 5.1. if，elseif，else\r\n\r\n下面是一个if条件控制结构的示例，注意其中括号，空格和花括号的位置。同时注意else和elseif要和前一个条件控制结构的右花括号在同一行。\r\n\r\n```php\r\n\r\n	<?php\r\n	if ($expr1) {\r\n	    // if body\r\n	} elseif ($expr2) {\r\n	    // elseif body\r\n	} else {\r\n	    // else body;\r\n	}\r\n\r\n```\r\n\r\n推荐用elseif来替代else if，以保持所有的条件控制关键字看起来像是一个单词。\r\n\r\n\r\n## 5.2. switch，case\r\n\r\n下面是一个switch条件控制结构的示例，注意其中括号，空格和花括号的位置。case语句必须要缩进一级，而break关键字（或其他中止关键字）必须和case结构的代码主体在同一个缩进层级。如果一个有主体代码的case结构故意的继续向下执行则必须要有一个类似于// no break的注释。\r\n\r\n```php\r\n\r\n	<?php\r\n	switch ($expr) {\r\n	    case 0:\r\n		echo ''First case, with a break'';\r\n		break;\r\n	    case 1:\r\n		echo ''Second case, which falls through'';\r\n		// no break\r\n	    case 2:\r\n	    case 3:\r\n	    case 4:\r\n		echo ''Third case, return instead of break'';\r\n		return;\r\n	    default:\r\n		echo ''Default case'';\r\n		break;\r\n	}\r\n\r\n```\r\n\r\n\r\n## 5.3. while，do while\r\n\r\n下面是一个while循环控制结构的示例，注意其中括号，空格和花括号的位置。\r\n\r\n```php\r\n\r\n	<?php\r\n	while ($expr) {\r\n	    // structure body\r\n\r\n	}\r\n\r\n```\r\n\r\n下面是一个do while循环控制结构的示例，注意其中括号，空格和花括号的位置。\r\n\r\n```php\r\n\r\n	<?php\r\n	do {\r\n	    // structure body;\r\n	} while ($expr);\r\n\r\n```\r\n\r\n## 5.4. for\r\n\r\n下面是一个for循环控制结构的示例，注意其中括号，空格和花括号的位置。\r\n\r\n```php\r\n\r\n	<?php\r\n	for ($i = 0; $i < 10; $i++) {\r\n	    // for body\r\n	}\r\n\r\n```\r\n\r\n## 5.5. foreach\r\n\r\n下面是一个foreach循环控制结构的示例，注意其中括号，空格和花括号的位置。\r\n\r\n```php\r\n\r\n	<?php\r\n	foreach ($iterable as $key => $value) {\r\n	    // foreach body\r\n	}\r\n\r\n```\r\n\r\n## 5.6. try, catch\r\n\r\n下面是一个try catch异常处理控制结构的示例，注意其中括号，空格和花括号的位置。\r\n\r\n```php\r\n\r\n	<?php\r\n	try {\r\n	    // try body\r\n	} catch (FirstExceptionType $e) {\r\n	    // catch body\r\n	} catch (OtherExceptionType $e) {\r\n	    // catch body\r\n	}\r\n\r\n```\r\n\r\n6. 闭包\r\n-----------\r\n\r\n声明闭包时所用的function关键字之后必须要有一个空格，而use关键字的前后都要有一个空格。\r\n\r\n闭包的左花括号必须跟其在同一行，而右花括号必须在闭包主体的下一行。\r\n\r\n闭包的参数列表和变量列表的左括号后面不可有空格，右括号的前面也不可有空格。\r\n\r\n闭包的参数列表和变量列表中逗号前面不可有空格，而逗号后面则必须有空格。\r\n\r\n闭包的参数列表中带默认值的参数必须放在参数列表的结尾部分。\r\n\r\n下面是一个闭包的示例。注意括号，空格和花括号的位置。\r\n\r\n```php\r\n\r\n	<?php\r\n	$closureWithArgs = function ($arg1, $arg2) {\r\n	    // body\r\n	};\r\n\r\n	$closureWithArgsAndVars = function ($arg1, $arg2) use ($var1, $var2) {\r\n	    // body\r\n	};\r\n\r\n```\r\n\r\n参数列表和变量列表可以被拆分成多个缩进了一级的子行。如果要拆分成多个子行，列表中的第一项必须放在下一行，并且每一行必须只放一个参数或变量。\r\n\r\n当列表（不管是参数还是变量）最终被拆分成多个子行，右括号和左花括号之间必须要有一个空格并且自成一行。\r\n\r\n下面是一个参数列表和变量列表被拆分成多个子行的示例。\r\n\r\n```php\r\n\r\n	<?php\r\n	$longArgs_noVars = function (\r\n	    $longArgument,\r\n	    $longerArgument,\r\n	    $muchLongerArgument\r\n	) {\r\n	   // body\r\n	};\r\n\r\n	$noArgs_longVars = function () use (\r\n	    $longVar1,\r\n	    $longerVar2,\r\n	    $muchLongerVar3\r\n	) {\r\n	   // body\r\n	};\r\n\r\n	$longArgs_longVars = function (\r\n	    $longArgument,\r\n	    $longerArgument,\r\n	    $muchLongerArgument\r\n	) use (\r\n	    $longVar1,\r\n	    $longerVar2,\r\n	    $muchLongerVar3\r\n	) {\r\n	   // body\r\n	};\r\n\r\n	$longArgs_shortVars = function (\r\n	    $longArgument,\r\n	    $longerArgument,\r\n	    $muchLongerArgument\r\n	) use ($var1) {\r\n	   // body\r\n	};\r\n\r\n	$shortArgs_longVars = function ($arg) use (\r\n	    $longVar1,\r\n	    $longerVar2,\r\n	    $muchLongerVar3\r\n	) {\r\n	   // body\r\n	};\r\n\r\n```\r\n\r\n把闭包作为一个参数在函数或者方法中调用时，依然要遵守上述规则。\r\n\r\n```php\r\n\r\n	<?php\r\n	$foo->bar(\r\n	    $arg1,\r\n	    function ($arg2) use ($var1) {\r\n		// body\r\n	    },\r\n	    $arg3\r\n	);\r\n\r\n```\r\n\r\n\r\n7. 结论\r\n--------------\r\n\r\n本指南有意的省略了许多元素的代码风格。主要包括：\r\n\r\n- 全局变量和全局常量的声明\r\n\r\n- 函数声明\r\n\r\n- 操作符和赋值\r\n\r\n- 行间对齐\r\n\r\n- 注释和文档块\r\n\r\n- 类名的前缀和后缀\r\n\r\n- 最佳实践\r\n\r\n以后的代码规范中可能会修正或扩展本指南中规定的代码风格。\r\n\r\n附录A 调查\r\n------------------\r\n\r\n为了写这个风格指南，我们调查了各个项目以最终确定通用的代码风格。并把这次调查在这里公布出来。\r\n\r\n## A.1. 调查数据\r\n\r\n    url,http://www.horde.org/apps/horde/docs/CODING_STANDARDS,http://pear.php.net/manual/en/standards.php,http://solarphp.com/manual/appendix-standards.style,http://framework.zend.com/manual/en/coding-standard.html,http://symfony.com/doc/2.0/contributing/code/standards.html,http://www.ppi.io/docs/coding-standards.html,https://github.com/ezsystems/ezp-next/wiki/codingstandards,http://book.cakephp.org/2.0/en/contributing/cakephp-coding-conventions.html,https://github.com/UnionOfRAD/lithium/wiki/Spec%3A-Coding,http://drupal.org/coding-standards,http://code.google.com/p/sabredav/,http://area51.phpbb.com/docs/31x/coding-guidelines.html,https://docs.google.com/a/zikula.org/document/edit?authkey=CPCU0Us&hgd=1&id=1fcqb93Sn-hR9c0mkN6m_tyWnmEvoswKBtSc0tKkZmJA,http://www.chisimba.com,n/a,https://github.com/Respect/project-info/blob/master/coding-standards-sample.php,n/a,Object Calisthenics for PHP,http://doc.nette.org/en/coding-standard,http://flow3.typo3.org,https://github.com/propelorm/Propel2/wiki/Coding-Standards,http://developer.joomla.org/coding-standards.html\r\n    voting,yes,yes,yes,yes,yes,yes,yes,yes,yes,yes,yes,yes,yes,yes,yes,no,no,no,?,yes,no,yes\r\n    indent_type,4,4,4,4,4,tab,4,tab,tab,2,4,tab,4,4,4,4,4,4,tab,tab,4,tab\r\n    line_length_limit_soft,75,75,75,75,no,85,120,120,80,80,80,no,100,80,80,?,?,120,80,120,no,150\r\n    line_length_limit_hard,85,85,85,85,no,no,no,no,100,?,no,no,no,100,100,?,120,120,no,no,no,no\r\n    class_names,studly,studly,studly,studly,studly,studly,studly,studly,studly,studly,studly,lower_under,studly,lower,studly,studly,studly,studly,?,studly,studly,studly\r\n    class_brace_line,next,next,next,next,next,same,next,same,same,same,same,next,next,next,next,next,next,next,next,same,next,next\r\n    constant_names,upper,upper,upper,upper,upper,upper,upper,upper,upper,upper,upper,upper,upper,upper,upper,upper,upper,upper,upper,upper,upper,upper\r\n    true_false_null,lower,lower,lower,lower,lower,lower,lower,lower,lower,upper,lower,lower,lower,upper,lower,lower,lower,lower,lower,upper,lower,lower\r\n    method_names,camel,camel,camel,camel,camel,camel,camel,camel,camel,camel,camel,lower_under,camel,camel,camel,camel,camel,camel,camel,camel,camel,camel\r\n    method_brace_line,next,next,next,next,next,same,next,same,same,same,same,next,next,same,next,next,next,next,next,same,next,next\r\n    control_brace_line,same,same,same,same,same,same,next,same,same,same,same,next,same,same,next,same,same,same,same,same,same,next\r\n    control_space_after,yes,yes,yes,yes,yes,no,yes,yes,yes,yes,no,yes,yes,yes,yes,yes,yes,yes,yes,yes,yes,yes\r\n    always_use_control_braces,yes,yes,yes,yes,yes,yes,no,yes,yes,yes,no,yes,yes,yes,yes,no,yes,yes,yes,yes,yes,yes\r\n    else_elseif_line,same,same,same,same,same,same,next,same,same,next,same,next,same,next,next,same,same,same,same,same,same,next\r\n    case_break_indent_from_switch,0/1,0/1,0/1,1/2,1/2,1/2,1/2,1/1,1/1,1/2,1/2,1/1,1/2,1/2,1/2,1/2,1/2,1/2,0/1,1/1,1/2,1/2\r\n    function_space_after,no,no,no,no,no,no,no,no,no,no,no,no,no,no,no,no,no,no,no,no,no,no\r\n    closing_php_tag_required,no,no,no,no,no,no,no,no,yes,no,no,no,no,yes,no,no,no,no,no,yes,no,no\r\n    line_endings,LF,LF,LF,LF,LF,LF,LF,LF,?,LF,?,LF,LF,LF,LF,?,,LF,?,LF,LF,LF\r\n    static_or_visibility_first,static,?,static,either,either,either,visibility,visibility,visibility,either,static,either,?,visibility,?,?,either,either,visibility,visibility,static,?\r\n    control_space_parens,no,no,no,no,no,no,yes,no,no,no,no,no,no,yes,?,no,no,no,no,no,no,no\r\n    blank_line_after_php,no,no,no,no,yes,no,no,no,no,yes,yes,no,no,yes,?,yes,yes,no,yes,no,yes,no\r\n    class_method_control_brace,next/next/same,next/next/same,next/next/same,next/next/same,next/next/same,same/same/same,next/next/next,same/same/same,same/same/same,same/same/same,same/same/same,next/next/next,next/next/same,next/same/same,next/next/next,next/next/same,next/next/same,next/next/same,next/next/same,same/same/same,next/next/same,next/next/next\r\n\r\n## A.2. 调查说明\r\n\r\n`indent_type`:\r\n缩进类型。 tab = "使用制表符"，2 or 4 = "空格数量"\r\n\r\n`line_length_limit_soft`:\r\n行长度的“软”限制，用字符。 `?` = 不表示或者数字 `no` 意为不限制.\r\n\r\n`line_length_limit_hard`:\r\n行长度的"硬"限制，用字符。 `?` = 不表示或者数字, `no` 意为不限制.\r\n\r\n`class_names`:\r\n类名如何命名 `lower` = 只是小写, `lower_under` = 小写加下划线, `studly` = 骆驼型.\r\n\r\n`class_brace_line`:\r\n类的左花括号是放在同(`same`)一行还是在下(`next`)一行？\r\n\r\n`constant_names`:\r\n类常量如何命名？`upper` = 大写加下划线分隔符。\r\n\r\n`true_false_null`:\r\n全小写或者全大写？\r\n\r\n`method_names`:\r\n方法名如何命名？`camel` = `驼峰式`, `lower_under` = 小写加下划线分隔符。\r\n\r\n`method_brace_line`:\r\n方法的左花括号在同(`same`)一行还是在下(`next`)一行？\r\n\r\n`control_brace_line`:\r\n控制结构的左花括号在同(`same`)一行还是在下(`next`)一行？\r\n\r\n`control_space_after`:\r\n控制结构关键词后是否有空格？\r\n\r\n`always_use_control_braces`:\r\n控制结构总是使用花括号？\r\n\r\n`else_elseif_line`:\r\n当使用`else`和`elseif`，是否放在同(`same`)一行还是在下(`next`)一行？\r\n\r\n`case_break_indent_from_switch`:\r\n`case`和`break`分别从`swith`语句处缩进多少次？\r\n\r\n`function_space_after`:\r\n函数调用的函数名和左括号是否有空格？\r\n\r\n`closing_php_tag_required`:\r\n如过是纯PHP文件，关闭标签`?>`是否需要？\r\n\r\n`line_endings`:\r\n使用何种的行结束符？\r\n\r\n`static_or_visibility_first`:\r\n在定义方法的时候`static`和可见性谁在前面？\r\n\r\n`control_space_parens`:\r\n在控制结构表达式中，左括号后面和右括号前面是否要有一个空格？yes = if ( $expr ), no = if ($expr).\r\n\r\n`blank_line_after_php`:\r\nPHP的开始标签后面是否需要一个空行？\r\n\r\n`class_method_control_brace`:\r\n左花括号在类，方法和控制结构中的位置。\r\n\r\n## A.3. 调查结果\r\n\r\n    indent_type:\r\n        tab: 7\r\n        2: 1\r\n        4: 14\r\n    line_length_limit_soft:\r\n        ?: 2\r\n        no: 3\r\n        75: 4\r\n        80: 6\r\n        85: 1\r\n        100: 1\r\n        120: 4\r\n        150: 1\r\n    line_length_limit_hard:\r\n        ?: 2\r\n        no: 11\r\n        85: 4\r\n        100: 3\r\n        120: 2\r\n    class_names:\r\n        ?: 1\r\n        lower: 1\r\n        lower_under: 1\r\n        studly: 19\r\n    class_brace_line:\r\n        next: 16\r\n        same: 6\r\n    constant_names:\r\n        upper: 22\r\n    true_false_null:\r\n        lower: 19\r\n        upper: 3\r\n    method_names:\r\n        camel: 21\r\n        lower_under: 1\r\n    method_brace_line:\r\n        next: 15\r\n        same: 7\r\n    control_brace_line:\r\n        next: 4\r\n        same: 18\r\n    control_space_after:\r\n        no: 2\r\n        yes: 20\r\n    always_use_control_braces:\r\n        no: 3\r\n        yes: 19\r\n    else_elseif_line:\r\n        next: 6\r\n        same: 16\r\n    case_break_indent_from_switch:\r\n        0/1: 4\r\n        1/1: 4\r\n        1/2: 14\r\n    function_space_after:\r\n        no: 22\r\n    closing_php_tag_required:\r\n        no: 19\r\n        yes: 3\r\n    line_endings:\r\n        ?: 5\r\n        LF: 17\r\n    static_or_visibility_first:\r\n        ?: 5\r\n        either: 7\r\n        static: 4\r\n        visibility: 6\r\n    control_space_parens:\r\n        ?: 1\r\n        no: 19\r\n        yes: 2\r\n    blank_line_after_php:\r\n        ?: 1\r\n        no: 13\r\n        yes: 8\r\n    class_method_control_brace:\r\n        next/next/next: 4\r\n        next/next/same: 11\r\n        next/same/same: 1\r\n        same/same/same: 6\r\n', NULL, 7, 1),
(54, 5, 50, 'PSR-3 日志接口', '<p>日志接口<br />\r\n================</p>\r\n\r\n<p>本文档描述了日志类库的通用接口。</p>\r\n\r\n<p>主要目标是让类库获得一个`Psr\\Log\\LoggerInterface`对象并能通过简单通用的方式来写日志。有自定义需求的框架和CMS`可以`根据情况扩展这个接口，但`推荐`保持和该文档的兼容性，以确保应用中使用到的第三方库能将日志集中写到应用日志里。</p>\r\n\r\n<p>[RFC 2119][]中的`必须(MUST)`，`不可(MUST NOT)`，`建议(SHOULD)`，`不建议(SHOULD NOT)`，`可以/可能(MAY)`等关键词将在本节用来做一些解释性的描述。</p>\r\n\r\n<p>关键词`实现者`在这个文档被解释为：在日志相关的库或框架实现`LoggerInterface`接口的开发人员。用这些实现者开发出来的类库的人都被称作`用户`。</p>\r\n\r\n<p>[RFC 2119]: http://tools.ietf.org/html/rfc2119</p>\r\n', '日志接口\r\n================\r\n\r\n本文档描述了日志类库的通用接口。\r\n\r\n主要目标是让类库获得一个Psr\\Log\\LoggerInterface对象并能通过简单通用的方式来写日志。有自定义需求的框架和CMS可以根据情况扩展这个接口，但推荐保持和该文档的兼容性，以确保应用中使用到的第三方库能将日志集中写到应用日志里。\r\n\r\n[RFC 2119][]中的必须(MUST)，不可(MUST NOT)，建议(SHOULD)，不建议(SHOULD NOT)，可以/可能(MAY)等关键词将在本节用来做一些解释性的描述。\r\n\r\n关键词实现者在这个文档被解释为：在日志相关的库或框架实现LoggerInterface接口的开发人员。用这些实现者开发出来的类库的人都被称作用户。\r\n\r\n[RFC 2119]: http://tools.ietf.org/html/rfc2119\r\n\r\n1. 规范\r\n-----------------\r\n\r\n## 1.1 基础\r\n\r\n- LoggerInterface暴露八个接口用来记录八个等级(debug, info, notice, warning, error, critical, alert, emergency)的日志。\r\n\r\n- 第九个方法是log，接受日志等级作为第一个参数。用一个日志等级常量来调用这个方法必须和直接调用指定等级方法的结果一致。用一个本规范中未定义且不为具体实现所知的日志等级来调用该方法必须抛出一个Psr\\Log\\InvalidArgumentException。不推荐使用自定义的日志等级，除非你非常确定当前类库对其有所支持。\r\n\r\n[RFC 5424]: http://tools.ietf.org/html/rfc5424\r\n\r\n## 1.2 消息\r\n\r\n- 每个方法都接受一个字符串，或者一个有__toString方法的对象作为message参数。实现者 可以对传入的对象有特殊的处理。如果没有，实现者 必须将它转换成字符串。\r\n\r\n- message参数中可能包含一些可以被context参数的数值所替换的占位符。\r\n\r\n\r\n  占位符名字必须和context数组类型参数的键名对应。\r\n\r\n  占位符名字必须使用一对花括号来作为分隔符。在占位符和分隔符之间不能有任何空格。\r\n\r\n  占位符名字应该只能由A-Z，a-z，0-9，下划线_和句号.组成。其它的字符作为以后占位符规范的保留字。\r\n\r\n  实现者 可以使用占位符来实现不同的转义和翻译日志成文。因为用户并不知道上下文数据会是什么，所以不推荐提前转义占位符。\r\n\r\n  下面提供一个占位符替换的例子，仅作为参考：\r\n\r\nphp\r\n\r\n    <?php\r\n	/**\r\n	* Interpolates context values into the message placeholders.\r\n	*/\r\n	function interpolate($message, array $context = array())\r\n	{\r\n		// build a replacement array with braces around the context keys\r\n		$replace = array();\r\n		foreach ($context as $key => $val) {\r\n		    $replace[''{'' . $key . ''}''] = $val;\r\n		}\r\n\r\n		// interpolate replacement values into the message and return\r\n		return strtr($message, $replace);\r\n	}\r\n\r\n	// a message with brace-delimited placeholder names\r\n	$message = "User {username} created";\r\n\r\n	// a context array of placeholder names => replacement values\r\n	$context = array(''username'' => ''bolivar'');\r\n\r\n	// echoes "Username bolivar created"\r\n	echo interpolate($message, $context);\r\n    \r\n\r\n## 1.3 上下文\r\n\r\n- 每个方法接受一个数组作为context参数，用来存储不适合在字符串中填充的信息。数组可以包括任何东西。实现者 必须确保他们尽可能包容的对context参数进行处理。一个context参数的给定值不可导致抛出异常，也不可产生任何PHP错误，警告或者提醒。\r\n\r\n- 如果在context参数中传入了一个异常对象，它必须以exception作为键名。记录异常轨迹是通用的模式，并且可以在日志系统支持的情况下从异常中提取出整个调用栈。实现者在将exception当做异常对象来使用之前必须去验证它是不是一个异常对象，因为它可能包含着任何东西。\r\n\r\n## 1.4 助手类和接口\r\n\r\n- Psr\\Log\\AbstractLogger类可以让你通过继承它并实现通用的log方法来方便的实现LoggerInterface接口。而其他八个方法将会把消息和上下文转发给log方法。\r\n\r\n- 类似的，使用Psr\\Log\\LoggerTrait只需要你实现通用的log方法。注意特性是不能用来实现接口的，所以你依然需要在你的类中implement LoggerInterface。\r\n\r\n- Psr\\Log\\NullLogger是和接口一起提供的。它在没有可用的日志记录器时，可以为使用日志接口的用户们提供一个后备的“黑洞”。但是，当context参数的构建非常耗时的时候，直接判断是否需要记录日志可能是个更好的选择。\r\n\r\n- Psr\\Log\\LoggerAwareInterface只有一个setLogger(LoggerInterface $logger)方法，它可以在框架中用来随意设置一个日志记录器。\r\n\r\n- Psr\\Log\\LoggerAwareTrait特性可以被用来在各个类中轻松实现相同的接口。通过它可以访问到$this->logger。\r\n\r\n- Psr\\Log\\LogLevel类拥有八个日志等级的常量。\r\n\r\n2. 包\r\n----------\r\n\r\n[psr/log](https://packagist.org/packages/psr/log)中提供了上文描述过的接口和类，以及相关的异常类，还有一组用来验证你的实现的单元测试。\r\n\r\n3. Psr\\Log\\LoggerInterface\r\n----------------------------\r\n\r\nphp\r\n\r\n	<?php\r\n\r\n	namespace Psr\\Log;\r\n\r\n	/**\r\n	 * Describes a logger instance\r\n	 *\r\n	 * The message MUST be a string or object implementing __toString().\r\n	 *\r\n	 * The message MAY contain placeholders in the form: {foo} where foo\r\n	 * will be replaced by the context data in key "foo".\r\n	 *\r\n	 * The context array can contain arbitrary data, the only assumption that\r\n	 * can be made by implementors is that if an Exception instance is given\r\n	 * to produce a stack trace, it MUST be in a key named "exception".\r\n	 *\r\n	 * See https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-3-logger-interface.md\r\n	 * for the full interface specification.\r\n	 */\r\n	interface LoggerInterface\r\n	{\r\n	    /**\r\n	     * System is unusable.\r\n	     *\r\n	     * @param string $message\r\n	     * @param array $context\r\n	     * @return null\r\n	     */\r\n	    public function emergency($message, array $context = array());\r\n\r\n	    /**\r\n	     * Action must be taken immediately.\r\n	     *\r\n	     * Example: Entire website down, database unavailable, etc. This should\r\n	     * trigger the SMS alerts and wake you up.\r\n	     *\r\n	     * @param string $message\r\n	     * @param array $context\r\n	     * @return null\r\n	     */\r\n	    public function alert($message, array $context = array());\r\n\r\n	    /**\r\n	     * Critical conditions.\r\n	     *\r\n	     * Example: Application component unavailable, unexpected exception.\r\n	     *\r\n	     * @param string $message\r\n	     * @param array $context\r\n	     * @return null\r\n	     */\r\n	    public function critical($message, array $context = array());\r\n\r\n	    /**\r\n	     * Runtime errors that do not require immediate action but should typically\r\n	     * be logged and monitored.\r\n	     *\r\n	     * @param string $message\r\n	     * @param array $context\r\n	     * @return null\r\n	     */\r\n	    public function error($message, array $context = array());\r\n\r\n	    /**\r\n	     * Exceptional occurrences that are not errors.\r\n	     *\r\n	     * Example: Use of deprecated APIs, poor use of an API, undesirable things\r\n	     * that are not necessarily wrong.\r\n	     *\r\n	     * @param string $message\r\n	     * @param array $context\r\n	     * @return null\r\n	     */\r\n	    public function warning($message, array $context = array());\r\n\r\n	    /**\r\n	     * Normal but significant events.\r\n	     *\r\n	     * @param string $message\r\n	     * @param array $context\r\n	     * @return null\r\n	     */\r\n	    public function notice($message, array $context = array());\r\n\r\n	    /**\r\n	     * Interesting events.\r\n	     *\r\n	     * Example: User logs in, SQL logs.\r\n	     *\r\n	     * @param string $message\r\n	     * @param array $context\r\n	     * @return null\r\n	     */\r\n	    public function info($message, array $context = array());\r\n\r\n	    /**\r\n	     * Detailed debug information.\r\n	     *\r\n	     * @param string $message\r\n	     * @param array $context\r\n	     * @return null\r\n	     */\r\n	    public function debug($message, array $context = array());\r\n\r\n	    /**\r\n	     * Logs with an arbitrary level.\r\n	     *\r\n	     * @param mixed $level\r\n	     * @param string $message\r\n	     * @param array $context\r\n	     * @return null\r\n	     */\r\n	    public function log($level, $message, array $context = array());\r\n	}\r\n\r\n\r\n4. Psr\\Log\\LoggerAwareInterface\r\n---------------------------------\r\n\r\nphp\r\n\r\n	<?php\r\n\r\n	namespace Psr\\Log;\r\n\r\n	/**\r\n	 * Describes a logger-aware instance\r\n	 */\r\n	interface LoggerAwareInterface\r\n	{\r\n	    /**\r\n	     * Sets a logger instance on the object\r\n	     *\r\n	     * @param LoggerInterface $logger\r\n	     * @return null\r\n	     */\r\n	    public function setLogger(LoggerInterface $logger);\r\n	}\r\n\r\n\r\n5. Psr\\Log\\LogLevel\r\n---------------------\r\n\r\nphp\r\n\r\n	<?php\r\n\r\n	namespace Psr\\Log;\r\n\r\n	/**\r\n	 * Describes log levels\r\n	 */\r\n	class LogLevel\r\n	{\r\n	    const EMERGENCY = ''emergency'';\r\n	    const ALERT     = ''alert'';\r\n	    const CRITICAL  = ''critical'';\r\n	    const ERROR     = ''error'';\r\n	    const WARNING   = ''warning'';\r\n	    const NOTICE    = ''notice'';\r\n	    const INFO      = ''info'';\r\n	    const DEBUG     = ''debug'';\r\n	}\r\n\r\n', NULL, 6, 1);
INSERT INTO `g_booknode` (`nodeid`, `bookid`, `preid`, `title`, `nr`, `nrcode`, `type`, `sort`, `enable`) VALUES
(55, 5, 50, 'PSR-4 自动载入', '<p>这个 PSR 描述的是通过文件路径[自动载入][]类的指南；它作为对 [PSR-0][] 的补充；根据这个<br />\r\n指导如何规范存放文件来自动载入；</p>\r\n', '## 1. 概况\r\n\r\n这个 PSR 描述的是通过文件路径[自动载入][]类的指南；它作为对 [PSR-0][] 的补充；根据这个\r\n指导如何规范存放文件来自动载入；\r\n\r\n## 2. 说明（Specification）\r\n\r\n1. 术语「类」是一个泛称；它包含类，接口，traits 以及其他类似的结构；\r\n\r\n2. 完全限定类名应该类似如下范例：\r\n\r\n    \\< NamespaceName>(\\< SubNamespaceNames>)*\\< ClassName>\r\n\r\n    -  完全限定类名必须有一个顶级命名空间（Vendor Name）；\r\n    -  完全限定类名可以有多个子命名空间；\r\n    -  完全限定类名应该有一个终止类名；\r\n    -  下划线在完全限定类名中是没有特殊含义的；\r\n    -  字母在完全限定类名中可以是任何大小写的组合；\r\n    -  所有类名必须以大小写敏感的方式引用；\r\n\r\n3. 当从完全限定类名载入文件时：\r\n\r\n    -  在完全限定类名中，连续的一个或几个子命名空间构成的命名空间前缀（不包括顶级命名空间的分隔符），至少对应着至少一个基础目录。\r\n    -  在「命名空间前缀」后的连续子命名空间名称对应一个「基础目录」下的子目录，其中的命名\r\n空间分隔符表示目录分隔符。子目录名称必须和子命名空间名大小写匹配；\r\n    -  终止类名对应一个以 .php 结尾的文件。文件名必须和终止类名大小写匹配；\r\n\r\n4. 自动载入器的实现不可抛出任何异常，不可引发任何等级的错误；也不应返回值；\r\n\r\n## 3. 范例\r\n\r\n如下表格展示的是与完全限定类名、命名空间前缀和基础目录相对应的文件路径：\r\n\r\n| 完全限定类名                    | 命名空间前缀       | 基础目录                 | 实际的文件路径\r\n| ----------------------------- |--------------------|--------------------------|-------------------------------------------\r\n| \\Acme\\Log\\Writer\\File_Writer  | Acme\\Log\\Writer    | ./acme-log-writer/lib/   | ./acme-log-writer/lib/File_Writer.php\r\n| \\Aura\\Web\\Response\\Status     | Aura\\Web           | /path/to/aura-web/src/   | /path/to/aura-web/src/Response/Status.php\r\n| \\Symfony\\Core\\Request         | Symfony\\Core       | ./vendor/Symfony/Core/   | ./vendor/Symfony/Core/Request.php\r\n| \\Zend\\Acl                     | Zend               | /usr/includes/Zend/      | /usr/includes/Zend/Acl.php\r\n\r\n例子中的自动载入器非常适应这个指南，请参照 [示例文件][]。由于可能随时变更，实例不能作为指南的一部分。\r\n\r\n[自动载入]: http://php.net/autoload\r\n[PSR-0]: https://github.com/hfcorriez/fig-standards/tree/master/accepted/zh_CN/PSR-0.md\r\n[示例文件]: http://www.php-fig.org/psr/psr-4/PSR-4-autoloader-examples.md\r\n', NULL, 0, 1),
(34, 3, 40, 'SVN', '<p>SVN是Subversion的简称，是一个开放源代码的版本控制系统，相较于RCS、CVS，它采用了分支管理系统，它的设计目标就是取代CVS。互联网上很多版本控制服务已从CVS迁移到Subversion。</p>\r\n', '在内网开发环境,SVN地址为: https://192.168.0.10/svn/m.so/\r\n\r\n用户名 irones\r\n\r\n密码 irones', 'con', -1, 1),
(35, 3, 46, 'Mysql', '<p><strong>MySQL 是一个关系型数据库管理系统，</strong>由瑞典 MySQL AB 公司开发，目前属于 Oracle 旗下公司。MySQL 最流行的关系型数据库管理系统，在 WEB 应用方面 MySQL 是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件之一。MySQL 是一种关联数据库管理系统， 关联数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。MySQL 所使用的 SQL 语言是用于访问数据库的最常用标准化语言。MySQL 软件采用了双授权政策（本词条&ldquo;授权政策&rdquo;），它分为社区版和商业版，由于其体积小、速度快、总体拥有成本低，尤其是开放源码这一特点，一般中小型网站的开发都选择 MySQL 作为网站数据库。由于其社区版的性能卓越，搭配 PHP 和 Apache 可组成良好的开发环境。</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;hostname&quot;&nbsp; =&gt;&nbsp; &#39;127.0.0.1&#39;,<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;username&quot;&nbsp; =&gt;&nbsp; &#39;gracemain&#39;,<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;password&quot;&nbsp; =&gt;&nbsp; &#39;gracemain&#39;,<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;database&quot;&nbsp; =&gt;&nbsp; &#39;gracemain&#39;,</p>\r\n\r\n<p>在程序中默认调用的是default库</p>\r\n\r\n<p>可采用的或者预留采用的数据库技术包括</p>\r\n\r\n<ol>\r\n	<li>索引</li>\r\n	<li>分库</li>\r\n	<li>读写分离</li>\r\n	<li>分布式</li>\r\n	<li>集群</li>\r\n	<li>分表</li>\r\n	<li>索引</li>\r\n	<li>缓存</li>\r\n</ol>\r\n', '    ''mysql''=>[\r\n        ''default2''=>[\r\n            "hostname"  =>  ''rdsoyq134we31od4l8uwi.mysql.rds.aliyuncs.com'',\r\n            "username"  =>  ''nsv1'',\r\n            "password"  =>  ''nsv1nsv1'',\r\n            "database"  =>  ''rvfjbvj6il30zoiq'',\r\n            "charset"   =>  ''utf8'',\r\n            "pconnect"  =>  0,\r\n            "quiet"     =>  0\r\n        ],\r\n        ''default''=>[\r\n            "hostname"  =>  ''127.0.0.1'',\r\n            "username"  =>  ''gracemain'',\r\n            "password"  =>  ''gracemain'',\r\n            "database"  =>  ''gracemain'',\r\n            "charset"   =>  ''utf8'',\r\n            "pconnect"  =>  0,\r\n            "quiet"     =>  0\r\n        ],\r\n    ],\r\n    \r\n\r\n####路线图\r\n\r\n    单库索引\r\n    缓存\r\n    分库\r\n    读写分离\r\n    分表\r\n    分布式\r\n    集群\r\n    \r\n    分表有不同的策略,要根据需要进行选择和使用', NULL, 0, 1),
(36, 3, 46, 'Memcache', '<p><strong>memcache</strong>是一套分布式的高速缓存系统，由LiveJournal的Brad Fitzpatrick开发，但目前被许多网站使用以提升网站的访问速度，尤其对于一些大型的、需要频繁访问数据库的网站访问速度提升效果十分显著。这是一套开放源代码软件，以BSD license授权发布。</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Memcache分布式</strong></p>\r\n\r\n<ol>\r\n	<li>检查客户端的请求数据是否在memcached中，如有，直接把请求数据返回，不再对数据库进行任何操作，路径操作为①②③⑦。</li>\r\n	<li>如果请求的数据不在memcached中，就去查数据库，把从数据库中获取的数据返回给客户端，同时把数据缓存一份到memcached中（memcached客户端不负责，需要程序明确实现），路径操作为①②④⑤⑦⑥。</li>\r\n	<li>每次更新数据库的同时更新memcached中的数据，保证一致性。</li>\r\n	<li>当分配给memcached内存空间用完之后，会使用LRU（Least Recently Used，最近最少使用）策略加上到期失效策略，失效数据首先被替换，然后再替换掉最近未使用的数据。</li>\r\n</ol>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>Memcached的分布式</strong></p>\r\n\r\n<p><br />\r\n当向memcached集群存入/取出key/value时，memcached客户端程序根据一定的算法计算存入哪台服务器，然后再把key/value值存到此服务器中。也就是说，存取数据分二步走，第一步，选择服务器，第二步存取数据。</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>分布式算法(Consistent Hashing)：</strong><br />\r\n<br />\r\n选择服务器算法有两种，一种是根据余数来计算分布，另一种是根据散列算法来计算分布。<br />\r\n<strong>余数算法：</strong><br />\r\n先求得键的整数散列值，再除以服务器台数，根据余数确定存取服务器，这种方法计算简单，高效，但在memcached服务器增加或减少时，几乎所有的缓存都会失效。<br />\r\n<strong>散列算法：</strong><br />\r\n先 算出memcached服务器的散列值，并将其分布到0到2的32次方的圆上，然后用同样的方法算出存储数据的键的散列值并映射至圆上，最后从数据映射到 的位置开始顺时针查找，将数据保存到查找到的第一个服务器上，如果超过2的32次方，依然找不到服务器，就将数据保存到第一台memcached服务器 上。如果添加了一台memcached服务器，只在圆上增加服务器的逆时针方向的第一台服务器上的键会受到影响。</p>\r\n', '##Memcache分布式\r\n\r\n![](/Upload/20120918153149100.jpg)\r\n\r\n##Memcache分布式\r\n\r\n![](/Upload/20120918153149105.jpg)\r\n\r\n##Memcached的分布式算法\r\n\r\n![](/Upload/20120918153149106.jpg)', NULL, 0, 1),
(37, 3, 46, 'Mongodb', '<p>Mongo DB 是目前在IT行业非常流行的一种非关系型数据库(NoSql),其灵活的数据存储方式备受当前IT从业人员的青睐。Mongo DB很好的实现了面向对象的思想(OO思想),在Mongo DB中 每一条记录都是一个Document对象。Mongo DB最大的优势在于所有的数据持久操作都无需开发人员手动编写SQL语句,直接调用方法就可以轻松的实现CRUD操作。</p>\r\n', '分布式Mongodb部署和使用\r\n\r\n\r\n', NULL, 0, 1),
(38, 3, 46, '文档系统', '', '', NULL, 0, 1),
(39, 3, 0, 'PHP扩展和模块', '<p>xcache</p>\r\n', '    xcache', NULL, 0, 1),
(40, 3, 0, '版本控制和发布', '', '', NULL, 9, 1),
(41, 3, 0, '前端', '<p>这里的前端是指站点的html css js 部分</p>\r\n', '', NULL, 7, 1),
(42, 3, 46, 'Redis', '<p>Redis是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。从2010年3月15日起，Redis的开发工作由VMware主持。从2013年5月开始，Redis的开发由Pivotal赞助。</p>\r\n', '', NULL, 0, 1),
(43, 3, 40, 'Apache', '<p>Apache是世界使用排名第一的Web服务器软件。它可以运行在几乎所有广泛使用的计算机平台上，由于其跨平台和安全性被广泛使用，是最流行的Web服务器端软件之一。它快速、可靠并且可通过简单的API扩充，将Perl/Python等解释器编译到服务器中。</p>\r\n', '    \r\n    LoadModule rewrite_module modules/mod_rewrite.so\r\n    \r\n    LoadModule include_module modules/mod_include.so\r\n    \r\n##=========httpd.conf begin===================\r\n    \r\n##Apache主配置文件\r\n##设置服务器的基础目录,默认为Apache安装目录\r\nServerRoot "/usr/local/apache-2.2.6"\r\n##设置服务器监听的IP和端口\r\nListen 80\r\n##设置管理员邮件地址\r\n\r\n##设置服务器用于辨识自己的主机名和端口号\r\nServerName www.uenu.com:80\r\n###设置动态加载的DSO模块\r\n##如果需要提供基于文本文件的认证,加载此模块，否则注释掉\r\nLoadModule authn_file_module modules/mod_authn_file.so\r\n##如果需要提供基于DBM文件的认证,加载此模块,否则注释掉\r\nLoadModule authn_dbm_module modules/mod_authn_dbm.so\r\n##如果需要提供匿名用户认证,加载此模块,否则注释掉\r\nLoadModule authn_anon_module modules/mod_authn_anon.so\r\n##如果需要提供基于SQL数据库的认证,加载此模块,否则注释掉\r\nLoadModule authn_dbd_module modules/mod_authn_dbd.so\r\n##如果需要在未正确配置认证模块的情况下简单拒绝一切认证信息,加载此模块,否则注释掉\r\nLoadModule authn_default_module modules/mod_authn_default.so\r\n##此模块提供基于主机名、IP地址、请求特征的访问控制,Allow、Deny指令需要,推荐加载。\r\nLoadModule authz_host_module modules/mod_authz_host.so\r\n##如果需要使用纯文本文件为组提供授权支持,加载此模块,否则注释掉\r\nLoadModule authz_groupfile_module modules/mod_authz_groupfile.so\r\n##如果需要提供基于每个用户的授权支持,加载此模块,否则注释掉\r\nLoadModule authz_user_module modules/mod_authz_user.so\r\n##如果需要使用DBM文件为组提供授权支持,加载此模块,否则注释掉\r\nLoadModule authz_dbm_module modules/mod_authz_dbm.so\r\n##如果需要基于文件的所有者进行授权,加载此模块,否则注释掉\r\nLoadModule authz_owner_module modules/mod_authz_owner.so\r\n##如果需要在未正确配置授权支持模块的情况下简单拒绝一切授权请求,加载此模块,否则注释掉\r\nLoadModule authz_default_module modules/mod_authz_default.so\r\n##如果需要提供基本的HTTP认证,加载此模块,否则注释掉,此模块至少需要同时加载一个认证支持模块和一个授权支持模块\r\nLoadModule auth_basic_module modules/mod_auth_basic.so\r\n##如果需要提供HTTP MD5摘要认证,加载此模块,否则注释掉,此模块至少需要同时加载一个认证支持模块和一个授权支持模块\r\nLoadModule auth_digest_module modules/mod_auth_digest.so\r\n##此模块提供文件描述符缓存支持,从而提高Apache性能,推荐加载,但请小心使用\r\nLoadModule file_cache_module modules/mod_file_cache.so\r\n##此模块提供基于URI键的内容动态缓存(内存或磁盘),从而提高Apache性能,必须与mod_disk_cache/mod_mem_cache同时使用,推荐加载\r\nLoadModule cache_module modules/mod_cache.so\r\n##此模块为mod_cache提供基于磁盘的缓存管理,推荐加载\r\nLoadModule disk_cache_module modules/mod_disk_cache.so\r\n##此模块为mod_cache提供基于内存的缓存管理,推荐加载\r\nLoadModule mem_cache_module modules/mod_mem_cache.so\r\n##如果需要管理SQL数据库连接，为需要数据库功能的模块提供支持,加载此模块,否则注释掉(推荐)\r\nLoadModule dbd_module modules/mod_dbd.so\r\n##此模块将所有I/O操作转储到错误日志中,会导致在日志中写入及其海量的数据,只建议在发现问题并进行调试的时候使用\r\nLoadModule dumpio_module modules/mod_dumpio.so\r\n##如果需要使用外部程序作为过滤器,加载此模块(不推荐),否则注释掉\r\nLoadModule ext_filter_module modules/mod_ext_filter.so\r\n##如果需要实现服务端包含文档(SSI)处理,加载此模块(不推荐),否则注释掉\r\nLoadModule include_module modules/mod_include.so\r\n##如果需要根据上下文实际情况对输出过滤器进行动态配置,加载此模块,否则注释掉\r\nLoadModule filter_module modules/mod_filter.so\r\n##如果需要服务器在将输出内容发送到客户端以前进行压缩以节约带宽,加载此模块(推荐),否则注释掉\r\nLoadModule deflate_module modules/mod_deflate.so\r\n##如果需要记录日志和定制日志文件格式,加载此模块(推荐),否则注释掉\r\nLoadModule log_config_module modules/mod_log_config.so\r\n##如果需要对每个请求的输入/输出字节数以及HTTP头进行日志记录,加载此模块,否则注释掉\r\nLoadModule logio_module modules/mod_logio.so\r\n##如果允许Apache修改或清除传送到CGI脚本和SSI页面的环境变量,加载此模块,否则注释掉\r\nLoadModule env_module modules/mod_env.so\r\n##如果允许通过配置文件控制HTTP的"Expires:"和"Cache-Control:"头内容,加载此模块(推荐),否则注释掉\r\nLoadModule expires_module modules/mod_expires.so\r\n##如果允许通过配置文件控制任意的HTTP请求和应答头信息,加载此模块,否则注释掉\r\nLoadModule headers_module modules/mod_headers.so\r\n##如果需要实现RFC1413规定的ident查找,加载此模块(不推荐),否则注释掉\r\nLoadModule ident_module modules/mod_ident.so\r\n##如果需要根据客户端请求头字段设置环境变量,加载此模块,否则注释掉\r\nLoadModule setenvif_module modules/mod_setenvif.so\r\n##此模块是mod_proxy的扩展,提供Apache JServ Protocol支持,只在必要时加载\r\nLoadModule proxy_ajp_module modules/mod_proxy_ajp.so\r\n##此模块是mod_proxy的扩展,提供负载均衡支持,只在必要时加载\r\nLoadModule proxy_balancer_module modules/mod_proxy_balancer.so\r\n##如果需要根据文件扩展名决定应答的行为(处理器/过滤器)和内容(MIME类型/语言/字符集/编码),加载此模块,否则注释掉\r\nLoadModule mime_module modules/mod_mime.so\r\n##如果允许Apache提供DAV协议支持,加载此模块,否则注释掉\r\nLoadModule dav_module modules/mod_dav.so\r\n##此模块生成描述服务器状态的Web页面,只建议在追踪服务器性能和问题时加载\r\nLoadModule status_module modules/mod_status.so\r\n##如果需要自动对目录中的内容生成列表(类似于"ls"或"dir"命令),加载此模块(会带来安全问题,不推荐),否则注释掉\r\nLoadModule autoindex_module modules/mod_autoindex.so\r\n##如果需要服务器发送自己包含HTTP头内容的文件,加载此模块,否则注释掉\r\nLoadModule asis_module modules/mod_asis.so\r\n##如果需要生成Apache配置情况的Web页面,加载此模块(会带来安全问题,不推荐),否则注释掉\r\nLoadModule info_module modules/mod_info.so\r\n##如果需要在非线程型MPM(prefork)上提供对CGI脚本执行的支持,加载此模块,否则注释掉\r\nLoadModule cgi_module modules/mod_cgi.so\r\n##此模块在线程型MPM(worker)上用一个外部CGI守护进程执行CGI脚本,如果正在多线程模式下使用CGI程序,推荐替换mod_cgi加载,否则注释掉\r\nLoadModule cgid_module modules/mod_cgid.so\r\n##此模块为mod_dav访问服务器上的文件系统提供支持,如果加载mod_dav,则也应加载此模块,否则注释掉\r\nLoadModule dav_fs_module modules/mod_dav_fs.so\r\n##如果需要提供大批量虚拟主机的动态配置支持,加载此模块,否则注释掉\r\nLoadModule vhost_alias_module modules/mod_vhost_alias.so\r\n##如果需要提供内容协商支持(从几个有效文档中选择一个最匹配客户端要求的文档),加载此模块(推荐),否则注释掉\r\nLoadModule negotiation_module modules/mod_negotiation.so\r\n##如果需要指定目录索引文件以及为目录提供"尾斜杠"重定向,加载此模块(推荐),否则注释掉\r\nLoadModule dir_module modules/mod_dir.so\r\n##如果需要处理服务器端图像映射,加载此模块,否则注释掉\r\nLoadModule imagemap_module modules/mod_imagemap.so\r\n##如果需要针对特定的媒体类型或请求方法执行CGI脚本,加载此模块,否则注释掉\r\nLoadModule actions_module modules/mod_actions.so\r\n##如果希望服务器自动纠正URL中的拼写错误,加载此模块(推荐),否则注释掉\r\nLoadModule speling_module modules/mod_speling.so\r\n##如果允许在URL中通过"/~username"形式从用户自己的主目录中提供页面,加载此模块,否则注释掉\r\nLoadModule userdir_module modules/mod_userdir.so\r\n##此模块提供从文件系统的不同部分到文档树的映射和URL重定向,推荐加载\r\nLoadModule alias_module modules/mod_alias.so\r\n##如果需要基于一定规则实时重写URL请求,加载此模块(推荐),否则注释掉\r\nLoadModule rewrite_module modules/mod_rewrite.so ', NULL, 0, 1),
(44, 3, 40, 'Nginx', '<p>Nginx (&quot;engine x&quot;) 是一个高性能的 HTTP 和 反向代理 服务器，也是一个 IMAP/POP3/SMTP 服务器。 Nginx 是由 Igor Sysoev 为俄罗斯访问量第二的 Rambler.ru 站点开发的，第一个公开版本0.1.0发布于2004年10月4日。其将源代码以类BSD许可证的形式发布，因它的稳定性、丰富的功能集、示例配置文件和低系统资源的消耗而闻名。2011年6月1日，nginx 1.0.4发布。</p>\r\n\r\n<p><strong>Nginx</strong>是 一款轻量级的Web 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器，并在一个BSD-like 协议下发行。由俄罗斯的程序设计师Igor Sysoev所开发，供俄国大型的入口网站及搜索引擎Rambler（俄文：Рамблер）使用。其特点是占有内存少，并发能力强，事实上nginx的并发能力确实在同类型的网页服务器中表现较好，中国大陆使用nginx网站用户有：百度、新浪、网易、腾讯等。</p>\r\n', '', NULL, 0, 1),
(45, 3, 40, 'Github', '<p>Git是一个分布式的版本控制系统，最初由Linus Torvalds编写，用作Linux内核代码的管理。在推出后，Git在其它项目中也取得了很大成功，尤其是在Ruby社区中。目前，包括Rubinius、Merb和Bitcoin在内的很多知名项目都使用了Git。Git同样可以被诸如Capistrano和Vlad the Deployer这样的部署工具所使用。</p>\r\n', 'https://github.com/shampeak/m.so/', NULL, -1, 1),
(46, 3, 0, '数据存储', '<p>数据存储</p>\r\n\r\n<ol>\r\n	<li>Sql</li>\r\n	<li>NoSql</li>\r\n	<li>Cache</li>\r\n</ol>\r\n', '', NULL, 8, 1),
(47, 3, 41, 'A目录', '', '', NULL, 0, 1),
(48, 3, 0, '问题', '<p>Mongodb 和 Mysql 的区别</p>\r\n\r\n<p>Mysql 索引的原理</p>\r\n\r\n<p>两个的深入理解<br />\r\n&nbsp;</p>\r\n', '', NULL, -2, 1),
(49, 3, 0, '框架内部署', '<ol>\r\n	<li>路由router</li>\r\n	<li>配置config</li>\r\n	<li>request</li>\r\n	<li>application</li>\r\n	<li>cache</li>\r\n	<li>db</li>\r\n	<li>user</li>\r\n	<li>rbac</li>\r\n</ol>\r\n', '    路由router\r\n    配置config\r\n    request\r\n    application\r\n    cache\r\n    db\r\n    user\r\n    rbac', NULL, -9, 1),
(56, 3, 0, '第三方支持', '<p>第三方的组件支持</p>\r\n', '', NULL, 6, 1),
(57, 3, 56, '短信验证码', '<p>参考</p>\r\n\r\n<p>http://www.yuntongxun.com/ability/toPriceTariff</p>\r\n\r\n<p>参考</p>\r\n\r\n<p>http://www.yuntongxun.com/activity/smsIdentifying#tiyan</p>\r\n', '![](/Upload/Yzm.jpg)', NULL, 0, 1),
(58, 3, 56, '图片存储', '<p>参考</p>\r\n\r\n<p>http://developer.qiniu.com/docs/v6/index.html</p>\r\n\r\n<p>参考 http://developer.qiniu.com/docs/v6/api/overview/programming-model.html</p>\r\n\r\n<ul>\r\n	<li>\r\n	<p>下载</p>\r\n\r\n	<p>公开资源因为不需要对应的下载凭证即可访问，客户端可以直接从七牛云存储下载对应资源。私有资源因为需要对应的下载凭证，因此必须先和业务服务器打交道。</p>\r\n\r\n	<p>按照实际的使用场景，客户端对于内容的展示非常类似于一个动态网页的生成过程，因此无论该页面内容是公开还是私有，均需要从业务服务器获取该展示页面的动态布局信息。所以通常显示过程也是需要先后和业务服务器及七牛云存储服务打交道。</p>\r\n	</li>\r\n	<li>\r\n	<p>资源管理</p>\r\n\r\n	<p>为了防止安全漏洞，资源管理操作应该只在业务服务器端进行。如果允许客户端进行资源管理，即使将管理凭证的生成动作放到业务服务器端进行，仍然很容易被第三方截获请求全文，从而导致重放攻击的风险。</p>\r\n	</li>\r\n</ul>\r\n', '##上传\r\n\r\n>客户端在上传资源到七牛云存储之前要先从业务服务器获取一个有效的上传凭证，因此需要先后和两个服务端打交道。\r\n\r\n![](/Upload/basic-upload.png)\r\n\r\n>如果有设置回调，则上传完成时七牛云存储会自动发起回调到指定的业务服务器。\r\n\r\n![](/Upload/upload-with-callback.png)\r\n\r\n\r\n', NULL, 0, 1),
(59, 3, 56, '及时通讯', '<p>融云 : http://www.rongcloud.cn/</p>\r\n\r\n<p>架构介绍</p>\r\n\r\n<p>融云提供的即时消息传输服务，不在 App 之外建立并行的用户体系，不需要同步用户账户，不影响 App 现有的系统架构与帐号体系，与现有业务体系能够实现完美融合。</p>\r\n\r\n<p>融云的架构设计上具有如下特点：</p>\r\n\r\n<ul>\r\n	<li>无需改变现有 App 的架构，直接嵌入现有代码框架中；</li>\r\n	<li>无需改变现有 App Server 的架构，独立部署一份用于用户授权的 Service 即可；</li>\r\n	<li>专注于提供通讯能力，使用私有的二进制通信协议，消息轻量、有序、不丢消息；</li>\r\n	<li>安全的身份认证和授权方式，无需担心 SDK 能力滥用（盗用身份的垃圾消息、垃圾群发）问题。</li>\r\n</ul>\r\n\r\n<p>如图：</p>\r\n\r\n<p>蓝色为您的应用（App）和应用服务器（App Server），用户数据（User Data）和用户好友消息（Friend Relationship Data）保存在您的应用服务器上，融云不需要同步 App 的用户系统和好友关系；绿色为融云服务器（RongCloud Server）和融云 SDK，支持快速集成和平滑迁移。</p>\r\n\r\n<p>蓝色箭头表示您自己的业务数据经由您自己的应用服务器；绿色箭头表示消息需要经过融云服务器转发（IM 的离线、通知等逻辑决定了消息必须经由服务器进行一次转发）；橙色箭头表示您的应用服务器只需要和融云服务器进行身份授权，不需要您提交详细用户资料。</p>\r\n', '##架构介绍\r\n\r\n![](/Upload/archietecture.png)', NULL, 0, 1),
(60, 3, 56, '消息推送', '<h1>融云</h1>\r\n\r\n<ul>\r\n	<li>&nbsp;&nbsp;&nbsp; 通知（Notification）</li>\r\n	<li>&nbsp;&nbsp;&nbsp; 推送（Push）</li>\r\n	<li>&nbsp;&nbsp;&nbsp; 广播（Broadcast）</li>\r\n	<li>&nbsp;&nbsp;&nbsp; 系统消息（System Message）</li>\r\n</ul>\r\n\r\n<p>参考http://www.rongcloud.cn/docs/message_and_push_system.html</p>\r\n', '', NULL, 0, 1),
(61, 3, 56, '第三方登录', '<p>第三方登录包括</p>\r\n\r\n<ol>\r\n	<li>QQ登录</li>\r\n	<li>微博登录</li>\r\n	<li>微信登录</li>\r\n</ol>\r\n', '', NULL, 0, 1),
(62, 5, 0, 'HTTP状态码', '<p>HTTP状态码（HTTP Status Code）是用以表示网页服务器HTTP响应状态的3位数字代码。它由 RFC 2616 规范定义的，并得到RFC 2518、RFC 2817、RFC 2295、RFC 2774、RFC 4918等规范扩展。</p>\r\n', '', NULL, 0, 1),
(63, 5, 62, '消息（1字头）', '<p>100 Continue</p>\r\n\r\n<p>客户端应当继续发送请求。这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应。</p>\r\n\r\n<p>101 Switching Protocols</p>\r\n\r\n<p>服务器已经理解了客户端的请求，并将通过Upgrade 消息头通知客户端采用不同的协议来完成这个请求。在发送完这个响应最后的空行后，服务器将会切换到在Upgrade 消息头中定义的那些协议。</p>\r\n\r\n<p>只有在切换新的协议更有好处的时候才应该采取类似措施。例如，切换到新的HTTP 版本比旧版本更有优势，或者切换到一个实时且同步的协议以传送利用此类特性的资源。</p>\r\n\r\n<p>102 Processing</p>\r\n\r\n<p>由WebDAV（RFC 2518）扩展的状态码，代表处理将被继续执行。</p>\r\n', '##这一类型的状态码，代表请求已被接受，需要继续处理。这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行结束。由于 HTTP/1.0 协议中没有定义任何 1xx 状态码，所以除非在某些试验条件下，服务器禁止向此类客户端发送 1xx 响应。\r\n\r\n\r\n- 100 Continue\r\n- 101 Switching Protocols\r\n- 102 Processing', NULL, 0, 1),
(64, 5, 62, '成功（2字头）', '<p>200 OK</p>\r\n\r\n<p>请求已成功，请求所希望的响应头或数据体将随此响应返回。</p>\r\n\r\n<p>201 Created</p>\r\n\r\n<p>请求已经被实现，而且有一个新的资源已经依据请求的需要而建立，且其 URI 已经随Location 头信息返回。假如需要的资源无法及时建立的话，应当返回 &#39;202 Accepted&#39;。</p>\r\n\r\n<p>202 Accepted</p>\r\n\r\n<p>服务器已接受请求，但尚未处理。正如它可能被拒绝一样，最终该请求可能会也可能不会被执行。在异步操作的场合下，没有比发送这个状态码更方便的做法了。</p>\r\n\r\n<p>返回202状态码的响应的目的是允许服务器接受其他过程的请求（例如某个每天只执行一次的基于批处理的操作），而不必让客户端一直保持与服务器的连接直到批处理操作全部完成。在接受请求处理并返回202状态码的响应应当在返回的实体中包含一些指示处理当前状态的信息，以及指向处理状态监视器或状态预测的指针，以便用户能够估计操作是否已经完成。</p>\r\n\r\n<p>203 Non-Authoritative Information</p>\r\n\r\n<p>服务器已成功处理了请求，但返回的实体头部元信息不是在原始服务器上有效的确定集合，而是来自本地或者第三方的拷贝。当前的信息可能是原始版本的子集或者超集。例如，包含资源的元数据可能导致原始服务器知道元信息的超集。使用此状态码不是必须的，而且只有在响应不使用此状态码便会返回200 OK的情况下才是合适的。</p>\r\n\r\n<p>204 No Content</p>\r\n\r\n<p>服务器成功处理了请求，但不需要返回任何实体内容，并且希望返回更新了的元信息。响应可能通过实体头部的形式，返回新的或更新后的元信息。如果存在这些头部信息，则应当与所请求的变量相呼应。</p>\r\n\r\n<p>如果客户端是浏览器的话，那么用户浏览器应保留发送了该请求的页面，而不产生任何文档视图上的变化，即使按照规范新的或更新后的元信息应当被应用到用户浏览器活动视图中的文档。</p>\r\n\r\n<p>由于204响应被禁止包含任何消息体，因此它始终以消息头后的第一个空行结尾。</p>\r\n\r\n<p>205 Reset Content</p>\r\n\r\n<p>服务器成功处理了请求，且没有返回任何内容。但是与204响应不同，返回此状态码的响应要求请求者重置文档视图。该响应主要是被用于接受用户输入后，立即重置表单，以便用户能够轻松地开始另一次输入。</p>\r\n\r\n<p>与204响应一样，该响应也被禁止包含任何消息体，且以消息头后的第一个空行结束。</p>\r\n\r\n<p>206 Partial Content</p>\r\n\r\n<p>服务器已经成功处理了部分 GET 请求。类似于 FlashGet 或者迅雷这类的 HTTP下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。</p>\r\n\r\n<p>该请求必须包含 Range 头信息来指示客户端希望得到的内容范围，并且可能包含 If-Range 来作为请求条件。</p>\r\n\r\n<p>响应必须包含如下的头部域：</p>\r\n\r\n<p>Content-Range 用以指示本次响应中返回的内容的范围；如果是 Content-Type 为 multipart/byteranges 的多段下载，则每一 multipart 段中都应包含 Content-Range 域用以指示本段的内容范围。假如响应中包含 Content-Length，那么它的数值必须匹配它返回的内容范围的真实字节数。</p>\r\n\r\n<p>Date</p>\r\n\r\n<p>ETag 和/或 Content-Location，假如同样的请求本应该返回200响应。</p>\r\n\r\n<p>Expires, Cache-Control，和/或 Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。</p>\r\n\r\n<p>假如本响应请求使用了 If-Range 强缓存验证，那么本次响应不应该包含其他实体头；假如本响应的请求使用了 If-Range 弱缓存验证，那么本次响应禁止包含其他实体头；这避免了缓存的实体内容和更新了的实体头信息之间的不一致。否则，本响应就应当包含所有本应该返回200响 应中应当返回的所有实体头部域。</p>\r\n\r\n<p>假如 ETag 或 Last-Modified 头部不能精确匹配的话，则客户端缓存应禁止将206响应返回的内容与之前任何缓存过的内容组合在一起。</p>\r\n\r\n<p>207 Multi-Status</p>\r\n\r\n<p>由WebDAV(RFC 2518)扩展的状态码，代表之后的消息体将是一个XML消息，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码。</p>\r\n', '##这一类型的状态码，代表请求已成功被服务器接收、理解、并接受.\r\n\r\n- 200 OK\r\n- 201 Created\r\n- 202 Accepted\r\n- 203 Non-Authoritative Information\r\n- 204 No Content\r\n- 205 Reset Content\r\n- 206 Partial Content\r\n- 207 Multi-Status\r\n', NULL, 0, 1),
(65, 5, 62, '重定向（3字头）', '<p>300 Multiple Choices</p>\r\n\r\n<p>被请求的资源有一系列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议信息。用户或浏览器能够自行选择一个首选的地址进行重定向。</p>\r\n\r\n<p>除非这是一个 HEAD 请求，否则该响应应当包括一个资源特性及地址的列表的实体，以便用户或浏览器从中选择最合适的重定向地址。这个实体的格式由 Content-Type 定义的格式所决定。浏览器可能根据响应的格式以及浏览器自身能力，自动作出最合适的选择。当然，RFC 2616规范并没有规定这样的自动选择该如何进行。</p>\r\n\r\n<p>如果服务器本身已经有了首选的回馈选择，那么在 Location 中应当指明这个回馈的 URI；浏览器可能会将这个 Location 值作为自动重定向的地址。此外，除非额外指定，否则这个响应也是可缓存的。</p>\r\n\r\n<p>301 Moved Permanently</p>\r\n\r\n<p>被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。</p>\r\n\r\n<p>新的永久性的URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。</p>\r\n\r\n<p>如果这不是一个 GET 或者 HEAD 请求，因此浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。</p>\r\n\r\n<p>注意：对于某些使用 HTTP/1.0 协议的浏览器，当它们发送的 POST 请求得到了一个301响应的话，接下来的重定向请求将会变成 GET 方式。</p>\r\n\r\n<p>302 Move temporarily</p>\r\n\r\n<p>请求的资源临时从不同的 URI响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。</p>\r\n\r\n<p>上文有提及。</p>\r\n\r\n<p>如果这不是一个 GET 或者 HEAD 请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。</p>\r\n\r\n<p>注意：虽然RFC 1945和RFC 2068规范不允许客户端在重定向时改变请求的方法，但是很多现存的浏览器将302响应视作为303响应，并且使用 GET 方式访问在 Location 中规定的 URI，而无视原先请求的方法。状态码303和307被添加了进来，用以明确服务器期待客户端进行何种反应。</p>\r\n\r\n<p>303 See Other</p>\r\n\r\n<p>对应当前请求的响应可以在另一个 URI 上被找到，而且客户端应当采用 GET 的方式访问那个资源。这个方法的存在主要是为了允许由脚本激活的POST请求输出重定向到一个新的资源。这个新的 URI 不是原始资源的替代引用。同时，303响应禁止被缓存。当然，第二个请求（重定向）可能被缓存。</p>\r\n\r\n<p>注意：许多 HTTP/1.1 版以前的浏览器不能正确理解303状态。如果需要考虑与这些浏览器之间的互动，302状态码应该可以胜任，因为大多数的浏览器处理302响应时的方式恰恰就是上述规范要求客户端处理303响应时应当做的。</p>\r\n\r\n<p>304 Not Modified</p>\r\n\r\n<p>如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。304响应禁止包含消息体，因此始终以消息头后的第一个空行结尾。</p>\r\n\r\n<p>该响应必须包含以下的头信息：</p>\r\n\r\n<p>Date，除非这个服务器没有时钟。假如没有时钟的服务器也遵守这些规则，那么代理服务器以及客户端可以自行将 Date 字段添加到接收到的响应头中去（正如RFC 2068中规定的一样），缓存机制将会正常工作。</p>\r\n\r\n<p>ETag 和/或 Content-Location，假如同样的请求本应返回200响应。</p>\r\n\r\n<p>Expires, Cache-Control，和/或Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。</p>\r\n\r\n<p>假如本响应请求使用了强缓存验证，那么本次响应不应该包含其他实体头；否则（例如，某个带条件的 GET 请求使用了弱缓存验证），本次响应禁止包含其他实体头；这避免了缓存了的实体内容和更新了的实体头信息之间的不一致。</p>\r\n\r\n<p>假如某个304响应指明了当前某个实体没有缓存，那么缓存系统必须忽视这个响应，并且重复发送不包含限制条件的请求。</p>\r\n\r\n<p>假如接收到一个要求更新某个缓存条目的304响应，那么缓存系统必须更新整个条目以反映所有在响应中被更新的字段的值。</p>\r\n\r\n<p>305 Use Proxy</p>\r\n\r\n<p>被请求的资源必须通过指定的代理才能被访问。Location 域中将给出指定的代理所在的 URI 信息，接收者需要重复发送一个单独的请求，通过这个代理才能访问相应资源。只有原始服务器才能建立305响应。</p>\r\n\r\n<p>注意：RFC 2068中没有明确305响应是为了重定向一个单独的请求，而且只能被原始服务器建立。忽视这些限制可能导致严重的安全后果。</p>\r\n\r\n<p>306 Switch Proxy</p>\r\n\r\n<p>在最新版的规范中，306状态码已经不再被使用。</p>\r\n\r\n<p>307 Temporary Redirect</p>\r\n\r\n<p>请求的资源临时从不同的URI 响应请求。</p>\r\n\r\n<p>新的临时性的URI 应当在响应的 Location 域中返回。除非这是一个HEAD 请求，否则响应的实体中应当包含指向新的URI 的超链接及简短说明。因为部分浏览器不能识别307响应，因此需要添加上述必要信息以便用户能够理解并向新的 URI 发出访问请求。</p>\r\n\r\n<p>如果这不是一个GET 或者 HEAD 请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。</p>\r\n', '##这类状态码代表需要客户端采取进一步的操作才能完成请求。通常，这些状态码用来重定向，后续的请求地址（重定向目标）在本次响应的 Location 域中指明。\r\n\r\n当且仅当后续的请求所使用的方法是 GET 或者 HEAD 时，用户浏览器才可以在没有用户介入的情况下自动提交所需要的后续请求。客户端应当自动监测无限循环重定向（例如：A->A，或者 A->B->C->A），因为这会导致服务器和客户端大量不必要的资源消耗。按照 HTTP/1.0 版规范的建议，浏览器不应自动访问超过5次的重定向。\r\n\r\n- 300 Multiple Choices\r\n- 301 Moved Permanently\r\n- 302 Move temporarily\r\n- 303 See Other\r\n- 304 Not Modified\r\n- 305 Use Proxy\r\n- 306 Switch Proxy\r\n- 307 Temporary Redirect', NULL, 0, 1);
INSERT INTO `g_booknode` (`nodeid`, `bookid`, `preid`, `title`, `nr`, `nrcode`, `type`, `sort`, `enable`) VALUES
(66, 5, 62, '请求错误（4字头）', '<p>400 Bad Request</p>\r\n\r\n<p>1、语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。</p>\r\n\r\n<p>2、请求参数有误。</p>\r\n\r\n<p>401 Unauthorized</p>\r\n\r\n<p>当前请求需要用户验证。该响应必须包含一个适用于被请求资源的 WWW-Authenticate 信息头用以询问用户信息。客户端可以重复提交一个包含恰当的 Authorization 头信息的请求。如果当前请求已经包含了 Authorization 证书，那么401响应代表着服务器验证已经拒绝了那些证书。如果401响应包含了与前一个响应相同的身份验证询问，且浏览器已经至少尝试了一次验证，那么浏览器应当向用户展示响应中包含的实体信息，因为这个实体信息中可能包含了相关诊断信息。参见RFC 2617。</p>\r\n\r\n<p>402 Payment Required</p>\r\n\r\n<p>该状态码是为了将来可能的需求而预留的。</p>\r\n\r\n<p>403 Forbidden</p>\r\n\r\n<p>服务器已经理解请求，但是拒绝执行它。与401响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。如果这不是一个 HEAD 请求，而且服务器希望能够讲清楚为何请求不能被执行，那么就应该在实体内描述拒绝的原因。当然服务器也可以返回一个404响应，假如它不希望让客户端获得任何信息。</p>\r\n\r\n<p>404 Not Found</p>\r\n\r\n<p>请求失败，请求所希望得到的资源未被在服务器上发现。没有信息能够告诉用户这个状况到底是暂时的还是永久的。假如服 务器知道情况的话，应当使用410状态码来告知旧资源因为某些内部的配置机制问题，已经永久的不可用，而且没有任何可以跳转的地址。404这个状态码被广 泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情况下。出现这个错误的最有可能的原因是服务器端没有这个页面。</p>\r\n\r\n<p>405 Method Not Allowed</p>\r\n\r\n<p>请求行中指定的请求方法不能被用于请求相应的资源。该响应必须返回一个Allow 头信息用以表示出当前资源能够接受的请求方法的列表。</p>\r\n\r\n<p>鉴于 PUT，DELETE 方法会对服务器上的资源进行写操作，因而绝大部分的网页服务器都不支持或者在默认配置下不允许上述请求方法，对于此类请求均会返回405错误。</p>\r\n\r\n<p>406 Not Acceptable</p>\r\n\r\n<p>请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体。</p>\r\n\r\n<p>除非这是一个 HEAD 请求，否则该响应就应当返回一个包含可以让用户或者浏览器从中选择最合适的实体特性以及地址列表的实体。实体的格式由 Content-Type 头中定义的媒体类型决定。浏览器可以根据格式及自身能力自行作出最佳选择。但是，规范中并没有定义任何作出此类自动选择的标准。</p>\r\n\r\n<p>407 Proxy Authentication Required</p>\r\n\r\n<p>与401响应类似，只不过客户端必须在代理服务器上进行身份验证。代理服务器必须返回一个 Proxy-Authenticate 用以进行身份询问。客户端可以返回一个 Proxy-Authorization 信息头用以验证。参见RFC 2617。</p>\r\n\r\n<p>408 Request Timeout</p>\r\n\r\n<p>请求超时。客户端没有在服务器预备等待的时间内完成一个请求的发送。客户端可以随时再次提交这一请求而无需进行任何更改。</p>\r\n\r\n<p>409 Conflict</p>\r\n\r\n<p>由于和被请求的资源的当前状态之间存在冲突，请求无法完成。这个代码只允许用在这样的情况下才能被使用：用户被认为能够解决冲突，并且会重新提交新的请求。该响应应当包含足够的信息以便用户发现冲突的源头。</p>\r\n\r\n<p>冲突通常发生于对 PUT 请求的处理中。例如，在采用版本检查的环境下，某次 PUT 提交的对特定资源的修改请求所附带的版本信息与之前的某个（第三方）请求向冲突，那么此时服务器就应该返回一个409错误，告知用户请求无法完成。此时， 响应实体中很可能会包含两个冲突版本之间的差异比较，以便用户重新提交归并以后的新版本。</p>\r\n\r\n<p>410 Gone</p>\r\n\r\n<p>被请求的资源在服务器上已经不再可用，而且没有任何已知的转发地址。这样的状况应当被认为是永久性的。如果可能，拥 有链接编辑功能的客户端应当在获得用户许可后删除所有指向这个地址的引用。如果服务器不知道或者无法确定这个状况是否是永久的，那么就应该使用404状态 码。除非额外说明，否则这个响应是可缓存的。</p>\r\n\r\n<p>410响应的目的主要是帮助网站管理员维 护网站，通知用户该资源已经不再可用，并且服务器拥有者希望所有指向这个资源的远端连接也被删除。这类事件在限时、增值服务中很普遍。同样，410响应也 被用于通知客户端在当前服务器站点上，原本属于某个个人的资源已经不再可用。当然，是否需要把所有永久不可用的资源标记为&#39;410 Gone&#39;，以及是否需要保持此标记多长时间，完全取决于服务器拥有者。</p>\r\n\r\n<p>411 Length Required</p>\r\n\r\n<p>服务器拒绝在没有定义 Content-Length 头的情况下接受请求。在添加了表明请求消息体长度的有效 Content-Length 头之后，客户端可以再次提交该请求。</p>\r\n\r\n<p>412 Precondition Failed</p>\r\n\r\n<p>服务器在验证在请求的头字段中给出先决条件时，没能满足其中的一个或多个。这个状态码允许客户端在获取资源时在请求的元信息（请求头字段数据）中设置先决条件，以此避免该请求方法被应用到其希望的内容以外的资源上。</p>\r\n\r\n<p>413 Request Entity Too Large</p>\r\n\r\n<p>服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围。此种情况下，服务器可以关闭连接以免客户端继续发送此请求。</p>\r\n\r\n<p>如果这个状况是临时的，服务器应当返回一个 Retry-After 的响应头，以告知客户端可以在多少时间以后重新尝试。</p>\r\n\r\n<p>414 Request-URI Too Long</p>\r\n\r\n<p>请求的URI 长度超过了服务器能够解释的长度，因此服务器拒绝对该请求提供服务。这比较少见，通常的情况包括：</p>\r\n\r\n<p>本应使用POST方法的表单提交变成了GET方法，导致查询字符串（Query String）过长。</p>\r\n\r\n<p>重定向URI &ldquo;黑洞&rdquo;，例如每次重定向把旧的 URI 作为新的 URI 的一部分，导致在若干次重定向后 URI 超长。</p>\r\n\r\n<p>客户端正在尝试利用某些服务器中存在的安全漏洞攻击服务器。这类服务器使用固定长度的缓冲读取或操作请求的 URI，当 GET 后的参数超过某个数值后，可能会产生缓冲区溢出，导致任意代码被执行[1]。没有此类漏洞的服务器，应当返回414状态码。</p>\r\n\r\n<p>415 Unsupported Media Type</p>\r\n\r\n<p>对于当前请求的方法和所请求的资源，请求中提交的实体并不是服务器中所支持的格式，因此请求被拒绝。</p>\r\n\r\n<p>416 Requested Range Not Satisfiable</p>\r\n\r\n<p>如果请求中包含了 Range 请求头，并且 Range 中指定的任何数据范围都与当前资源的可用范围不重合，同时请求中又没有定义 If-Range 请求头，那么服务器就应当返回416状态码。</p>\r\n\r\n<p>假如 Range 使用的是字节范 围，那么这种情况就是指请求指定的所有数据范围的首字节位置都超过了当前资源的长度。服务器也应当在返回416状态码的同时，包含一个 Content-Range 实体头，用以指明当前资源的长度。这个响应也被禁止使用 multipart/byteranges 作为其 Content-Type。</p>\r\n\r\n<p>417 Expectation Failed</p>\r\n\r\n<p>在请求头 Expect 中指定的预期内容无法被服务器满足，或者这个服务器是一个代理服务器，它有明显的证据证明在当前路由的下一个节点上，Expect 的内容无法被满足。</p>\r\n\r\n<p>421There are too many connections from your internet address</p>\r\n\r\n<p>从当前客户端所在的IP地址到服务器的连接数超过了服务器许可的最大范围。通常，这里的IP地址指的是从服务器上看到的客户端地址（比如用户的网关或者代理服务器地址）。在这种情况下，连接数的计算可能涉及到不止一个终端用户。</p>\r\n\r\n<p>422 Unprocessable Entity</p>\r\n\r\n<p>请求格式正确，但是由于含有语义错误，无法响应。（RFC 4918 WebDAV）</p>\r\n\r\n<p>423 Locked</p>\r\n\r\n<p>当前资源被锁定。（RFC 4918 WebDAV）</p>\r\n\r\n<p>424 Failed Dependency</p>\r\n\r\n<p>由于之前的某个请求发生的错误，导致当前请求失败，例如 PROPPATCH。（RFC 4918 WebDAV）</p>\r\n\r\n<p>425 Unordered Collection</p>\r\n\r\n<p>在WebDav Advanced Collections 草案中定义，但是未出现在《WebDAV 顺序集协议》（RFC 3658）中。</p>\r\n\r\n<p>426 Upgrade Required</p>\r\n\r\n<p>客户端应当切换到TLS/1.0。（RFC 2817）</p>\r\n\r\n<p>449 Retry With</p>\r\n\r\n<p>由微软扩展，代表请求应当在执行完适当的操作后进行重试。</p>\r\n', '##这类的状态码代表了客户端看起来可能发生了错误，妨碍了服务器的处理。除非响应的是一个 HEAD 请求，否则服务器就应该返回一个解释当前错误状况的实体，以及这是临时的还是永久性的状况。这些状态码适用于任何请求方法。浏览器应当向用户显示任何包含 在此类错误响应中的实体内容。\r\n\r\n如果错误发生时客户端正在传送数据，那么使用TCP的服务器实现应当仔细确保在关闭客户端与服务器之间的连接之前， 客户端已经收到了包含错误信息的数据包。如果客户端在收到错误信息后继续向服务器发送数据，服务器的TCP栈将向客户端发送一个重置数据包，以清除该客户 端所有还未识别的输入缓冲，以免这些数据被服务器上的应用程序读取并干扰后者。\r\n\r\n- 400 Bad Request\r\n- 401 Unauthorized\r\n- 402 Payment Required\r\n- 403 Forbidden\r\n- 404 Not Found\r\n- 405 Method Not Allowed\r\n- 406 Not Acceptable\r\n- 407 Proxy Authentication Required\r\n- 408 Request Timeout\r\n- 409 Conflict\r\n- 410 Gone\r\n- 411 Length Required\r\n- 412 Precondition Failed\r\n- 413 Request Entity Too Large\r\n- 414 Request-URI Too Long\r\n- 415 Unsupported Media Type\r\n- 416 Requested Range Not Satisfiable\r\n- 417 Expectation Failed\r\n- 421There are too many connections from your internet address\r\n- 422 Unprocessable Entity\r\n- 423 Locked\r\n- 424 Failed Dependency\r\n- 425 Unordered Collection\r\n- 426 Upgrade Required\r\n- 449 Retry With', NULL, 0, 1),
(67, 5, 62, '服务器错误（5字头）', '<p>500 Internal Server Error</p>\r\n\r\n<p>服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在服务器端的源代码出现错误时出现。</p>\r\n\r\n<p>501 Not Implemented</p>\r\n\r\n<p>服务器不支持当前请求所需要的某个功能。当服务器无法识别请求的方法，并且无法支持其对任何资源的请求。</p>\r\n\r\n<p>502 Bad Gateway</p>\r\n\r\n<p>作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。</p>\r\n\r\n<p>503 Service Unavailable</p>\r\n\r\n<p>由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状况是临时的，并且将在一段时间以后恢复。如果能够预 计延迟时间，那么响应中可以包含一个 Retry-After 头用以标明这个延迟时间。如果没有给出这个 Retry-After 信息，那么客户端应当以处理500响应的方式处理它。</p>\r\n\r\n<p>注意：503状态码的存在并不意味着服务器在过载的时候必须使用它。某些服务器只不过是希望拒绝客户端的连接。</p>\r\n\r\n<p>504 Gateway Timeout</p>\r\n\r\n<p>作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI标识出的服务器，例如HTTP、FTP、LDAP）或者辅助服务器（例如DNS）收到响应。</p>\r\n\r\n<p>注意：某些代理服务器在DNS查询超时时会返回400或者500错误</p>\r\n\r\n<p>505 HTTP Version Not Supported</p>\r\n\r\n<p>服务器不支持，或者拒绝支持在请求中使用的 HTTP 版本。这暗示着服务器不能或不愿使用与客户端相同的版本。响应中应当包含一个描述了为何版本不被支持以及服务器支持哪些协议的实体。</p>\r\n\r\n<p>506 Variant Also Negotiates</p>\r\n\r\n<p>由《透明内容协商协议》（RFC 2295）扩展，代表服务器存在内部配置错误：被请求的协商变元资源被配置为在透明内容协商中使用自己，因此在一个协商处理中不是一个合适的重点。</p>\r\n\r\n<p>507 Insufficient Storage</p>\r\n\r\n<p>服务器无法存储完成请求所必须的内容。这个状况被认为是临时的。WebDAV (RFC 4918)</p>\r\n\r\n<p>509 Bandwidth Limit Exceeded</p>\r\n\r\n<p>服务器达到带宽限制。这不是一个官方的状态码，但是仍被广泛使用。</p>\r\n\r\n<p>510 Not Extended</p>\r\n\r\n<p>获取资源所需要的策略并没有没满足。（RFC 2774）</p>\r\n\r\n<p>600 Unparseable Response Headers</p>\r\n\r\n<p>源站没有返回响应头部，只返回实体内容</p>\r\n', '##这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器意识到以当前的软硬件资源无法 完成对请求的处理。除非这是一个HEAD 请求，否则服务器应当包含一个解释当前错误状态以及这个状况是临时的还是永久的解释信息实体。浏览器应当向用户展示任何在当前响应中被包含的实体。\r\n\r\n这些状态码适用于任何响应方法。\r\n\r\n\r\n- 500 Internal Server Error\r\n- 501 Not Implemented\r\n- 502 Bad Gateway\r\n- 503 Service Unavailable\r\n- 504 Gateway Timeout\r\n- 505 HTTP Version Not Supported\r\n- 506 Variant Also Negotiates\r\n- 507 Insufficient Storage\r\n- 509 Bandwidth Limit Exceeded\r\n- 510 Not Extended\r\n- 600 Unparseable Response Headers\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n', NULL, 0, 1),
(68, 5, 0, 'XCache', '<p>XCache是一款快速、稳定的php代码级缓存器，可以为高负载环境下的服务器提供一个有效的缓冲层。与它类似的缓冲器有eAccelerator、APC。</p>\r\n\r\n<p>详细 : http://xcache.lighttpd.net/</p>\r\n\r\n<p>配置</p>\r\n\r\n<p>http://xcache.lighttpd.net/wiki/XcacheIni</p>\r\n', '##修改php.ini \r\n\r\n    [xcache.admin]\r\n    xcache.admin.enable_auth = On\r\n    xcache.admin.user = "super"\r\n    ; xcache.admin.pass = md5($您的密码)\r\n    ; 登录使用 $your_password\r\n    xcache.admin.pass = "1b3231655cebb7a1f783eddf27d254ca"', NULL, 0, 1),
(69, 5, 0, 'Apache Benchmark', '<p>安装</p>\r\n\r\n<p>参考 : http://book.51cto.com/art/201110/299799.htm</p>\r\n', '', NULL, 0, 1),
(70, 5, 0, 'Pear', '<p>PEAR是PHP扩展与应用库(the PHP Extension and Application Repository)的缩写。它是一个PHP扩展及应用的一个代码仓库，简单地说，PEAR之于PHP就像是CPAN(Comprehensive Perl Archive Network)之于Perl。</p>\r\n\r\n<p>PEAR的基本目标是发展成为PHP扩展和库代码的知识库，而这个项目最有雄心的目标则是试图定义一种标准，这种标准将帮助开发者编写可移植、可重用的代码。</p>\r\n', '    D:\\phpStudy\\php54n>pear list\r\n    INSTALLED PACKAGES, CHANNEL PEAR.PHP.NET:\r\n    =========================================\r\n    PACKAGE          VERSION STATE\r\n    Archive_Tar      1.3.12  stable\r\n    Benchmark        1.2.9   stable\r\n    Console_Getopt   1.3.1   stable\r\n    MDB2             2.4.1   stable\r\n    PEAR             1.9.5   stable\r\n    Structures_Graph 1.0.4   stable\r\n    XML_Util         1.2.3   stable', NULL, 0, 1),
(71, 5, 70, 'PEAR Benchmark', '<p>参考</p>\r\n\r\n<p>http://oss.org.cn/html/83/n-63283.html</p>\r\n\r\n<p>http://www.ithao123.cn/content-7852457.html</p>\r\n\r\n<p>http://www.51edu.com/it/chengxu/php/phpshili/2773547.html</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>Benchmark工具类包共有三个文件，分别是Timer.php、Iterate.php和Profiler.php，三个工具类功能相同，只是侧重点不同，都是用于调试代码获取程序的执行时间。</p>\r\n\r\n<ol>\r\n	<li>Benchmark_Timer类原理与通过microtime函数获取微秒时间再比较前后两个时间值的差相同。</li>\r\n	<li>Benchmark_Iterate类用于调试函数的平均执行时间。</li>\r\n	<li>Benchmark_Profiler类用于统计代码和函数的执行时间以及函数的调用次数。</li>\r\n</ol>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;</p>\r\n', '	<?\r\n	require_once "Benchmark/Iterate.php";\r\n	$bench = new Benchmark_Iterate;\r\n	$charset = $GLOBALS[''db_charset''] = ''gbk'';//utf-8\r\n	$content = "今年春晚，我特地关注了赵本山的新小品《捐助》，这篇小品对弱势...";\r\n\r\n	/*phpwind*/\r\n	//$bench->run(50,"substrs",$content,30);\r\n	/*discuz*/\r\n	function cutstr(){\r\n\r\n	}\r\n\r\n	$bench->run(50,"cutstr",$content,30);\r\n\r\n	$result = $bench->get();\r\n	print_r($result);\r\n\r\n参考\r\nhttp://m.so/test.php', NULL, 0, 1),
(72, 5, 0, 'Xdebug', '<p>Xdebug是一个<strong>开放源代码</strong>的PHP程序调试器(即一个Debug工具)，可以用来跟踪，调试和分析PHP程序的运行状况。Xdebug现在的最新版本是<strong>Xdebug 2.2.6,</strong>release日期 2014-11-04，支持PHP4/PHP5。</p>\r\n\r\n<p>&nbsp;</p>\r\n', '', NULL, 0, 1),
(73, 5, 70, 'PEAR PHPUnit', '<p>安装 : https://phpunit.de/manual/current/zh_cn/installation.html</p>\r\n\r\n<p>http://www.phpunit.cn/</p>\r\n', '', NULL, 0, 1),
(74, 5, 0, 'Composer', '<p>Composer 是由 Jordi Boggiano 和 Nils Aderman 创造的一个命令行工具，它的使命就是帮你为项目自动安装所依赖的开发包。Composer 中的很多理念都借鉴了 npm 和 Bundler，如果你对这两个工具有所了解的话，就会在 composer 中发现他们的身影。Composer 包含了一个依赖解析器，用来处理开发包之间复杂的依赖关系；另外，它还包含了下载器、安装器等有趣的东西。</p>\r\n\r\n<p>作为一个用户，你所要做的就是在 <code>composer.json</code> 文件中声明当前项目所依赖的开发包，然后运行 <code>composer.phar install</code> 就行了。<code>composer.json</code> 文件定义了当前项目所依赖的开发包和 composer 的配置信息。</p>\r\n', '参考\r\n\r\nhttp://www.phpcomposer.com/\r\n\r\n', NULL, 99, 1),
(75, 5, 74, 'Packagist', '<p>Packagist 是 Composer 的默认的开发包仓库。你可以将自己的安装包提交到 packagist，将来你在自己的 VCS （源码管理软件，比如 Github） 仓库中新建了 tag 或更新了代码，packagist 都会自动构建一个新的开发包。这就是 packagist 目前的运作方式，将来 packagist 将允许直接上传开发包。</p>\r\n', 'https://packagist.org/', NULL, 0, 1),
(76, 2, 0, 'Geter容器', '<p>主要被设计用来返回相对稳定和重用的环境数据和数据库数据</p>\r\n\r\n<p>降低跟主系统的耦合程度!</p>\r\n\r\n<div style="background:#eee; border:1px solid #ccc; padding:5px 10px">=&gt; sys/geter/index&nbsp;&nbsp; =&gt;<strong> <span class="marker">制作当中</span></strong></div>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>可以看做系统内部的持久化存储数据</p>\r\n\r\n<p>调用方法是在控制器中 用G方法调用</p>\r\n\r\n<p>对应的处理代码放在\\App\\G\\Lib 中</p>\r\n', '调用示例\r\n\r\n参数格式分别对应于库文件中的\r\n\r\n类.方法.参数 [参数暂时只被限制为一个字符]\r\n\r\n     D($this->G(''user.md''));', NULL, 66, 1),
(77, 2, 76, '配置', '<p>配置文件路径为</p>\r\n\r\n<p>\\App\\Seter\\Config\\Default.php</p>\r\n', 'FW字段解释为Geter可以接受的对象范围\r\n\r\n    ...\r\n    ''Geter''=>[\r\n        ''Base''=> ''../G/'',\r\n        ''FW'' => [\r\n            ''user'',\r\n            ''sys'',\r\n        ],\r\n    ],\r\n    ...\r\n', NULL, 99, 1),
(78, 2, 76, '提示信息', '<pre>\r\n对Geter的使用错误,会有想管的提示信息给出;\r\n</pre>\r\n', '##解析出来的类名为空\r\nError::Geter is not permit empty!!\r\n##解析出来的类名超出配置的限制\r\nError::out of Geter limit!\r\n##解析出来的类方法超出限制\r\nError::out of Geter Method limit!', NULL, 8, 1),
(79, 2, 76, 'Debug', '<p>有两个调用参数可以用来进行调试</p>\r\n', '##返回所有的类信息\r\n    $this->G(''debug.show'')\r\n##显示所有的类信息\r\n    $this->G(''debug.display'')\r\n    \r\n\r\n\r\n或者直接调用Geter对象的方法来进行调试\r\n\r\n	\\G\\Geter::getInstance()->show();                //调试\r\n	\\G\\Geter::getInstance()->display();                //调试', NULL, 7, 1),
(81, 2, 76, '使用', '<p>所有的Geter内对象都继承自Mg对象</p>\r\n\r\n<p>Mg对象中的方法可以直接进行调用</p>\r\n\r\n<p>包括</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;</p>\r\n', '方法\r\n\r\n__construct\r\n    \r\n    //可以在子类中被\r\n    public  function __construct()\r\n    {\r\n        $this->db= \\Seter\\Seter::getInstance()->db;\r\n    }    \r\n    \r\n方法show 返回该对象所有的方法    \r\n    \r\n    public function show()\r\n    {\r\n        $lib =  get_class_methods($this);            //所有的方法\r\n        $lib = array_diff($lib,[''show'',''ds'']);           //去掉show方法\r\n        return $lib;\r\n    }    \r\n    \r\n    \r\n对象\r\n\r\n数据库对象db\r\n\r\n调用\r\n    \r\n    $this->db->getall();\r\n    \r\n示例要获取某个内方法的数据控制器中如下获取\r\n\r\n    $user = $this->G(''user.info.3'');		=> user->info(3);\r\n    $user = $this->G(''userlist'');			=> userlist->index()\r\n    $user = $this->G(''group.list'');			=> group->list()\r\n\r\n\r\n    \r\n    ', NULL, 0, 1),
(80, 2, 76, 'Debug返回的数据格式', '<p>这里返回的数据是在处理类中DS方法定义的数据</p>\r\n', '	Array\r\n	(\r\n	    [user] => Array\r\n		(\r\n		    [index] => \r\n		    [info] => $parm = ""\r\n		    [getlist] => $parm = ""\r\n		)\r\n\r\n	    [sys] => Array\r\n		(\r\n		    [index] => \r\n		    [info] => $parm = ""\r\n		    [getlist] => $parm = ""\r\n		)\r\n\r\n	)', NULL, 6, 1),
(82, 2, 76, '对象', '<p>有内置对象db / table</p>\r\n', '示例\r\n\r\n        $rc =         $this->db->getall(''select * from dy_user'');\r\n        $rc =         $this->table->dy_user->getall();', NULL, 0, 1),
(83, 5, 0, 'Markdown', '<p>Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。</p>\r\n\r\n<p>Markdown具有一系列衍生版本，用于扩展Markdown的功能（如表格、脚注、内嵌HTML等等），这些功能原初的Markdown尚不具备，它们能让Markdown转换成更多的格式，例如LaTeX，Docbook。Markdown增强版中比较有名的有Markdown Extra、MultiMarkdown、 Maruku等。这些衍生版本要么基于工具，如Pandoc；要么基于网站，如GitHub和Wikipedia，在语法上基本兼容，但在一些语法和渲染效果上有改动.</p>\r\n', '', NULL, -90, 1),
(84, 5, 83, '用途', '<p>Markdown的语法简洁明了、学习容易，而且功能比纯文本更强，因此有很多人用它写博客。世界上最流行的博客平台WordPress和大型CMS如Joomla、Drupal都能很好的支持Markdown。完全采用Markdown编辑器的博客平台有Ghost和Typecho。</p>\r\n\r\n<p>用于编写说明文档，并且以&ldquo;README.MD&rdquo;的文件名保存在软件的目录下面。</p>\r\n', '', NULL, 99, 1),
(85, 5, 83, '常用语法', '<p>最常见的Markdown格式选项和键盘快捷键[2]<a name="ref_[2]_2311114">&nbsp;</a> :</p>\r\n\r\n<table>\r\n	<tbody>\r\n		<tr>\r\n			<th>输出后的效果</th>\r\n			<th>Markdown</th>\r\n			<th>快捷键</th>\r\n		</tr>\r\n		<tr>\r\n			<td>Bold</td>\r\n			<td>**text**</td>\r\n			<td>Ctrl/⌘ + B</td>\r\n		</tr>\r\n		<tr>\r\n			<td><em>Emphasize</em></td>\r\n			<td>*text*</td>\r\n			<td>Ctrl/⌘ + I</td>\r\n		</tr>\r\n		<tr>\r\n			<td>Strike-through</td>\r\n			<td>~~text~~</td>\r\n			<td>Ctrl + Alt + U</td>\r\n		</tr>\r\n		<tr>\r\n			<td>Link</td>\r\n			<td>[title](http://)</td>\r\n			<td>Ctrl/⌘ + K</td>\r\n		</tr>\r\n		<tr>\r\n			<td>Inline Code</td>\r\n			<td>`code`</td>\r\n			<td>Ctrl/⌘ + Shift + K</td>\r\n		</tr>\r\n		<tr>\r\n			<td>Image</td>\r\n			<td>![alt](http://)</td>\r\n			<td>Ctrl/⌘ + Shift + I</td>\r\n		</tr>\r\n		<tr>\r\n			<td>List</td>\r\n			<td>* item</td>\r\n			<td>Ctrl + L</td>\r\n		</tr>\r\n		<tr>\r\n			<td>Blockquote</td>\r\n			<td>&gt; quote</td>\r\n			<td>Ctrl + Q</td>\r\n		</tr>\r\n		<tr>\r\n			<td>H1</td>\r\n			<td># Heading</td>\r\n			<td><br />\r\n			　　</td>\r\n		</tr>\r\n		<tr>\r\n			<td>H2</td>\r\n			<td>## Heading</td>\r\n			<td>Ctrl/⌘ + H</td>\r\n		</tr>\r\n		<tr>\r\n			<td>H3</td>\r\n			<td>### Heading</td>\r\n			<td>Ctrl/⌘ + H (x2)</td>\r\n		</tr>\r\n	</tbody>\r\n</table>\r\n', '', NULL, 8, 1),
(86, 5, 83, '标题', '<p>标题能显示出文章的结构。行首插入1-6个 # ，每增加一个 # 表示更深入层次的内容，对应到标题的深度由 1-6 阶。</p>\r\n\r\n<ul>\r\n	<li>&nbsp;&nbsp;&nbsp; H1 :# Header 1</li>\r\n	<li>&nbsp;&nbsp;&nbsp; H2 :## Header 2</li>\r\n	<li>&nbsp;&nbsp;&nbsp; H3 :### Header 3</li>\r\n	<li>&nbsp;&nbsp;&nbsp; H4 :#### Header 4</li>\r\n	<li>&nbsp;&nbsp;&nbsp; H5 :##### Header 5</li>\r\n	<li>&nbsp;&nbsp;&nbsp; H6 :###### Header 6</li>\r\n</ul>\r\n', '# Header 1\r\n## Header 2\r\n### Header 3\r\n#### Header 4\r\n##### Header 5\r\n###### Header 6', NULL, 9, 1),
(87, 5, 83, '文本样式', '<ul>\r\n	<li>&nbsp;&nbsp;&nbsp; 链接 :[Title](URL)</li>\r\n	<li>&nbsp;&nbsp;&nbsp; 加粗 :**Bold**</li>\r\n	<li>&nbsp;&nbsp;&nbsp; 斜体字 :*Italics*</li>\r\n	<li>&nbsp;&nbsp;&nbsp; 删除线 :~~text~~</li>\r\n	<li>&nbsp;&nbsp;&nbsp; 高亮 :==text==</li>\r\n	<li>&nbsp;&nbsp;&nbsp; 段落 : 段落之间空一行</li>\r\n	<li>&nbsp;&nbsp;&nbsp; 换行符 : 一行结束时输入两个空格</li>\r\n	<li>&nbsp;&nbsp;&nbsp; 列表 :* 添加星号成为一个新的列表项。</li>\r\n	<li>&nbsp;&nbsp;&nbsp; 引用 :&gt; 引用内容</li>\r\n	<li>&nbsp;&nbsp;&nbsp; 内嵌代码 : `alert(&#39;Hello World&#39;);`</li>\r\n	<li>&nbsp;&nbsp;&nbsp; 画水平线 (HR) :--------</li>\r\n</ul>\r\n', '', NULL, 7, 1),
(88, 5, 83, '图片', '<p>使用Markdown将图像插入文章，你需要在Markdown编辑器输入 ![]() 。 这时在预览面板中会自动创建一个图像上传框。你可以从电脑桌面拖放图片(.png, .gif, .jpg)到上传框, 或者点击图片上传框使用标准的图像上传方式。 如果你想通过链接插入网络上已经存在的图片，只要单击图片上传框的左下角的&ldquo;链接&rdquo;图标，这时就会呈现图像URL的输入框。想给图片添加一个标题, 你需要做的是将标题文本插图中的方括号，e.g;![This is a title]().</p>\r\n', '', NULL, 6, 1),
(89, 5, 83, '脚注', '<p>使用这样的占位符号可以将脚注添加到文本中:[^1]. 另外，你可以使用&ldquo;n&rdquo;而不是数字的[^n]所以你可以不必担心使用哪个号码。在您的文章的结尾，你可以如下图所示定义匹配的注脚，URL将变成链接:</p>\r\n', '[^1]: This is my first footnote\r\n \r\n[^n]: Visit http://example.com\r\n \r\n[^n]: A final footnote\r\n\r\n源码\r\n\r\n    [^1]: This is my first footnote\r\n \r\n    [^n]: Visit http://example.com\r\n \r\n    [^n]: A final footnote\r\n', NULL, 5, 1),
(90, 5, 83, '写代码', '<p>添加内嵌代码可以使用一对回勾号 `alert(&#39;Hello World&#39;)`.对于插入代码, Ghost支持标准的Markdown代码和GitHub Flavored Markdown (GFM)。标准Markdown基于缩进代码行或者4个空格位:</p>\r\n\r\n<p>&nbsp;&nbsp; public function info($parm = &#39;&#39;)<br />\r\n&nbsp;&nbsp;&nbsp; {<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return&nbsp; &#39;user.info&#39;.$parm;<br />\r\n&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp;</p>\r\n\r\n<p>GFM 使用三个回勾号```</p>\r\n\r\n<p>&acute;&acute;&acute;</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp; public function info($parm = &#39;&#39;)<br />\r\n&nbsp;&nbsp;&nbsp; {<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return&nbsp; &#39;user.info&#39;.$parm;<br />\r\n&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp;</p>\r\n\r\n<p>&acute;&acute;&acute;</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;</p>\r\n', '示例\r\n    \r\n    public function info($parm = '''')\r\n    {\r\n        return  ''user.info''.$parm;\r\n    }    ', NULL, 4, 1),
(91, 5, 83, '例子', '<p>嵌入链接</p>\r\n\r\n<p><code>This&nbsp;is&nbsp;a&nbsp;paragraph&nbsp;that&nbsp;contains&nbsp;a&nbsp;[link&nbsp;to&nbsp;example]()</code></p>\r\n\r\n<p>列表格式</p>\r\n\r\n<p><code>This&nbsp;paragraph&nbsp;contains&nbsp;a&nbsp;list&nbsp;of&nbsp;items.</code></p>\r\n\r\n<p>This paragraph contains a list of items.<br />\r\n&nbsp;* Item 1<br />\r\n&nbsp;* Item 2<br />\r\n&nbsp;* Item three</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>使用Markdown 引用文本：</p>\r\n\r\n<p><code>This&nbsp;paragraph&nbsp;has&nbsp;a&nbsp;quote</code></p>\r\n\r\n<p><code>&gt;&nbsp;That&nbsp;is&nbsp;pulled&nbsp;out&nbsp;like&nbsp;this</code></p>\r\n\r\n<p><code>from&nbsp;the&nbsp;text&nbsp;my&nbsp;post.</code></p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;</p>\r\n', '嵌入链接\r\n\r\nThis is a paragraph that contains a [link to example]()\r\n\r\n\r\n列表格式\r\n\r\nThis paragraph contains a list of items.\r\n\r\nThis paragraph contains a list of items.\r\n * Item 1\r\n * Item 2\r\n * Item three\r\n\r\n使用Markdown 引用文本：\r\n\r\nThis paragraph has a quote\r\n\r\n> That is pulled out like this\r\n\r\nfrom the text my post.\r\n\r\n\r\n', NULL, 3, 1);
INSERT INTO `g_booknode` (`nodeid`, `bookid`, `preid`, `title`, `nr`, `nrcode`, `type`, `sort`, `enable`) VALUES
(92, 4, 0, 'PHP数组函数', '<p>PHP Array 函数允许您访问并操作数组。</p>\r\n\r\n<table>\r\n	<tbody>\r\n		<tr>\r\n			<th>\r\n			<p>函数</p>\r\n			</th>\r\n			<th>\r\n			<p>描述</p>\r\n			</th>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p>array()</p>\r\n			</td>\r\n			<td>\r\n			<p>创建数组。</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p>array_change_key_case()</p>\r\n			</td>\r\n			<td>\r\n			<p>返回其键均为大写或小写的数组。</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p>array_chunk()</p>\r\n			</td>\r\n			<td>\r\n			<p>把一个数组分割为新的数组块。</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p>array_column()</p>\r\n			</td>\r\n			<td>\r\n			<p>返回输入数组中某个单一列的值。</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p>array_combine()</p>\r\n			</td>\r\n			<td>\r\n			<p>通过合并两个数组（一个为键名数组，一个为键值数组）来创建一个新数组。</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p>array_count_values()</p>\r\n			</td>\r\n			<td>\r\n			<p>用于统计数组中所有值出现的次数。</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p>array_diff()</p>\r\n			</td>\r\n			<td>\r\n			<p>比较数组，返回两个数组的差集（只比较键值）。</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p>array_diff_assoc()</p>\r\n			</td>\r\n			<td>\r\n			<p>比较数组，返回两个数组的差集（比较键名和键值）。</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p>array_diff_key()</p>\r\n			</td>\r\n			<td>\r\n			<p>比较数组，返回两个数组的差集（只比较键名）。</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p>array_diff_uassoc()</p>\r\n			</td>\r\n			<td>\r\n			<p>比较数组，返回两个数组的差集（比较键名和键值，使用用户自定义的键名比较函数）。</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p>array_diff_ukey()</p>\r\n			</td>\r\n			<td>\r\n			<p>比较数组，返回两个数组的差集（只比较键名，使用用户自定义的键名比较函数）。</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p>array_fill()</p>\r\n			</td>\r\n			<td>\r\n			<p>用给定的键值填充数组。</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p>array_fill_keys()</p>\r\n			</td>\r\n			<td>\r\n			<p>用给定的指定键名的键值填充数组。</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p>array_filter()</p>\r\n			</td>\r\n			<td>\r\n			<p>用回调函数过滤数组中的元素。</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p>array_flip()</p>\r\n			</td>\r\n			<td>\r\n			<p>反转/交换数组中的键名和对应关联的键值。</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p>array_intersect()</p>\r\n			</td>\r\n			<td>\r\n			<p>比较数组，返回两个数组的交集（只比较键值）。</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p>array_intersect_assoc()</p>\r\n			</td>\r\n			<td>\r\n			<p>比较数组，返回两个数组的交集（比较键名和键值）。</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p>array_intersect_key()</p>\r\n			</td>\r\n			<td>\r\n			<p>比较数组，返回两个数组的交集（只比较键名）。</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p>array_intersect_uassoc()</p>\r\n			</td>\r\n			<td>\r\n			<p>比较数组，返回两个数组的交集（比较键名和键值，使用用户自定义的键名比较函数）。</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p>array_intersect_ukey()</p>\r\n			</td>\r\n			<td>\r\n			<p>比较数组，返回两个数组的交集（只比较键名，使用用户自定义的键名比较函数）。</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p>array_key_exists()</p>\r\n			</td>\r\n			<td>\r\n			<p>检查指定的键名是否存在于数组中。</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p>array_keys()</p>\r\n			</td>\r\n			<td>\r\n			<p>返回数组中所有的键名。</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p>array_map()</p>\r\n			</td>\r\n			<td>\r\n			<p>将用户自定义函数作用到给定数组的每个值上，返回新的值。</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p>array_merge()</p>\r\n			</td>\r\n			<td>\r\n			<p>把一个或多个数组合并为一个数组。</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p>array_merge_recursive()</p>\r\n			</td>\r\n			<td>\r\n			<p>递归地把一个或多个数组合并为一个数组。</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p>array_multisort()</p>\r\n			</td>\r\n			<td>\r\n			<p>对多个数组或多维数组进行排序。</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p>array_pad()</p>\r\n			</td>\r\n			<td>\r\n			<p>将指定数量的带有指定值的元素插入到数组中。</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p>array_pop()</p>\r\n			</td>\r\n			<td>\r\n			<p>删除数组中的最后一个元素（出栈）。</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p>array_product()</p>\r\n			</td>\r\n			<td>\r\n			<p>计算数组中所有值的乘积。</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p>array_push()</p>\r\n			</td>\r\n			<td>\r\n			<p>将一个或多个元素插入数组的末尾（入栈）。</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p>array_rand()</p>\r\n			</td>\r\n			<td>\r\n			<p>从数组中随机选出一个或多个元素，返回键名。</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p>array_reduce()</p>\r\n			</td>\r\n			<td>\r\n			<p>通过使用用户自定义函数，迭代地将数组简化为一个字符串，并返回。</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p>array_replace()</p>\r\n			</td>\r\n			<td>\r\n			<p>将所有被替换数组中的元素替换成第一个数组。</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p>array_replace_recursive()</p>\r\n			</td>\r\n			<td>\r\n			<p>将所有被替换数组中的元素递归地替换成第一个数组。</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p>array_reverse()</p>\r\n			</td>\r\n			<td>\r\n			<p>将原数组中的元素顺序翻转，创建新的数组并返回。</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p>array_search()</p>\r\n			</td>\r\n			<td>\r\n			<p>在数组中搜索给定的值，如果成功则返回相应的键名。</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p>array_shift()</p>\r\n			</td>\r\n			<td>\r\n			<p>删除数组中的第一个元素，并返回被删除元素的值。</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p>array_slice()</p>\r\n			</td>\r\n			<td>\r\n			<p>返回数组中的选定部分。</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p>array_splice()</p>\r\n			</td>\r\n			<td>\r\n			<p>把数组中的指定元素去掉并用其它值取代。</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p>array_sum()</p>\r\n			</td>\r\n			<td>\r\n			<p>返回数组中所有值的和。</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p>array_udiff()</p>\r\n			</td>\r\n			<td>\r\n			<p>比较数组，返回两个数组的差集（只比较键值，使用一个用户自定义的键名比较函数）。</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p>array_udiff_assoc()</p>\r\n			</td>\r\n			<td>\r\n			<p>比较数组，返回两个数组的差集（比较键名和键值，使用内建函数比较键名，使用用户自定义函数比较键值）。</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p>array_udiff_uassoc()</p>\r\n			</td>\r\n			<td>\r\n			<p>比较数组，返回两个数组的差集（比较键名和键值，使用两个用户自定义的键名比较函数）。</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p>array_uintersect()</p>\r\n			</td>\r\n			<td>\r\n			<p>比较数组，返回两个数组的交集（只比较键值，使用一个用户自定义的键名比较函数）。</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p>array_uintersect_assoc()</p>\r\n			</td>\r\n			<td>\r\n			<p>比较数组，返回两个数组的交集（比较键名和键值，使用内建函数比较键名，使用用户自定义函数比较键值）。</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p>array_uintersect_uassoc()</p>\r\n			</td>\r\n			<td>\r\n			<p>比较数组，返回两个数组的交集（比较键名和键值，使用两个用户自定义的键名比较函数）。</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p>array_unique()</p>\r\n			</td>\r\n			<td>\r\n			<p>删除数组中重复的值。</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p>array_unshift()</p>\r\n			</td>\r\n			<td>\r\n			<p>在数组开头插入一个或多个元素。</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p>array_values()</p>\r\n			</td>\r\n			<td>\r\n			<p>返回数组中所有的值。</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p>array_walk()</p>\r\n			</td>\r\n			<td>\r\n			<p>对数组中的每个成员应用用户函数。</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p>array_walk_recursive()</p>\r\n			</td>\r\n			<td>\r\n			<p>对数组中的每个成员递归地应用用户函数。</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p>arsort()</p>\r\n			</td>\r\n			<td>\r\n			<p>对关联数组按照键值进行降序排序。</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p>asort()</p>\r\n			</td>\r\n			<td>\r\n			<p>对关联数组按照键值进行升序排序。</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p>compact()</p>\r\n			</td>\r\n			<td>\r\n			<p>创建一个包含变量名和它们的值的数组。</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p>count()</p>\r\n			</td>\r\n			<td>\r\n			<p>返回数组中元素的数目。</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p>current()</p>\r\n			</td>\r\n			<td>\r\n			<p>返回数组中的当前元素。</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p>each()</p>\r\n			</td>\r\n			<td>\r\n			<p>返回数组中当前的键/值对。</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p>end()</p>\r\n			</td>\r\n			<td>\r\n			<p>将数组的内部指针指向最后一个元素。</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p>extract()</p>\r\n			</td>\r\n			<td>\r\n			<p>从数组中将变量导入到当前的符号表。</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p>in_array()</p>\r\n			</td>\r\n			<td>\r\n			<p>检查数组中是否存在指定的值。</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p>key()</p>\r\n			</td>\r\n			<td>\r\n			<p>从关联数组中取得键名。</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p>krsort()</p>\r\n			</td>\r\n			<td>\r\n			<p>对关联数组按照键名降序排序。</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p>ksort()</p>\r\n			</td>\r\n			<td>\r\n			<p>对关联数组按照键名升序排序。</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p>list()</p>\r\n			</td>\r\n			<td>\r\n			<p>把数组中的值赋给一些数组变量。</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p>natcasesort()</p>\r\n			</td>\r\n			<td>\r\n			<p>用&quot;自然排序&quot;算法对数组进行不区分大小写字母的排序。</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p>natsort()</p>\r\n			</td>\r\n			<td>\r\n			<p>用&quot;自然排序&quot;算法对数组排序。</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p>next()</p>\r\n			</td>\r\n			<td>\r\n			<p>将数组中的内部指针向前移动一位。</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p>pos()</p>\r\n			</td>\r\n			<td>\r\n			<p>current() 的别名。</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p>prev()</p>\r\n			</td>\r\n			<td>\r\n			<p>将数组的内部指针倒回一位。</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p>range()</p>\r\n			</td>\r\n			<td>\r\n			<p>创建一个包含指定范围的元素的数组。</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p>reset()</p>\r\n			</td>\r\n			<td>\r\n			<p>将数组的内部指针指向第一个元素。</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p>rsort()</p>\r\n			</td>\r\n			<td>\r\n			<p>对数值数组进行降序排序。</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p>shuffle()</p>\r\n			</td>\r\n			<td>\r\n			<p>把数组中的元素按随机顺序重新排列。</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p>sizeof()</p>\r\n			</td>\r\n			<td>\r\n			<p>count() 的别名。</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p>sort()</p>\r\n			</td>\r\n			<td>\r\n			<p>对数值数组进行升序排序。</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p>uasort()</p>\r\n			</td>\r\n			<td>\r\n			<p>使用用户自定义的比较函数对数组中的键值进行排序。</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p>uksort()</p>\r\n			</td>\r\n			<td>\r\n			<p>使用用户自定义的比较函数对数组中的键名进行排序。</p>\r\n			</td>\r\n		</tr>\r\n		<tr>\r\n			<td>\r\n			<p>usort()</p>\r\n			</td>\r\n			<td>\r\n			<p>使用用户自定义的比较函数对数组进行排序。</p>\r\n			</td>\r\n		</tr>\r\n	</tbody>\r\n</table>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><strong>目录</strong></p>\r\n\r\n<p><a href="http://www.kuqin.com/php5_doc/function.array-change-key-case.html">array_change_key_case</a>&nbsp;--&nbsp;返回字符串键名全为小写或大写的数组</p>\r\n\r\n<p><a href="http://www.kuqin.com/php5_doc/function.array-chunk.html">array_chunk</a>&nbsp;--&nbsp;将一个数组分割成多个</p>\r\n\r\n<p><a href="http://www.kuqin.com/php5_doc/function.array-combine.html">array_combine</a>&nbsp;--&nbsp; 创建一个数组，用一个数组的值作为其键名，另一个数组的值作为其值</p>\r\n\r\n<p><a href="http://www.kuqin.com/php5_doc/function.array-count-values.html">array_count_values</a>&nbsp;--&nbsp;统计数组中所有的值出现的次数</p>\r\n\r\n<p><a href="http://www.kuqin.com/php5_doc/function.array-diff-assoc.html">array_diff_assoc</a>&nbsp;--&nbsp;带索引检查计算数组的差集</p>\r\n\r\n<p><a href="http://www.kuqin.com/php5_doc/function.array-diff-key.html">array_diff_key</a>&nbsp;--&nbsp;使用键名比较计算数组的差集</p>\r\n\r\n<p><a href="http://www.kuqin.com/php5_doc/function.array-diff-uassoc.html">array_diff_uassoc</a>&nbsp;--&nbsp;用用户提供的回调函数做索引检查来计算数组的差集</p>\r\n\r\n<p><a href="http://www.kuqin.com/php5_doc/function.array-diff-ukey.html">array_diff_ukey</a>&nbsp;--&nbsp;用回调函数对键名比较计算数组的差集</p>\r\n\r\n<p><a href="http://www.kuqin.com/php5_doc/function.array-diff.html">array_diff</a>&nbsp;--&nbsp;计算数组的差集</p>\r\n\r\n<p><a href="http://www.kuqin.com/php5_doc/function.array-fill.html">array_fill</a>&nbsp;--&nbsp;用给定的值填充数组</p>\r\n\r\n<p><a href="http://www.kuqin.com/php5_doc/function.array-filter.html">array_filter</a>&nbsp;--&nbsp; 用回调函数过滤数组中的单元</p>\r\n\r\n<p><a href="http://www.kuqin.com/php5_doc/function.array-flip.html">array_flip</a>&nbsp;--&nbsp;交换数组中的键和值</p>\r\n\r\n<p><a href="http://www.kuqin.com/php5_doc/function.array-intersect-assoc.html">array_intersect_assoc</a>&nbsp;--&nbsp;带索引检查计算数组的交集</p>\r\n\r\n<p><a href="http://www.kuqin.com/php5_doc/function.array-intersect-key.html">array_intersect_key</a>&nbsp;--&nbsp;使用键名比较计算数组的交集</p>\r\n\r\n<p><a href="http://www.kuqin.com/php5_doc/function.array-intersect-uassoc.html">array_intersect_uassoc</a>&nbsp;--&nbsp;带索引检查计算数组的交集，用回调函数比较索引</p>\r\n\r\n<p><a href="http://www.kuqin.com/php5_doc/function.array-intersect-ukey.html">array_intersect_ukey</a>&nbsp;--&nbsp;用回调函数比较键名来计算数组的交集</p>\r\n\r\n<p><a href="http://www.kuqin.com/php5_doc/function.array-intersect.html">array_intersect</a>&nbsp;--&nbsp;计算数组的交集</p>\r\n\r\n<p><a href="http://www.kuqin.com/php5_doc/function.array-key-exists.html">array_key_exists</a>&nbsp;--&nbsp;检查给定的键名或索引是否存在于数组中</p>\r\n\r\n<p><a href="http://www.kuqin.com/php5_doc/function.array-keys.html">array_keys</a>&nbsp;--&nbsp;返回数组中所有的键名</p>\r\n\r\n<p><a href="http://www.kuqin.com/php5_doc/function.array-map.html">array_map</a>&nbsp;--&nbsp; 将回调函数作用到给定数组的单元上</p>\r\n\r\n<p><a href="http://www.kuqin.com/php5_doc/function.array-merge-recursive.html">array_merge_recursive</a>&nbsp;--&nbsp;递归地合并一个或多个数组</p>\r\n\r\n<p><a href="http://www.kuqin.com/php5_doc/function.array-merge.html">array_merge</a>&nbsp;--&nbsp;合并一个或多个数组</p>\r\n\r\n<p><a href="http://www.kuqin.com/php5_doc/function.array-multisort.html">array_multisort</a>&nbsp;--&nbsp;对多个数组或多维数组进行排序</p>\r\n\r\n<p><a href="http://www.kuqin.com/php5_doc/function.array-pad.html">array_pad</a>&nbsp;--&nbsp; 用值将数组填补到指定长度</p>\r\n\r\n<p><a href="http://www.kuqin.com/php5_doc/function.array-pop.html">array_pop</a>&nbsp;--&nbsp;将数组最后一个单元弹出（出栈）</p>\r\n\r\n<p><a href="http://www.kuqin.com/php5_doc/function.array-product.html">array_product</a>&nbsp;--&nbsp;计算数组中所有值的乘积</p>\r\n\r\n<p><a href="http://www.kuqin.com/php5_doc/function.array-push.html">array_push</a>&nbsp;--&nbsp; 将一个或多个单元压入数组的末尾（入栈）</p>\r\n\r\n<p><a href="http://www.kuqin.com/php5_doc/function.array-rand.html">array_rand</a>&nbsp;--&nbsp; 从数组中随机取出一个或多个单元</p>\r\n\r\n<p><a href="http://www.kuqin.com/php5_doc/function.array-reduce.html">array_reduce</a>&nbsp;--&nbsp;用回调函数迭代地将数组简化为单一的值</p>\r\n\r\n<p><a href="http://www.kuqin.com/php5_doc/function.array-reverse.html">array_reverse</a>&nbsp;--&nbsp; 返回一个单元顺序相反的数组</p>\r\n\r\n<p><a href="http://www.kuqin.com/php5_doc/function.array-search.html">array_search</a>&nbsp;--&nbsp; 在数组中搜索给定的值，如果成功则返回相应的键名</p>\r\n\r\n<p><a href="http://www.kuqin.com/php5_doc/function.array-shift.html">array_shift</a>&nbsp;--&nbsp; 将数组开头的单元移出数组</p>\r\n\r\n<p><a href="http://www.kuqin.com/php5_doc/function.array-slice.html">array_slice</a>&nbsp;--&nbsp;从数组中取出一段</p>\r\n\r\n<p><a href="http://www.kuqin.com/php5_doc/function.array-splice.html">array_splice</a>&nbsp;--&nbsp; 把数组中的一部分去掉并用其它值取代</p>\r\n\r\n<p><a href="http://www.kuqin.com/php5_doc/function.array-sum.html">array_sum</a>&nbsp;--&nbsp; 计算数组中所有值的和</p>\r\n\r\n<p><a href="http://www.kuqin.com/php5_doc/function.array-udiff-assoc.html">array_udiff_assoc</a>&nbsp;--&nbsp;带索引检查计算数组的差集，用回调函数比较数据</p>\r\n\r\n<p><a href="http://www.kuqin.com/php5_doc/function.array-udiff-uassoc.html">array_udiff_uassoc</a>&nbsp;--&nbsp;带索引检查计算数组的差集，用回调函数比较数据和索引</p>\r\n\r\n<p><a href="http://www.kuqin.com/php5_doc/function.array-udiff.html">array_udiff</a>&nbsp;--&nbsp;用回调函数比较数据来计算数组的差集</p>\r\n\r\n<p><a href="http://www.kuqin.com/php5_doc/function.array-uintersect-assoc.html">array_uintersect_assoc</a>&nbsp;--&nbsp;带索引检查计算数组的交集，用回调函数比较数据</p>\r\n\r\n<p><a href="http://www.kuqin.com/php5_doc/function.array-uintersect-uassoc.html">array_uintersect_uassoc</a>&nbsp;--&nbsp;带索引检查计算数组的交集，用回调函数比较数据和索引</p>\r\n\r\n<p><a href="http://www.kuqin.com/php5_doc/function.array-uintersect.html">array_uintersect</a>&nbsp;--&nbsp;计算数组的交集，用回调函数比较数据</p>\r\n\r\n<p><a href="http://www.kuqin.com/php5_doc/function.array-unique.html">array_unique</a>&nbsp;--&nbsp;移除数组中重复的值</p>\r\n\r\n<p><a href="http://www.kuqin.com/php5_doc/function.array-unshift.html">array_unshift</a>&nbsp;--&nbsp; 在数组开头插入一个或多个单元</p>\r\n\r\n<p><a href="http://www.kuqin.com/php5_doc/function.array-values.html">array_values</a>&nbsp;--&nbsp;返回数组中所有的值</p>\r\n\r\n<p><a href="http://www.kuqin.com/php5_doc/function.array-walk-recursive.html">array_walk_recursive</a>&nbsp;--&nbsp;对数组中的每个成员递归地应用用户函数</p>\r\n\r\n<p><a href="http://www.kuqin.com/php5_doc/function.array-walk.html">array_walk</a>&nbsp;--&nbsp;对数组中的每个成员应用用户函数</p>\r\n\r\n<p><a href="http://www.kuqin.com/php5_doc/function.array.html">array</a>&nbsp;--&nbsp; 新建一个数组</p>\r\n\r\n<p><a href="http://www.kuqin.com/php5_doc/function.arsort.html">arsort</a>&nbsp;--&nbsp; 对数组进行逆向排序并保持索引关系</p>\r\n\r\n<p><a href="http://www.kuqin.com/php5_doc/function.asort.html">asort</a>&nbsp;--&nbsp;对数组进行排序并保持索引关系</p>\r\n\r\n<p><a href="http://www.kuqin.com/php5_doc/function.compact.html">compact</a>&nbsp;--&nbsp; 建立一个数组，包括变量名和它们的值</p>\r\n\r\n<p><a href="http://www.kuqin.com/php5_doc/function.count.html">count</a>&nbsp;--&nbsp;计算数组中的单元数目或对象中的属性个数</p>\r\n\r\n<p><a href="http://www.kuqin.com/php5_doc/function.current.html">current</a>&nbsp;--&nbsp;返回数组中的当前单元</p>\r\n\r\n<p><a href="http://www.kuqin.com/php5_doc/function.each.html">each</a>&nbsp;--&nbsp; 返回数组中当前的键／值对并将数组指针向前移动一步</p>\r\n\r\n<p><a href="http://www.kuqin.com/php5_doc/function.end.html">end</a>&nbsp;--&nbsp; 将数组的内部指针指向最后一个单元</p>\r\n\r\n<p><a href="http://www.kuqin.com/php5_doc/function.extract.html">extract</a>&nbsp;--&nbsp; 从数组中将变量导入到当前的符号表</p>\r\n\r\n<p><a href="http://www.kuqin.com/php5_doc/function.in-array.html">in_array</a>&nbsp;--&nbsp;检查数组中是否存在某个值</p>\r\n\r\n<p><a href="http://www.kuqin.com/php5_doc/function.key.html">key</a>&nbsp;--&nbsp;从关联数组中取得键名</p>\r\n\r\n<p><a href="http://www.kuqin.com/php5_doc/function.krsort.html">krsort</a>&nbsp;--&nbsp;对数组按照键名逆向排序</p>\r\n\r\n<p><a href="http://www.kuqin.com/php5_doc/function.ksort.html">ksort</a>&nbsp;--&nbsp;对数组按照键名排序</p>\r\n\r\n<p><a href="http://www.kuqin.com/php5_doc/function.list.html">list</a>&nbsp;--&nbsp; 把数组中的值赋给一些变量</p>\r\n\r\n<p><a href="http://www.kuqin.com/php5_doc/function.natcasesort.html">natcasesort</a>&nbsp;--&nbsp; 用&ldquo;自然排序&rdquo;算法对数组进行不区分大小写字母的排序</p>\r\n\r\n<p><a href="http://www.kuqin.com/php5_doc/function.natsort.html">natsort</a>&nbsp;--&nbsp; 用&ldquo;自然排序&rdquo;算法对数组排序</p>\r\n\r\n<p><a href="http://www.kuqin.com/php5_doc/function.next.html">next</a>&nbsp;--&nbsp; 将数组中的内部指针向前移动一位</p>\r\n\r\n<p><a href="http://www.kuqin.com/php5_doc/function.pos.html">pos</a>&nbsp;--&nbsp;<a href="http://www.kuqin.com/php5_doc/function.current.html"><strong>current()</strong></a> 的别名</p>\r\n\r\n<p><a href="http://www.kuqin.com/php5_doc/function.prev.html">prev</a>&nbsp;--&nbsp;将数组的内部指针倒回一位</p>\r\n\r\n<p><a href="http://www.kuqin.com/php5_doc/function.range.html">range</a>&nbsp;--&nbsp; 建立一个包含指定范围单元的数组</p>\r\n\r\n<p><a href="http://www.kuqin.com/php5_doc/function.reset.html">reset</a>&nbsp;--&nbsp; 将数组的内部指针指向第一个单元</p>\r\n\r\n<p><a href="http://www.kuqin.com/php5_doc/function.rsort.html">rsort</a>&nbsp;--&nbsp;对数组逆向排序</p>\r\n\r\n<p><a href="http://www.kuqin.com/php5_doc/function.shuffle.html">shuffle</a>&nbsp;--&nbsp;将数组打乱</p>\r\n\r\n<p><a href="http://www.kuqin.com/php5_doc/function.sizeof.html">sizeof</a>&nbsp;--&nbsp;<a href="http://www.kuqin.com/php5_doc/function.count.html"><strong>count()</strong></a> 的别名</p>\r\n\r\n<p><a href="http://www.kuqin.com/php5_doc/function.sort.html">sort</a>&nbsp;--&nbsp;对数组排序</p>\r\n\r\n<p><a href="http://www.kuqin.com/php5_doc/function.uasort.html">uasort</a>&nbsp;--&nbsp; 使用用户自定义的比较函数对数组中的值进行排序并保持索引关联</p>\r\n\r\n<p><a href="http://www.kuqin.com/php5_doc/function.uksort.html">uksort</a>&nbsp;--&nbsp; 使用用户自定义的比较函数对数组中的键名进行排序</p>\r\n\r\n<p><a href="http://www.kuqin.com/php5_doc/function.usort.html">usort</a>&nbsp;--&nbsp; 使用用户自定义的比较函数对数组中的值进行排序</p>\r\n', '', NULL, 0, 1),
(93, 4, 92, 'Array常用', '', '', NULL, 9, 1),
(94, 4, 92, 'Array排序', '', '', NULL, 8, 1),
(95, 4, 92, 'Array操作', '', '', NULL, 0, 1),
(96, 4, 92, '相关函数', '<p>&nbsp;&nbsp;&nbsp; PHP中最常用到的数据结构就是数组，数组可以帮我们解决很大一部分的编程问题。其实有很多数组操作不用我们自己写，系统已经自带了相关的函数了。下面我们介绍一些关于PHP数组操作的函数，也许有些你没有听说过。</p>\r\n\r\n<p>&nbsp;&nbsp;&nbsp; 在数组中搜索一个特定值，如果找到返回TRUE否则返回FALSE<br />\r\n&nbsp;&nbsp; &nbsp;<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;boolean in_array(mixed needle,array haystack[,boolean strict])<br />\r\n&nbsp;&nbsp;&nbsp; 在数组中找到一个指定的健，如果找到返回TRUE否则返回FALSE<br />\r\n&nbsp;&nbsp; &nbsp;<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;boolean array_eky_exists(mixed key,array array)<br />\r\n&nbsp;&nbsp;&nbsp; 在数组中搜索一个特定值，如果找到返回TRUE否则返回FALSE<br />\r\n&nbsp;&nbsp; &nbsp;<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;boolean array_search(mixed needle,array haystack[,boolean strict])<br />\r\n&nbsp;&nbsp;&nbsp; 获取数组所有键组成的新数组<br />\r\n&nbsp;&nbsp; &nbsp;<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;array array_keys(array array[,mixed search_value])<br />\r\n&nbsp;&nbsp;&nbsp; 获取数组所有值组成的新数组<br />\r\n&nbsp;&nbsp; &nbsp;<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;array array_values(array array)<br />\r\n&nbsp;&nbsp;&nbsp; 确定数组大小<br />\r\n&nbsp;&nbsp; &nbsp;<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;integer count(array array[,int mode])<br />\r\n&nbsp;&nbsp; &nbsp;<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;integer sizeof(array array[,int mode])<br />\r\n&nbsp;&nbsp;&nbsp; 统计数组元素出现频率<br />\r\n&nbsp;&nbsp; &nbsp;<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;array array_count_values(array array)<br />\r\n&nbsp;&nbsp;&nbsp; 删除数组中重复的值，返回一个由唯一值组成的数组<br />\r\n&nbsp;&nbsp; &nbsp;<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;array array_unique(array array)<br />\r\n&nbsp;&nbsp;&nbsp; 逆置数组元素顺序,preserve_key如果为TRUE则数组键值顺序不变<br />\r\n&nbsp;&nbsp; &nbsp;<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;array array_reverse(array array[,boolean preserve_key])<br />\r\n&nbsp;&nbsp;&nbsp; 置换数组键和值<br />\r\n&nbsp;&nbsp; &nbsp;<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;array array_flip(array array)<br />\r\n&nbsp;&nbsp;&nbsp; 数组顺序排序，sort_flags参数可选，默认行为<br />\r\n&nbsp;&nbsp; &nbsp;<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;SORT_NUMBERIC，按数值排序，对整数或浮点数排序很有用<br />\r\n&nbsp;&nbsp; &nbsp;<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;SORT_REGULAR，按照ASCII值排序<br />\r\n&nbsp;&nbsp; &nbsp;<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;SORT_STRING，按接近人所认识的正确顺序排序<br />\r\n&nbsp;&nbsp; &nbsp;<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;asort函数键值顺序不变<br />\r\n&nbsp;&nbsp; &nbsp;<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;void sort(array array[,int sort_flags])<br />\r\n&nbsp;&nbsp; &nbsp;<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;void asort(array array[,int sort_flags])<br />\r\n&nbsp;&nbsp;&nbsp; 数组逆序排序，sort_flags参数可选，默认行为<br />\r\n&nbsp;&nbsp; &nbsp;<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;SORT_NUMBERIC，按数值排序，对整数或浮点数排序很有用<br />\r\n&nbsp;&nbsp; &nbsp;<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;SORT_REGULAR，按照ASCII值排序<br />\r\n&nbsp;&nbsp; &nbsp;<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;SORT_STRING，按接近人所认识的正确顺序排序<br />\r\n&nbsp;&nbsp; &nbsp;<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;arsort函数键值顺序不变<br />\r\n&nbsp;&nbsp; &nbsp;<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;void rsort(array array[,int sort_flags])<br />\r\n&nbsp;&nbsp; &nbsp;<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;void arsort(array array[,int sort_flags])<br />\r\n&nbsp;&nbsp;&nbsp; 数组自然排序<br />\r\n&nbsp;&nbsp; &nbsp;<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;void natsort(array array)<br />\r\n&nbsp;&nbsp;&nbsp; 不区分大小写的自然排序<br />\r\n&nbsp;&nbsp; &nbsp;<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;void natcasesort(array array)<br />\r\n&nbsp;&nbsp;&nbsp; 健键值对数组排序<br />\r\n&nbsp;&nbsp; &nbsp;<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;boolean ksort(array array[,int sort_flags])<br />\r\n&nbsp;&nbsp;&nbsp; 健键值对数组逆序排序<br />\r\n&nbsp;&nbsp; &nbsp;<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;boolean krsort(array array[,int sort_flags])<br />\r\n&nbsp;&nbsp;&nbsp; 根据用户自定义顺序排序<br />\r\n&nbsp;&nbsp; &nbsp;<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;void usort(array array,callback function_name)<br />\r\n&nbsp;&nbsp;&nbsp; 将数组合并到一起，返回一个联合的数组。array_merge后面覆盖前面，array_merge_recursive合并在一起<br />\r\n&nbsp;&nbsp; &nbsp;<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;array array_merge(array array1[array array2&hellip;&hellip;])//一个以上<br />\r\n&nbsp;&nbsp; &nbsp;<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;array array_merge_recursive(array array1,array array2[,array &hellip;&hellip;])//两个以上<br />\r\n&nbsp;&nbsp;&nbsp; 键和值组成新的数组<br />\r\n&nbsp;&nbsp; &nbsp;<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;array array_combine(array key,array value)<br />\r\n&nbsp;&nbsp;&nbsp; 返回数组一部分，从健offset开始，到offse+length位置结束<br />\r\n&nbsp;&nbsp; &nbsp;<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;array array_slice(array array, int offset [,int length])<br />\r\n&nbsp;&nbsp;&nbsp; 删除从offset开始到offset+length结束的所有元素，并以数组的形式返回删除的元素<br />\r\n&nbsp;&nbsp; &nbsp;<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;array array_splice(array, int offset [,int length[,array peplacement]])<br />\r\n&nbsp;&nbsp;&nbsp; 求数组的交集,键值为第一个数组中键值<br />\r\n&nbsp;&nbsp; &nbsp;<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;array array_intersect(array array1,array array2[,arrayN&hellip;&hellip;])<br />\r\n&nbsp;&nbsp;&nbsp; 求数组的交集包含了键值相等,键值为第一个数组中键值<br />\r\n&nbsp;&nbsp; &nbsp;<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;array array_intersect_assoc(array array1,array array2[,arrayN&hellip;&hellip;])<br />\r\n&nbsp;&nbsp;&nbsp; 求数组的差集，第一个数组在其他数组没有的值<br />\r\n&nbsp;&nbsp; &nbsp;<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;array array_diff(array array1,array array2[,arrayN&hellip;&hellip;])<br />\r\n&nbsp;&nbsp;&nbsp; 求数组的差集，第一个数组在其他数组没有的值包含了键值相等<br />\r\n&nbsp;&nbsp; &nbsp;<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;array array_diffassoc(array array1,array array2[,arrayN&hellip;&hellip;])<br />\r\n&nbsp;&nbsp;&nbsp; 返回数组中一个或多个键值<br />\r\n&nbsp;&nbsp; &nbsp;<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;mixed array_rand(array array[,int num_entries])<br />\r\n&nbsp;&nbsp;&nbsp; 随即洗牌函数<br />\r\n&nbsp;&nbsp; &nbsp;<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;void shuffle(array input_array)<br />\r\n&nbsp;&nbsp;&nbsp; 对数组中的值求和<br />\r\n&nbsp;&nbsp; &nbsp;<br />\r\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;mixed array_sum(array array);<br />\r\n&nbsp;&nbsp;&nbsp; 将数组分解为一个多维数组，它包含了size个元素<br />\r\n&nbsp;&nbsp; &nbsp;array array_chunk(array array, int size [,boolean preserve_keys])</p>\r\n\r\n<p>&nbsp;</p>\r\n', 'PHP中最常用到的数据结构就是数组，数组可以帮我们解决很大一部分的编程问题。其实有很多数组操作不用我们自己写，系统已经自带了相关的函数了。下面我们介绍一些关于PHP数组操作的函数，也许有些你没有听说过。\r\n\r\n在数组中搜索一个特定值，如果找到返回TRUE否则返回FALSE\r\n\r\n	boolean in_array(mixed needle,array haystack[,boolean strict])\r\n在数组中找到一个指定的健，如果找到返回TRUE否则返回FALSE\r\n\r\n	boolean array_eky_exists(mixed key,array array)\r\n在数组中搜索一个特定值，如果找到返回TRUE否则返回FALSE\r\n\r\n	boolean array_search(mixed needle,array haystack[,boolean strict])\r\n获取数组所有键组成的新数组\r\n\r\n	array array_keys(array array[,mixed search_value])\r\n获取数组所有值组成的新数组\r\n\r\n	array array_values(array array)\r\n确定数组大小\r\n\r\n	integer count(array array[,int mode])\r\n\r\n	integer sizeof(array array[,int mode])\r\n统计数组元素出现频率\r\n\r\n	array array_count_values(array array)\r\n删除数组中重复的值，返回一个由唯一值组成的数组\r\n\r\n	array array_unique(array array)\r\n逆置数组元素顺序,preserve_key如果为TRUE则数组键值顺序不变\r\n\r\n	array array_reverse(array array[,boolean preserve_key])\r\n置换数组键和值\r\n\r\n	array array_flip(array array)\r\n数组顺序排序，sort_flags参数可选，默认行为\r\n\r\n	SORT_NUMBERIC，按数值排序，对整数或浮点数排序很有用\r\n\r\n	SORT_REGULAR，按照ASCII值排序\r\n\r\n	SORT_STRING，按接近人所认识的正确顺序排序\r\n\r\n	asort函数键值顺序不变\r\n\r\n	void sort(array array[,int sort_flags])\r\n\r\n	void asort(array array[,int sort_flags])\r\n数组逆序排序，sort_flags参数可选，默认行为\r\n\r\n	SORT_NUMBERIC，按数值排序，对整数或浮点数排序很有用\r\n\r\n	SORT_REGULAR，按照ASCII值排序\r\n\r\n	SORT_STRING，按接近人所认识的正确顺序排序\r\n\r\n	arsort函数键值顺序不变\r\n\r\n	void rsort(array array[,int sort_flags])\r\n\r\n	void arsort(array array[,int sort_flags])\r\n数组自然排序\r\n\r\n	void natsort(array array)\r\n不区分大小写的自然排序\r\n\r\n	void natcasesort(array array)\r\n健键值对数组排序\r\n\r\n	boolean ksort(array array[,int sort_flags])\r\n健键值对数组逆序排序\r\n\r\n	boolean krsort(array array[,int sort_flags])\r\n根据用户自定义顺序排序\r\n\r\n	void usort(array array,callback function_name)\r\n将数组合并到一起，返回一个联合的数组。array_merge后面覆盖前面，array_merge_recursive合并在一起\r\n\r\n	array array_merge(array array1[array array2……])//一个以上\r\n\r\n	array array_merge_recursive(array array1,array array2[,array ……])//两个以上\r\n键和值组成新的数组\r\n\r\n	array array_combine(array key,array value)\r\n返回数组一部分，从健offset开始，到offse+length位置结束\r\n\r\n	array array_slice(array array, int offset [,int length])\r\n删除从offset开始到offset+length结束的所有元素，并以数组的形式返回删除的元素\r\n\r\n	array array_splice(array, int offset [,int length[,array peplacement]])\r\n求数组的交集,键值为第一个数组中键值\r\n\r\n	array array_intersect(array array1,array array2[,arrayN……])\r\n求数组的交集包含了键值相等,键值为第一个数组中键值\r\n\r\n	array array_intersect_assoc(array array1,array array2[,arrayN……])\r\n求数组的差集，第一个数组在其他数组没有的值\r\n\r\n	array array_diff(array array1,array array2[,arrayN……])\r\n求数组的差集，第一个数组在其他数组没有的值包含了键值相等\r\n\r\n	array array_diffassoc(array array1,array array2[,arrayN……])\r\n返回数组中一个或多个键值\r\n\r\n	mixed array_rand(array array[,int num_entries])\r\n随即洗牌函数\r\n\r\n	void shuffle(array input_array)\r\n对数组中的值求和\r\n\r\n	mixed array_sum(array array);\r\n将数组分解为一个多维数组，它包含了size个元素\r\n	array array_chunk(array array, int size [,boolean preserve_keys])\r\n', NULL, 11, 1),
(97, 5, 83, '表格', '<p>Year | Temperature (low) | Temperature (high)<br />\r\n--- | --- | ---<br />\r\n1900 | -10 | 25<br />\r\n1910 | -15 | 30<br />\r\n1920 | -10 | 32</p>\r\n', 'Year | Temperature (low) | Temperature (high)\r\n--- | --- | ---\r\n1900 | -10 | 25\r\n1910 | -15 | 30\r\n1920 | -10 | 32', NULL, 2, 1),
(98, 4, 92, '数组的排序函数', '<p>&nbsp;*&nbsp;&nbsp; sort()<br />\r\n&nbsp;*&nbsp;&nbsp; rsort()<br />\r\n&nbsp;*&nbsp;&nbsp; usort()<br />\r\n&nbsp;*&nbsp;&nbsp; asort()<br />\r\n&nbsp;*&nbsp;&nbsp; arsort()<br />\r\n&nbsp;*&nbsp;&nbsp; uasort()<br />\r\n&nbsp;*&nbsp;&nbsp; ksort()<br />\r\n&nbsp;*&nbsp;&nbsp; krsort()<br />\r\n&nbsp;*&nbsp;&nbsp; uksort()<br />\r\n&nbsp;*&nbsp;&nbsp; uatsort()<br />\r\n&nbsp;*&nbsp;&nbsp; natcasesort()<br />\r\n&nbsp;*&nbsp;&nbsp; array_multisort()</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;*&nbsp;&nbsp;&nbsp; 1.简单的数组排序<br />\r\n&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sort() rsort()<br />\r\n&nbsp;*&nbsp;&nbsp;&nbsp; 2.根据键名对数组排序<br />\r\n&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ksort() krsort()<br />\r\n&nbsp;*&nbsp;&nbsp;&nbsp; 3.根据元素的值对数组排序<br />\r\n&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; asort() arsort()<br />\r\n&nbsp;*&nbsp;&nbsp;&nbsp; 4.根据&quot;自然数排序&ldquo;法对数组排序<br />\r\n&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; natsort()//区分大小写字母比较 natcasescort()//不区分大小写字母的比较<br />\r\n&nbsp;*&nbsp;&nbsp;&nbsp; 5.根据用户自定义规则对数组排序<br />\r\n&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; usort() uasort() uksort()对键排序<br />\r\n&nbsp;*&nbsp;&nbsp;&nbsp; 6.对维数组的排序<br />\r\n&nbsp;*&nbsp;&nbsp;&nbsp; array_multisort()</p>\r\n', ' \r\n    //简单数组排序的使用\r\n	$data=array(5,8,1,7,2);\r\n	sort($data);//元素由小到大进行排序\r\n	print_r($data);//Array ( [0] => 1 [1] => 2 [2] => 5 [3] => 7 [4] => 8 )\r\n	rsort($data);//元素由大到小进行排序\r\n	print_r($data);//Array ( [0] => 8 [1] => 7 [2] => 5 [3] => 2 [4] => 1 )\r\n\r\n	//根据键名排序的例子\r\n	$data_2=array(5=>"five",8=>"eight",1=>"one",7=>"seven",2=>"two");\r\n	ksort($data_2);//对数组的下标进行由小到大排序\r\n	print_r($data_2);//Array ( [1] => one [2] => two [5] => five [7] => seven [8] => eight )\r\n	krsort($data_2);//对数组的下标进行由大到小排序\r\n	print_r($data_2);//Array ( [8] => eight [7] => seven [5] => five [2] => two [1] => one )\r\n\r\n	 \r\n\r\n	//根据元素的值对数组排序\r\n	$data_3=array("1"=>"Linux","a"=>"Apache","m"=>"MySQL","l"=>"PHP");\r\n	//asort() arsort  与 sort() rsort()的区别在于 前者排序后保持原有的键名,后者不保持原有键名，且键名从0开始\r\n	asort($data_3);\r\n	print_r($data_3);//Array ( [a] => Apache [1] => Linux [m] => MySQL [l] => PHP )\r\n	echo ''\r\n	'';\r\n	arsort($data_3);\r\n	print_r($data_3);//Array ( [l] => PHP [m] => MySQL [1] => Linux [a] => Apache )\r\n	echo ''\r\n	'';\r\n	sort($data_3);\r\n	print_r($data_3);//Array ( [0] => Apache [1] => Linux [2] => MySQL [3] => PHP )\r\n	echo ''\r\n	'';\r\n	rsort($data_3);\r\n	print_r($data_3);//Array ( [0] => PHP [1] => MySQL [2] => Linux [3] => Apache )\r\n\r\n	//根据”自然数排序法“对数组排序(0-9短者优先)\r\n	$data_4=array("file.txt","file11.txt","file2.txt","file22.txt");\r\n	sort($data_4);\r\n	print_r($data_4);//Array ( [0] => file.txt [1] => file11.txt [2] => file2.txt [3] => file22.txt )\r\n	echo ''\r\n	'';\r\n	natsort($data_4);\r\n	print_r($data_4);//Array ( [0] => file.txt [2] => file2.txt [1] => file11.txt [3] => file22.txt )\r\n	echo ''\r\n	'';\r\n	natcasesort($data_4);\r\n	print_r($data_4);//Array ( [0] => file.txt [2] => file2.txt [1] => file11.txt [3] => file22.txt )\r\n	echo ''\r\n	'';', NULL, 99, 1),
(99, 4, 92, '拆分、合并、分解、接合的数组函数', '<p>*&nbsp;&nbsp;&nbsp; 1.array_slice()<br />\r\n&nbsp;*&nbsp;&nbsp;&nbsp; 2.array_splice()//删除<br />\r\n&nbsp;*&nbsp;&nbsp;&nbsp; 3.array_combine()//合并<br />\r\n&nbsp;*&nbsp;&nbsp;&nbsp; 4.array_merge();//合并<br />\r\n&nbsp;*&nbsp;&nbsp;&nbsp; 5.array_intersect();//多个数组的交集<br />\r\n&nbsp;*&nbsp;&nbsp;&nbsp; 6.array_diff();//返回多个数组的差集</p>\r\n', '\r\n\r\n	//用户自定义排序函数\r\n	echo ''\r\n	'';\r\n	$data_5=array("Linux","Apache","MySQL","PHP");\r\n	usort($data_5,"sortbylen");//通过元素长度排序\r\n	print_r($data_5);//Array ( [0] => PHP [1] => MySQL [2] => Linux [3] => Apache )\r\n	function sortbylen($one,$two){\r\n	 if(strlen($one)==strlen($two))\r\n	  return 0;\r\n	 else\r\n	  return (strlen($one)>strlen($two))?1:-1;\r\n	}\r\n\r\n	//拆分、合并、分解、接合的数组函数\r\n	echo ''\r\n	'';\r\n	$data_6=array("Linux","Apache","MySQL","PHP");\r\n	print_r(array_slice($data_6,1,2));//取下标为1、2的元素\r\n	//Array ( [0] => Apache [1] => MySQL ) 下标重置从0开始\r\n	echo ''\r\n	'';\r\n\r\n	print_r(array_slice($data_6,-2,1));//从后边的第二个开始取返回一个，不是从0开始的\r\n	//Array ( [0] => MySQL ) 下标重置从0开始\r\n	echo ''\r\n	'';\r\n\r\n	print_r(array_slice($data_6,1,2,true));\r\n	//Array ( [1] => Apache [2] => MySQL )  保留原有的下标\r\n\r\n	echo ''\r\n	'';\r\n\r\n\r\n	//array_combine()\r\n	$a1=array("OS","WebServer","DataBase","Language");\r\n	$a2=array("Linux","Apache","MySQL","PHP");\r\n\r\n	print_r(array_combine($a1,$a2));//第一个参数作为键名，第二个作为值来合并\r\n	//Array ( [OS] => Linux [WebServer] => Apache [DataBase] => MySQL [Language] => PHP )\r\n\r\n	echo ''\r\n	'';\r\n\r\n	//array_merge()\r\n	$a3=array("OS","WebServer","DataBase","Language");\r\n	$a4=array("Linux","Apache","MySQL","PHP");\r\n	$a5=$a3+$a4;\r\n	print_r($a5);//因为两个数组下标重复所以显示这样\r\n	//Array ( [0] => OS [1] => WebServer [2] => DataBase [3] => Language )\r\n	echo ''\r\n	'';\r\n	print_r(array_merge($a3,$a4));//合并并重新索引\r\n	//Array ( [0] => OS [1] => WebServer [2] => DataBase [3] => Language [4] => Linux [5] => Apache [6] => MySQL [7] => PHP )\r\n\r\n	echo ''\r\n	'';\r\n\r\n	//array_intersect()\r\n	$a7=array("OS","WebServer","DataBase","Language",1,2,3);\r\n	$a8=array("Linux","Apache","MySQL","PHP",2,3,4);\r\n	print_r(array_intersect($a7,$a8));//Array ( [5] => 2 [6] => 3 )\r\n	echo ''\r\n	'';\r\n\r\n	//array_diff()\r\n	$a9=array(1,2,3,4);\r\n	$a10=array(3,4,5,6);\r\n	print_r(array_diff($a9,$a10));//Array ( [0] => 1 [1] => 2 )\r\n	//返回第一个数组跟第二个相差的元素\r\n	echo ''\r\n	'';', NULL, 88, 1),
(100, 4, 92, '数组与数据结构的函数', '<p>&nbsp;*&nbsp;&nbsp; 1.使用数组实现堆栈 //先进后出<br />\r\n&nbsp;*&nbsp;&nbsp; &nbsp;array_push() array_pop()<br />\r\n&nbsp;*&nbsp;&nbsp; 2.使用数组实现队列 //先进先出<br />\r\n&nbsp;*&nbsp;&nbsp; &nbsp;array_unshift() array_shift() unset()</p>\r\n', '\r\n	//使用数组实现堆栈\r\n	$b=array(1,2,3,4);\r\n	$b[]="a";//入栈\r\n	array_push($b,"b","c");//使用函数入栈\r\n	print_r($b);//Array ( [0] => 1 [1] => 2 [2] => 3 [3] => 4 [4] => a [5] => b [6] => c )\r\n	echo ''\r\n	'';\r\n\r\n	$value=array_pop($b);//使用函数出栈\r\n	print_r($b);//Array ( [0] => 1 [1] => 2 [2] => 3 [3] => 4 [4] => a [5] => b )\r\n	echo ''\r\n	'';\r\n	echo $value;//显示出栈的元素的值 c\r\n	echo ''\r\n	'';\r\n\r\n	//使用数组实现队列\r\n	$c=array(1,2,3);\r\n	print_r($c);//Array ( [0] => 1 [1] => 2 [2] => 3 )\r\n	echo ''\r\n	'';\r\n	array_unshift($c,"abc","bcd");//入队\r\n	print_r($c);//Array ( [0] => abc [1] => bcd [2] => 1 [3] => 2 [4] => 3 )\r\n	echo ''\r\n	'';\r\n	$values=array_shift($c);//出队\r\n	print_r($c);// Array ( [0] => bcd [1] => 1 [2] => 2 [3] => 3 )\r\n	echo ''\r\n	'';\r\n	unset($c[2]);//删除指定位置元素\r\n	print_r($c);//Array ( [0] => bcd [1] => 1 [3] => 3 )\r\n	echo ''\r\n	'';', NULL, 77, 1),
(101, 4, 92, '其他与数组操作有关的函数', '<p>&nbsp;*&nbsp;&nbsp;&nbsp; array_rand()<br />\r\n&nbsp;*&nbsp;&nbsp;&nbsp; shuffle()<br />\r\n&nbsp;*&nbsp;&nbsp;&nbsp; array_sum()<br />\r\n&nbsp;*&nbsp;&nbsp;&nbsp; range()</p>\r\n', '	//array_rand()  随机返回数组下标\r\n	$arr=array(1,3,4,5,76,7,99,6,2,3);\r\n	echo array_rand($arr);//返回的是随机的数组元素的下标\r\n	echo $arr[array_rand($arr)];//随机显示数组元素的值\r\n	echo ''\r\n	'';\r\n	//shuffle()  随机重新排列数组\r\n	$arr2=array(32,35,33);\r\n	shuffle($arr2);\r\n	print_r($arr2);//数组元素位置随机变换\r\n	echo ''\r\n	'';\r\n	//array_sum()  求和\r\n	$arr3=array(1,3,5);\r\n	echo array_sum($arr3); //返回9\r\n	echo ''\r\n	'';\r\n	print_r($arr3);//Array ( [0] => 1 [1] => 3 [2] => 5 )\r\n	echo ''\r\n	'';\r\n	//range(最小值，最大值，步长)\r\n	$arr4=range(0,100,10);\r\n	print_r($arr4);//Array ( [0] => 0 [1] => 10 [2] => 20 [3] => 30 [4] => 40 [5] => 50 [6] => 60 [7] => 70 [8] => 80 [9] => 90 [10] => 100 )', NULL, 66, 1);
INSERT INTO `g_booknode` (`nodeid`, `bookid`, `preid`, `title`, `nr`, `nrcode`, `type`, `sort`, `enable`) VALUES
(102, 4, 0, 'PHP字符串函数', '<h1><a href="http://www.cnblogs.com/freespider/archive/2010/08/19/1803308.html">php字符串处理函数大全</a></h1>\r\n\r\n<p>addcslashes &mdash; 为字符串里面的部分字符添加反斜线转义字符<br />\r\naddslashes &mdash; 用指定的方式对字符串里面的字符进行转义<br />\r\nbin2hex &mdash; 将二进制数据转换成十六进制表示<br />\r\nchop &mdash; rtrim() 的别名函数<br />\r\nchr &mdash; 返回一个字符的ASCII码<br />\r\nchunk_split &mdash; 按一定的字符长度将字符串分割成小块<br />\r\nconvert_cyr_string &mdash; 将斯拉夫语字符转换为别的字符<br />\r\nconvert_uudecode &mdash; 解密一个字符串<br />\r\nconvert_uuencode &mdash; 加密一个字符串<br />\r\ncount_chars &mdash; 返回一个字符串里面的字符使用信息<br />\r\ncrc32 &mdash; 计算一个字符串的crc32多项式<br />\r\ncrypt &mdash; 单向散列加密函数<br />\r\necho &mdash; 用以显示一些内容<br />\r\nexplode &mdash; 将一个字符串用分割符转变为一数组形式<br />\r\nfprintf &mdash; 按照要求对数据进行返回，并直接写入文档流<br />\r\nget_html_translation_table &mdash; 返回可以转换的HTML实体<br />\r\nhebrev &mdash; 将Hebrew编码的字符串转换为可视的文本<br />\r\nhebrevc &mdash; 将Hebrew编码的字符串转换为可视的文本<br />\r\nhtml_entity_decode &mdash; htmlentities ()函数的反函数，将HTML实体转换为字符<br />\r\nhtmlentities &mdash; 将字符串中一些字符转换为HTML实体<br />\r\nhtmlspecialchars_decode &mdash;htmlspecialchars()函数的反函数，将HTML实体转换为字符<br />\r\nhtmlspecialchars &mdash; 将字符串中一些字符转换为HTML实体<br />\r\nimplode &mdash; 将数组用特定的分割符转变为字符串<br />\r\njoin &mdash; 将数组转变为字符串，implode()函数的别名<br />\r\nlevenshtein &mdash; 计算两个词的差别大小<br />\r\nlocaleconv &mdash; 获取数字相关的格式定义<br />\r\nltrim &mdash; 去除字符串左侧的空白或者指定的字符<br />\r\nmd5_file &mdash; 将一个文件进行MD5算法加密<br />\r\nmd5 &mdash; 将一个字符串进行MD5算法加密<br />\r\nmetaphone &mdash; 判断一个字符串的发音规则<br />\r\nmoney_format &mdash; 按照参数对数字进行格式化的输出<br />\r\nnl_langinfo &mdash; 查询语言和本地信息<br />\r\nnl2br &mdash; 将字符串中的换行符&ldquo;\\n&rdquo;替换成&ldquo;&lt;br/&gt;&rdquo;<br />\r\nnumber_format &mdash; 按照参数对数字进行格式化的输出<br />\r\nord &mdash; 将一个ASCII码转换为一个字符<br />\r\nparse_str &mdash; 把一定格式的字符串转变为变量和值<br />\r\nprint &mdash; 用以输出一个单独的值<br />\r\nprintf &mdash; 按照要求对数据进行显示<br />\r\nquoted_printable_decode &mdash; 将一个字符串加密为一个8位的二进制字符串<br />\r\nquotemeta &mdash; 对若干个特定字符进行转义<br />\r\nrtrim &mdash; 去除字符串右侧的空白或者指定的字符<br />\r\nsetlocale &mdash; 设置关于数字，日期等等的本地格式<br />\r\nsha1_file &mdash; 将一个文件进行SHA1算法加密<br />\r\nsha1 &mdash; 将一个字符串进行SHA1算法加密<br />\r\nsimilar_text &mdash; 比较两个字符串，返回系统认为的相似字符个数<br />\r\nsoundex &mdash; 判断一个字符串的发音规则<br />\r\nsprintf &mdash; 按照要求对数据进行返回，但是不输出<br />\r\nsscanf &mdash; 可以对字符串进行格式化<br />\r\nstr_ireplace &mdash; 像str_replace()函数一样匹配和替换字符串，但是不区分大小写<br />\r\nstr_pad &mdash; 对字符串进行两侧的补白<br />\r\nstr_repeat &mdash; 对字符串进行重复组合<br />\r\nstr_replace &mdash; 匹配和替换字符串<br />\r\nstr_rot13 &mdash; 将字符串进行ROT13加密处理<br />\r\nstr_shuffle &mdash; 对一个字符串里面的字符进行随机排序<br />\r\nstr_split &mdash; 将一个字符串按照字符间距分割为一个数组<br />\r\nstr_word_count &mdash; 获取字符串里面的英文单词信息<br />\r\nstrcasecmp &mdash; 对字符串进行大小比较，不区分大小写<br />\r\nstrchr &mdash; 通过比较返回一个字符串的部分strstr()函数的别名<br />\r\nstrcmp &mdash; 对字符串进行大小比较<br />\r\nstrcoll &ndash; 根据本地设置对字符串进行大小比较<br />\r\nstrcspn &mdash; 返回字符连续非匹配长度的值<br />\r\nstrip_tags &mdash; 去除一个字符串里面的HTML和PHP代码<br />\r\nstripcslashes &mdash; 反转义addcslashes()函数转义处理过的字符串<br />\r\nstripos &mdash; 查找并返回首个匹配项的位置，匹配不区分大小写<br />\r\nstripslashes &mdash; 反转义addslashes()函数转义处理过的字符串<br />\r\nstristr &mdash; 通过比较返回一个字符串的部分，比较时不区分大小写<br />\r\nstrlen &mdash; 获取一个字符串的编码长度<br />\r\nstrnatcasecmp &mdash; 使用自然排序法对字符串进行大小比较，不区分大小写<br />\r\nstrnatcmp &mdash; 使用自然排序法对字符串进行大小比较<br />\r\nstrncasecmp &mdash; 对字符串的前N个字符进行大小比较，不区分大小写<br />\r\nstrncmp &mdash; 对字符串的前N个字符进行大小比较<br />\r\nstrpbrk &mdash; 通过比较返回一个字符串的部分<br />\r\nstrpos &mdash; 查找并返回首个匹配项的位置<br />\r\nstrrchr &mdash; 通过从后往前比较返回一个字符串的部分<br />\r\nstrrev &mdash; 将字符串里面的所有字母反向排列<br />\r\nstrripos &mdash; 从后往前查找并返回首个匹配项的位置，匹配不区分大小写<br />\r\nstrrpos &ndash; 从后往前查找并返回首个匹配项的位置<br />\r\nstrspn &mdash; 匹配并返回字符连续出现长度的值<br />\r\nstrstr &mdash; 通过比较返回一个字符串的部分<br />\r\nstrtok &mdash; 用指定的若干个字符来分割字符串<br />\r\nstrtolower &mdash; 将字符串转变为小写<br />\r\nstrtoupper &ndash;将字符串转变为大写<br />\r\nstrtr &mdash; 对字符串比较替换<br />\r\nsubstr_compare &mdash; 对字符串进行截取后的比较<br />\r\nsubstr_count &mdash; 计算字符串中某字符段的出现次数<br />\r\nsubstr_replace &mdash; 对字符串中的部分字符进行替换<br />\r\nsubstr &mdash; 对字符串进行截取<br />\r\ntrim &mdash; 去除字符串两边的空白或者指定的字符<br />\r\nucfirst &mdash; 将所给字符串的第一个字母转换为大写<br />\r\nucwords &mdash; 将所给字符串的每一个英文单词的第一个字母变成大写<br />\r\nvfprintf &mdash; 按照要求对数据进行返回，并直接写入文档流<br />\r\nvprintf &mdash; 按照要求对数据进行显示<br />\r\nvsprintf &mdash; 按照要求对数据进行返回，但是不输出<br />\r\nwordwrap &mdash; 按照一定的字符长度分割字符串</p>\r\n', '', NULL, 0, 1),
(103, 4, 102, 'PHP字符串操作常用函数', '<p>&nbsp;&nbsp;&nbsp; /*</p>\r\n\r\n<p>&nbsp;&nbsp; &nbsp;* 确定字符串长度</p>\r\n\r\n<p>&nbsp;&nbsp; &nbsp;* int strlen(string str)</p>\r\n\r\n<p>&nbsp;&nbsp; &nbsp;* 比较两个字符串</p>\r\n\r\n<p>&nbsp;&nbsp; &nbsp;* 1、strcmp函数对两个字符串进行二进制安全的比较，并区分大小写</p>\r\n\r\n<p>&nbsp;&nbsp; &nbsp;* int strcmp(string str1,string str2)</p>\r\n\r\n<p>&nbsp;&nbsp; &nbsp;* 2、以不区分大小写的方式比较两个字符串</p>\r\n\r\n<p>&nbsp;&nbsp; &nbsp;* int strcasecmp(string str1,string str2)</p>\r\n\r\n<p>&nbsp;&nbsp; &nbsp;* 3、求两个字符串相同部分</p>\r\n\r\n<p>&nbsp;&nbsp; &nbsp;* int strspn(string str1,string str2)</p>\r\n\r\n<p>&nbsp;&nbsp; &nbsp;* 4、求两个字符串的不同部分</p>\r\n\r\n<p>&nbsp;&nbsp; &nbsp;* int strcspn(string str1,string str2)</p>\r\n\r\n<p>&nbsp;&nbsp; &nbsp;* 处理字符串大小写</p>\r\n\r\n<p>&nbsp;&nbsp; &nbsp;* 1、将字符串全部转换为小写</p>\r\n\r\n<p>&nbsp;&nbsp; &nbsp;* string strtolower(string str)</p>\r\n\r\n<p>&nbsp;&nbsp; &nbsp;* 2、将字符串全部转化为大写</p>\r\n\r\n<p>&nbsp;&nbsp; &nbsp;* string strtoupper(string str)</p>\r\n\r\n<p>&nbsp;&nbsp; &nbsp;* 3、将字符串第一个字符大写</p>\r\n\r\n<p>&nbsp;&nbsp; &nbsp;* string ucfirst(string str)</p>\r\n\r\n<p>&nbsp;&nbsp; &nbsp;* 4、将字符串中的每个单词变成大写</p>\r\n\r\n<p>&nbsp;&nbsp; &nbsp;* string ucword(string str)</p>\r\n\r\n<p>&nbsp;&nbsp; &nbsp;* 字符串与HTML相互转换</p>\r\n\r\n<p>&nbsp;&nbsp; &nbsp;* 1、将换行符转换为HTML终止标记</p>\r\n\r\n<p>&nbsp;&nbsp; &nbsp;* string bl2br(string str)</p>\r\n\r\n<p>&nbsp;&nbsp; &nbsp;* 2、将特殊字符转换wieldHTML等价形式</p>\r\n\r\n<p>&nbsp;&nbsp; &nbsp;* string htmlentities(string str[,int quote_style[,int charset]])</p>\r\n\r\n<p>&nbsp;&nbsp; &nbsp;* 3、使用特殊的HTML字符用于其他目的</p>\r\n\r\n<p>&nbsp;&nbsp; &nbsp;* string htmlspecialchars(string str[,int quote_style[,string charset]])</p>\r\n\r\n<p>&nbsp;&nbsp; &nbsp;* 4、将文本转换为HTML等价形式</p>\r\n\r\n<p>&nbsp;&nbsp; &nbsp;* array get_html_translaction_table(int table[,int quote_style])</p>\r\n\r\n<p>&nbsp;&nbsp; &nbsp;* 5、创建一个自定义的转换清单</p>\r\n\r\n<p>&nbsp;&nbsp; &nbsp;* string strtr(string str,array replacements)</p>\r\n\r\n<p>&nbsp;&nbsp; &nbsp;* 6、将HTML转换为纯文本</p>\r\n\r\n<p>&nbsp;&nbsp; &nbsp;* string strip_tags(string str[,string allowable_tags])</p>\r\n\r\n<p>&nbsp;&nbsp; &nbsp;* 正则表达式函数的替代函数</p>\r\n\r\n<p>&nbsp;&nbsp; &nbsp;* 1、strtok函数根据预定义的字符串列表来解析字符串</p>\r\n\r\n<p>&nbsp;&nbsp; &nbsp;* string strtok(string str,string tonens)</p>\r\n\r\n<p>&nbsp;&nbsp; &nbsp;* 2、根据预定义的定界符分析字符串</p>\r\n\r\n<p>&nbsp;&nbsp; &nbsp;* array explode(string separator,string str[,int limit])</p>\r\n\r\n<p>&nbsp;&nbsp; &nbsp;* 3、将数组转换为字符串</p>\r\n\r\n<p>&nbsp;&nbsp; &nbsp;* string implode(string delimiter, array array)</p>\r\n\r\n<p>&nbsp;&nbsp; &nbsp;* 4、解析复杂的字符串</p>\r\n\r\n<p>&nbsp;&nbsp; &nbsp;* int strpos(string str,string substr[,int offset])</p>\r\n\r\n<p>&nbsp;&nbsp; &nbsp;* 5、找到字符串的最后一次出现</p>\r\n\r\n<p>&nbsp;&nbsp; &nbsp;* int strrpos(string str,char substr[,offset])</p>\r\n\r\n<p>&nbsp;&nbsp; &nbsp;* 6、用另外一个字符串替代字符串的所有实例</p>\r\n\r\n<p>&nbsp;&nbsp; &nbsp;* mixed str_replace(string occurrence,mixed replacement,mixed str[,int count])</p>\r\n\r\n<p>&nbsp;&nbsp; &nbsp;* 7、获取字符串的一部分strstr返回字符串中预定义字符串第一次出现开始的剩余部分</p>\r\n\r\n<p>&nbsp;&nbsp; &nbsp;* string strstr(string str,string occurrence)</p>\r\n\r\n<p>&nbsp;&nbsp; &nbsp;* 8、根据预定义的偏移返回字符串一部分</p>\r\n\r\n<p>&nbsp;&nbsp; &nbsp;* string substr(string str,int start[,ing length])</p>\r\n\r\n<p>&nbsp;&nbsp; &nbsp;* 9、确定字符串出现的频率</p>\r\n\r\n<p>&nbsp;&nbsp; &nbsp;* int substr_count(string str,string substring)</p>\r\n\r\n<p>&nbsp;&nbsp; &nbsp;* 10、用另一个字符串替换一个字符串的一部分</p>\r\n\r\n<p>&nbsp;&nbsp; &nbsp;* string substr_replace(string str,string replacement,int start[,int length])</p>\r\n\r\n<p>&nbsp;&nbsp; &nbsp;* 填充和剔除字符串</p>\r\n\r\n<p>&nbsp;&nbsp; &nbsp;* 1、从字符串开始出裁剪字符</p>\r\n\r\n<p>&nbsp;&nbsp; &nbsp;* string ltrim(string str[,string charliset])</p>\r\n\r\n<p>&nbsp;&nbsp; &nbsp;* 2、从字符串结尾裁剪字符</p>\r\n\r\n<p>&nbsp;&nbsp; &nbsp;* string rtrim(string str[,string charliset])</p>\r\n\r\n<p>&nbsp;&nbsp; &nbsp;* 3、从字符串两端裁剪字符</p>\r\n\r\n<p>&nbsp;&nbsp; &nbsp;* string trim(string str[,string charliset])</p>\r\n\r\n<p>&nbsp;&nbsp; &nbsp;* 4、填充字符串</p>\r\n\r\n<p>&nbsp;&nbsp; &nbsp;* string str_pad(string str,int length[,string pad_string[,int pad_type]])</p>\r\n\r\n<p>&nbsp;&nbsp; &nbsp;* 字符和单词计数</p>\r\n\r\n<p>&nbsp;&nbsp; &nbsp;* 1、字符串中字符计数</p>\r\n\r\n<p>&nbsp;&nbsp; &nbsp;* mixed count_chars(string str[,mode])</p>\r\n\r\n<p>&nbsp;&nbsp; &nbsp;* 2、字符串中单词总数计数</p>\r\n\r\n<p>&nbsp;&nbsp; &nbsp;* mixed str_word_count(string str[,int format])</p>\r\n\r\n<p>&nbsp;&nbsp; &nbsp;*/</p>\r\n', '', NULL, 0, 1),
(104, 4, 102, '字符串函数', '<ul>\r\n	<li><a href="http://php.net/manual/zh/function.addcslashes.php">addcslashes</a> &mdash; 以 C 语言风格使用反斜线转义字符串中的字符</li>\r\n	<li><a href="http://php.net/manual/zh/function.addslashes.php">addslashes</a> &mdash; 使用反斜线引用字符串</li>\r\n	<li><a href="http://php.net/manual/zh/function.bin2hex.php">bin2hex</a> &mdash; 函数把ASCII字符的字符串转换为十六进制值</li>\r\n	<li><a href="http://php.net/manual/zh/function.chop.php">chop</a> &mdash; rtrim 的别名</li>\r\n	<li><a href="http://php.net/manual/zh/function.chr.php">chr</a> &mdash; 返回指定的字符</li>\r\n	<li><a href="http://php.net/manual/zh/function.chunk-split.php">chunk_split</a> &mdash; 将字符串分割成小块</li>\r\n	<li><a href="http://php.net/manual/zh/function.convert-cyr-string.php">convert_cyr_string</a> &mdash; 将字符由一种 Cyrillic 字符转换成另一种</li>\r\n	<li><a href="http://php.net/manual/zh/function.convert-uudecode.php">convert_uudecode</a> &mdash; 解码一个 uuencode 编码的字符串</li>\r\n	<li><a href="http://php.net/manual/zh/function.convert-uuencode.php">convert_uuencode</a> &mdash; 使用 uuencode 编码一个字符串</li>\r\n	<li><a href="http://php.net/manual/zh/function.count-chars.php">count_chars</a> &mdash; 返回字符串所用字符的信息</li>\r\n	<li><a href="http://php.net/manual/zh/function.crc32.php">crc32</a> &mdash; 计算一个字符串的 crc32 多项式</li>\r\n	<li><a href="http://php.net/manual/zh/function.crypt.php">crypt</a> &mdash; 单向字符串散列</li>\r\n	<li><a href="http://php.net/manual/zh/function.echo.php">echo</a> &mdash; 输出一个或多个字符串</li>\r\n	<li><a href="http://php.net/manual/zh/function.explode.php">explode</a> &mdash; 使用一个字符串分割另一个字符串</li>\r\n	<li><a href="http://php.net/manual/zh/function.fprintf.php">fprintf</a> &mdash; 将格式化后的字符串写入到流</li>\r\n	<li><a href="http://php.net/manual/zh/function.get-html-translation-table.php">get_html_translation_table</a> &mdash; 返回使用 htmlspecialchars 和 htmlentities 后的转换表</li>\r\n	<li><a href="http://php.net/manual/zh/function.hebrev.php">hebrev</a> &mdash; 将逻辑顺序希伯来文（logical-Hebrew）转换为视觉顺序希伯来文（visual-Hebrew）</li>\r\n	<li><a href="http://php.net/manual/zh/function.hebrevc.php">hebrevc</a> &mdash; 将逻辑顺序希伯来文（logical-Hebrew）转换为视觉顺序希伯来文（visual-Hebrew），并且转换换行符</li>\r\n	<li><a href="http://php.net/manual/zh/function.hex2bin.php">hex2bin</a> &mdash; 转换十六进制字符串为二进制字符串</li>\r\n	<li><a href="http://php.net/manual/zh/function.html-entity-decode.php">html_entity_decode</a> &mdash; Convert all HTML entities to their applicable characters</li>\r\n	<li><a href="http://php.net/manual/zh/function.htmlentities.php">htmlentities</a> &mdash; Convert all applicable characters to HTML entities</li>\r\n	<li><a href="http://php.net/manual/zh/function.htmlspecialchars-decode.php">htmlspecialchars_decode</a> &mdash; 将特殊的 HTML 实体转换回普通字符</li>\r\n	<li><a href="http://php.net/manual/zh/function.htmlspecialchars.php">htmlspecialchars</a> &mdash; Convert special characters to HTML entities</li>\r\n	<li><a href="http://php.net/manual/zh/function.implode.php">implode</a> &mdash; 将一个一维数组的值转化为字符串</li>\r\n	<li><a href="http://php.net/manual/zh/function.join.php">join</a> &mdash; 别名 implode</li>\r\n	<li><a href="http://php.net/manual/zh/function.lcfirst.php">lcfirst</a> &mdash; 使一个字符串的第一个字符小写</li>\r\n	<li><a href="http://php.net/manual/zh/function.levenshtein.php">levenshtein</a> &mdash; 计算两个字符串之间的编辑距离</li>\r\n	<li><a href="http://php.net/manual/zh/function.localeconv.php">localeconv</a> &mdash; Get numeric formatting information</li>\r\n	<li><a href="http://php.net/manual/zh/function.ltrim.php">ltrim</a> &mdash; 删除字符串开头的空白字符（或其他字符）</li>\r\n	<li><a href="http://php.net/manual/zh/function.md5-file.php">md5_file</a> &mdash; 计算指定文件的 MD5 散列值</li>\r\n	<li><a href="http://php.net/manual/zh/function.md5.php">md5</a> &mdash; 计算字符串的 MD5 散列值</li>\r\n	<li><a href="http://php.net/manual/zh/function.metaphone.php">metaphone</a> &mdash; Calculate the metaphone key of a string</li>\r\n	<li><a href="http://php.net/manual/zh/function.money-format.php">money_format</a> &mdash; Formats a number as a currency string</li>\r\n	<li><a href="http://php.net/manual/zh/function.nl-langinfo.php">nl_langinfo</a> &mdash; Query language and locale information</li>\r\n	<li><a href="http://php.net/manual/zh/function.nl2br.php">nl2br</a> &mdash; 在字符串所有新行之前插入 HTML 换行标记</li>\r\n	<li><a href="http://php.net/manual/zh/function.number-format.php">number_format</a> &mdash; 以千位分隔符方式格式化一个数字</li>\r\n	<li><a href="http://php.net/manual/zh/function.ord.php">ord</a> &mdash; 返回字符的 ASCII 码值</li>\r\n	<li><a href="http://php.net/manual/zh/function.parse-str.php">parse_str</a> &mdash; 将字符串解析成多个变量</li>\r\n	<li><a href="http://php.net/manual/zh/function.print.php">print</a> &mdash; 输出字符串</li>\r\n	<li><a href="http://php.net/manual/zh/function.printf.php">printf</a> &mdash; 输出格式化字符串</li>\r\n	<li><a href="http://php.net/manual/zh/function.quoted-printable-decode.php">quoted_printable_decode</a> &mdash; 将 quoted-printable 字符串转换为 8-bit 字符串</li>\r\n	<li><a href="http://php.net/manual/zh/function.quoted-printable-encode.php">quoted_printable_encode</a> &mdash; 将 8-bit 字符串转换成 quoted-printable 字符串</li>\r\n	<li><a href="http://php.net/manual/zh/function.quotemeta.php">quotemeta</a> &mdash; 转义元字符集</li>\r\n	<li><a href="http://php.net/manual/zh/function.rtrim.php">rtrim</a> &mdash; 删除字符串末端的空白字符（或者其他字符）</li>\r\n	<li><a href="http://php.net/manual/zh/function.setlocale.php">setlocale</a> &mdash; 设置地区信息</li>\r\n	<li><a href="http://php.net/manual/zh/function.sha1-file.php">sha1_file</a> &mdash; 计算文件的 sha1 散列值</li>\r\n	<li><a href="http://php.net/manual/zh/function.sha1.php">sha1</a> &mdash; 计算字符串的 sha1 散列值</li>\r\n	<li><a href="http://php.net/manual/zh/function.similar-text.php">similar_text</a> &mdash; 计算两个字符串的相似度</li>\r\n	<li><a href="http://php.net/manual/zh/function.soundex.php">soundex</a> &mdash; Calculate the soundex key of a string</li>\r\n	<li><a href="http://php.net/manual/zh/function.sprintf.php">sprintf</a> &mdash; Return a formatted string</li>\r\n	<li><a href="http://php.net/manual/zh/function.sscanf.php">sscanf</a> &mdash; 根据指定格式解析输入的字符</li>\r\n	<li><a href="http://php.net/manual/zh/function.str-getcsv.php">str_getcsv</a> &mdash; 解析 CSV 字符串为一个数组</li>\r\n	<li><a href="http://php.net/manual/zh/function.str-ireplace.php">str_ireplace</a> &mdash; str_replace 的忽略大小写版本</li>\r\n	<li><a href="http://php.net/manual/zh/function.str-pad.php">str_pad</a> &mdash; 使用另一个字符串填充字符串为指定长度</li>\r\n	<li><a href="http://php.net/manual/zh/function.str-repeat.php">str_repeat</a> &mdash; 重复一个字符串</li>\r\n	<li><a href="http://php.net/manual/zh/function.str-replace.php">str_replace</a> &mdash; 子字符串替换</li>\r\n	<li><a href="http://php.net/manual/zh/function.str-rot13.php">str_rot13</a> &mdash; 对字符串执行 ROT13 转换</li>\r\n	<li><a href="http://php.net/manual/zh/function.str-shuffle.php">str_shuffle</a> &mdash; 随机打乱一个字符串</li>\r\n	<li><a href="http://php.net/manual/zh/function.str-split.php">str_split</a> &mdash; 将字符串转换为数组</li>\r\n	<li><a href="http://php.net/manual/zh/function.str-word-count.php">str_word_count</a> &mdash; 返回字符串中单词的使用情况</li>\r\n	<li><a href="http://php.net/manual/zh/function.strcasecmp.php">strcasecmp</a> &mdash; 二进制安全比较字符串（不区分大小写）</li>\r\n	<li><a href="http://php.net/manual/zh/function.strchr.php">strchr</a> &mdash; 别名 strstr</li>\r\n	<li><a href="http://php.net/manual/zh/function.strcmp.php">strcmp</a> &mdash; 二进制安全字符串比较</li>\r\n	<li><a href="http://php.net/manual/zh/function.strcoll.php">strcoll</a> &mdash; 基于区域设置的字符串比较</li>\r\n	<li><a href="http://php.net/manual/zh/function.strcspn.php">strcspn</a> &mdash; 获取不匹配遮罩的起始子字符串的长度</li>\r\n	<li><a href="http://php.net/manual/zh/function.strip-tags.php">strip_tags</a> &mdash; 从字符串中去除 HTML 和 PHP 标记</li>\r\n	<li><a href="http://php.net/manual/zh/function.stripcslashes.php">stripcslashes</a> &mdash; 反引用一个使用 addcslashes 转义的字符串</li>\r\n	<li><a href="http://php.net/manual/zh/function.stripos.php">stripos</a> &mdash; 查找字符串首次出现的位置（不区分大小写）</li>\r\n	<li><a href="http://php.net/manual/zh/function.stripslashes.php">stripslashes</a> &mdash; 反引用一个引用字符串</li>\r\n	<li><a href="http://php.net/manual/zh/function.stristr.php">stristr</a> &mdash; strstr 函数的忽略大小写版本</li>\r\n	<li><a href="http://php.net/manual/zh/function.strlen.php">strlen</a> &mdash; 获取字符串长度</li>\r\n	<li><a href="http://php.net/manual/zh/function.strnatcasecmp.php">strnatcasecmp</a> &mdash; 使用&ldquo;自然顺序&rdquo;算法比较字符串（不区分大小写）</li>\r\n	<li><a href="http://php.net/manual/zh/function.strnatcmp.php">strnatcmp</a> &mdash; 使用自然排序算法比较字符串</li>\r\n	<li><a href="http://php.net/manual/zh/function.strncasecmp.php">strncasecmp</a> &mdash; 二进制安全比较字符串开头的若干个字符（不区分大小写）</li>\r\n	<li><a href="http://php.net/manual/zh/function.strncmp.php">strncmp</a> &mdash; 二进制安全比较字符串开头的若干个字符</li>\r\n	<li><a href="http://php.net/manual/zh/function.strpbrk.php">strpbrk</a> &mdash; 在字符串中查找一组字符的任何一个字符</li>\r\n	<li><a href="http://php.net/manual/zh/function.strpos.php">strpos</a> &mdash; 查找字符串首次出现的位置</li>\r\n	<li><a href="http://php.net/manual/zh/function.strrchr.php">strrchr</a> &mdash; 查找指定字符在字符串中的最后一次出现</li>\r\n	<li><a href="http://php.net/manual/zh/function.strrev.php">strrev</a> &mdash; 反转字符串</li>\r\n	<li><a href="http://php.net/manual/zh/function.strripos.php">strripos</a> &mdash; 计算指定字符串在目标字符串中最后一次出现的位置（不区分大小写）</li>\r\n	<li><a href="http://php.net/manual/zh/function.strrpos.php">strrpos</a> &mdash; 计算指定字符串在目标字符串中最后一次出现的位置</li>\r\n	<li><a href="http://php.net/manual/zh/function.strspn.php">strspn</a> &mdash; 计算字符串中全部字符都存在于指定字符集合中的第一段子串的长度。</li>\r\n	<li><a href="http://php.net/manual/zh/function.strstr.php">strstr</a> &mdash; 查找字符串的首次出现</li>\r\n	<li><a href="http://php.net/manual/zh/function.strtok.php">strtok</a> &mdash; 标记分割字符串</li>\r\n	<li><a href="http://php.net/manual/zh/function.strtolower.php">strtolower</a> &mdash; 将字符串转化为小写</li>\r\n	<li><a href="http://php.net/manual/zh/function.strtoupper.php">strtoupper</a> &mdash; 将字符串转化为大写</li>\r\n	<li><a href="http://php.net/manual/zh/function.strtr.php">strtr</a> &mdash; 转换指定字符</li>\r\n	<li><a href="http://php.net/manual/zh/function.substr-compare.php">substr_compare</a> &mdash; 二进制安全比较字符串（从偏移位置比较指定长度）</li>\r\n	<li><a href="http://php.net/manual/zh/function.substr-count.php">substr_count</a> &mdash; 计算字串出现的次数</li>\r\n	<li><a href="http://php.net/manual/zh/function.substr-replace.php">substr_replace</a> &mdash; 替换字符串的子串</li>\r\n	<li><a href="http://php.net/manual/zh/function.substr.php">substr</a> &mdash; 返回字符串的子串</li>\r\n	<li><a href="http://php.net/manual/zh/function.trim.php">trim</a> &mdash; 去除字符串首尾处的空白字符（或者其他字符）</li>\r\n	<li><a href="http://php.net/manual/zh/function.ucfirst.php">ucfirst</a> &mdash; 将字符串的首字母转换为大写</li>\r\n	<li><a href="http://php.net/manual/zh/function.ucwords.php">ucwords</a> &mdash; 将字符串中每个单词的首字母转换为大写</li>\r\n	<li><a href="http://php.net/manual/zh/function.vfprintf.php">vfprintf</a> &mdash; 将格式化字符串写入流</li>\r\n	<li><a href="http://php.net/manual/zh/function.vprintf.php">vprintf</a> &mdash; 输出格式化字符串</li>\r\n	<li><a href="http://php.net/manual/zh/function.vsprintf.php">vsprintf</a> &mdash; 返回格式化字符串</li>\r\n	<li><a href="http://php.net/manual/zh/function.wordwrap.php">wordwrap</a> &mdash; 打断字符串为指定数量的字串</li>\r\n</ul>\r\n', '', NULL, 0, 1),
(105, 4, 0, 'PHP5各个版本', '<p>PHP5.2 以前：autoload, PDO 和 MySQLi, 类型约束<br />\r\nPHP5.2：JSON 支持<br />\r\nPHP5.3：弃用的功能，匿名函数，新增魔术方法，命名空间，后期静态绑定，Heredoc 和 Nowdoc, const, 三元运算符，Phar<br />\r\nPHP5.4：Short Open Tag, 数组简写形式，Traits, 内置 Web 服务器，细节修改<br />\r\nPHP5.5：yield, list() 用于 foreach, 细节修改<br />\r\nPHP5.6: 常量增强，可变函数参数，命名空间增强</p>\r\n\r\n<ul>\r\n	<li><strong>PHP5.2以前(2006前)</strong></li>\r\n	<li><strong>PHP5.2(2006-2011)</strong></li>\r\n	<li><strong>PHP5.3(2009-2012)</strong></li>\r\n	<li><strong>PHP5.4(2012-2013)</strong></li>\r\n	<li><strong>PHP5.5(2013起)</strong></li>\r\n	<li><strong>PHP5.6</strong></li>\r\n</ul>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;</p>\r\n', '', NULL, 0, 1),
(106, 4, 105, 'PHP5.2以前(2006前)', '<p>PHP5.2 已经出现但值得介绍的特征。</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<ul>\r\n	<li>autoload</li>\r\n	<li>PDO 和 MySQLi</li>\r\n</ul>\r\n', '##autoload\r\n\r\n大家可能都知道 __autoload() 函数，如果定义了该函数，那么当在代码中使用一个未定义的类的时候，该函数就会被调用，你可以在该函数中加载相应的类实现文件，如：\r\n\r\n	function __autoload($classname)\r\n	{\r\n	    require_once("{$classname}.php")\r\n	}\r\n    \r\n    \r\n但该函数已经不被建议使用，原因是一个项目中仅能有一个这样的 __autoload() 函数，因为 PHP 不允许函数重名。但当你使用一些类库的时候，难免会出现多个 autoload 函数的需要，于是 spl_autoload_register() 取而代之：    \r\n    \r\n    \r\n    spl_autoload_register(function($classname)\r\n	{\r\n	    require_once("{$classname}.php")\r\n	});\r\n    \r\nspl_autoload_register() 会将一个函数注册到 autoload 函数列表中，当出现未定义的类的时候，SPL [注] 会按照注册的倒序逐个调用被注册的 autoload 函数，这意味着你可以使用 spl_autoload_register() 注册多个 autoload 函数.\r\n注：SPL: Standard PHP Library, 标准 PHP 库, 被设计用来解决一些经典问题(如数据结构).    \r\n    \r\n    \r\n##PDO 和 MySQLi    \r\n\r\n即 PHP Data Object, PHP 数据对象，这是 PHP 的新式数据库访问接口。\r\n按照传统的风格，访问 MySQL 数据库应该是这样子：\r\n\r\n\r\n	// 连接到服务器，选择数据库\r\n	$conn = mysql_connect("localhost", "user", "password");\r\n	mysql_select_db("database");\r\n\r\n	// 执行 SQL 查询\r\n	$type = $_POST[''type''];\r\n	$sql = "SELECT * FROM `table` WHERE `type` = {$type}";\r\n	$result = mysql_query($sql);\r\n\r\n	// 打印结果\r\n	while($row = mysql_fetch_array($result, MYSQL_ASSOC))\r\n	{\r\n	    foreach($row as $k => $v)\r\n		print "{$k}: {$v}\\n";\r\n	}\r\n\r\n	// 释放结果集，关闭连接\r\n	mysql_free_result($result);\r\n	mysql_close($conn);\r\n    \r\n    \r\n为了能够让代码实现数据库无关，即一段代码同时适用于多种数据库(例如以上代码仅仅适用于MySQL)，PHP 官方设计了 PDO.\r\n除此之外，PDO 还提供了更多功能，比如：\r\n\r\n1.面向对象风格的接口\r\n2.SQL预编译(prepare), 占位符语法\r\n3.更高的执行效率，作为官方推荐，有特别的性能优化\r\n4.支持大部分SQL数据库，更换数据库无需改动代码\r\n\r\n上面的代码用 PDO 实现将会是这样：\r\n    \r\n    \r\n	// 连接到数据库\r\n	$conn = new PDO("mysql:host=localhost;dbname=database", "user", "password");\r\n\r\n	// 预编译SQL, 绑定参数\r\n	$query = $conn->prepare("SELECT * FROM `table` WHERE `type` = :type");\r\n	$query->bindParam("type", $_POST[''type'']);\r\n\r\n	// 执行查询并打印结果\r\n	foreach($query->execute() as $row)\r\n	{\r\n	    foreach($row as $k => $v)\r\n		print "{$k}: {$v}\\n";\r\n	}    \r\n    \r\n    \r\nPDO 是官方推荐的，更为通用的数据库访问方式，如果你没有特殊需求，那么你最好学习和使用 PDO.\r\n但如果你需要使用 MySQL 所特有的高级功能，那么你可能需要尝试一下 MySQLi, 因为 PDO 为了能够同时在多种数据库上使用，不会包含那些 MySQL 独有的功能。\r\n\r\nMySQLi 是 MySQL 的增强接口，同时提供面向过程和面向对象接口，也是目前推荐的 MySQL 驱动，旧的C风格 MySQL 接口将会在今后被默认关闭。\r\nMySQLi 的用法和以上两段代码相比，没有太多新概念，在此不再给出示例，可以参见 PHP 官网文档 [注]。\r\n\r\n注：http://www.php.net/manual/en/mysqli.quickstart.php\r\n\r\n类型约束\r\n通过类型约束可以限制参数的类型，不过这一机制并不完善，目前仅适用于类和 callable(可执行类型) 以及 array(数组), 不适用于 string 和 int.    \r\n    \r\n    \r\n	// 限制第一个参数为 MyClass, 第二个参数为可执行类型，第三个参数为数组\r\n	function MyFunction(MyClass $a, callable $b, array $c)\r\n	{\r\n	    // ...\r\n	}    \r\n    \r\n    \r\n    \r\n\r\n\r\n', NULL, 0, 1),
(107, 4, 105, 'PHP5.2(2006-2011)', '<p><strong>JSON 支持</strong></p>\r\n\r\n<p>包括 json_encode(), json_decode() 等函数，JSON 算是在 Web 领域非常常用的数据交换格式，可以被 JS 直接支持，JSON 实际上是 JS 语法的一部分。</p>\r\n', 'JSON 系列函数，可以将 PHP 中的数组结构与 JSON 字符串进行转换：\r\n\r\n	$array = ["key" => "value", "array" => [1, 2, 3, 4]];\r\n	$json = json_encode($array);\r\n	echo "{$json}\\n";\r\n\r\n	$object = json_decode($json);\r\n	print_r($object);\r\n    \r\n    \r\n输出：\r\n\r\n	{"key":"value","array":[1,2,3,4]}\r\n	stdClass Object\r\n	(\r\n	    [key] => value\r\n	    [array] => Array\r\n		(\r\n		    [0] => 1\r\n		    [1] => 2\r\n		    [2] => 3\r\n		    [3] => 4\r\n		)\r\n	)\r\n    \r\n    \r\n值得注意的是 json_decode() 默认会返回一个对象而非数组，如果需要返回数组需要将第二个参数设置为 true.    \r\n    ', NULL, 0, 1),
(108, 4, 105, 'PHP5.3 - 删除', '<p>PHP5.3 算是一个非常大的更新，新增了大量新特征，同时也做了一些不向下兼容的修改。<br />\r\n【PHP5.3弃用的功能】：以下几个功能被弃用，若在配置文件中启用，则 PHP 会在运行时发出警告。</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><s><strong>Register Globals</strong></s></p>\r\n\r\n<p><s><strong>Magic Quotes</strong></s></p>\r\n\r\n<p><s><strong>Safe Mode</strong></s></p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;</p>\r\n', 'PHP5.3 算是一个非常大的更新，新增了大量新特征，同时也做了一些不向下兼容的修改。\r\n【PHP5.3弃用的功能】：以下几个功能被弃用，若在配置文件中启用，则 PHP 会在运行时发出警告。\r\n\r\n##Register Globals\r\n\r\n这是 php.ini 中的一个选项(register_globals), 开启后会将所有表单变量($_GET和$_POST)注册为全局变量.\r\n看下面的例子：\r\n复制代码 代码如下:\r\n\r\n	if(isAuth())\r\n	    $authorized = true;\r\n	if($authorized)\r\n	    include("page.php");\r\n        \r\n这段代码在通过验证时，将 $authorized 设置为 true. 然后根据 $authorized 的值来决定是否显示页面.\r\n但由于并没有事先把 $authorized 初始化为 false, 当 register_globals 打开时，可能访问 /auth.php?authorized=1 来定义该变量值，绕过身份验证。\r\n该特征属于历史遗留问题，在 PHP4.2 中被默认关闭，在 PHP5.4 中被移除。\r\n\r\n##Magic Quotes\r\n\r\n对应 php.ini 中的选项 magic_quotes_gpc, 这个特征同样属于历史遗留问题，已经在 PHP5.4 中移除。\r\n该特征会将所有用户输入进行转义，这看上去不错，在第一章我们提到过要对用户输入进行转义。\r\n但是 PHP 并不知道哪些输入会进入 SQL , 哪些输入会进入 Shell, 哪些输入会被显示为 HTML, 所以很多时候这种转义会引起混乱。\r\n\r\n##Safe Mode\r\n很多虚拟主机提供商使用 Safe Mode 来隔离多个用户，但 Safe Mode 存在诸多问题，例如某些扩展并不按照 Safe Mode 来进行权限控制。\r\nPHP官方推荐使用操作系统的机制来进行权限隔离，让Web服务器以不同的用户权限来运行PHP解释器，请参见第一章中的最小权限原则.', NULL, 0, 1),
(109, 4, 105, 'PHP5.3 - 新增、改进', '<ul>\r\n	<li><strong>匿名函数</strong></li>\r\n	<li><strong>魔术方法：__invoke(), __callStatic()</strong></li>\r\n	<li><strong>命名空间</strong></li>\r\n	<li><strong>后期静态绑定</strong></li>\r\n	<li><strong>Heredoc 和 Nowdoc</strong></li>\r\n	<li><strong>用 const 定义常量</strong></li>\r\n	<li><strong>三元运算符简写形式</strong></li>\r\n	<li><strong>Phar</strong></li>\r\n</ul>\r\n', '##匿名函数\r\n\r\n也叫闭包(Closures), 经常被用来临时性地创建一个无名函数，用于回调函数等用途。\r\n复制代码 代码如下:\r\n\r\n	$func = function($arg)\r\n	{\r\n	    print $arg;\r\n	};\r\n\r\n	$func("Hello World");\r\n\r\n以上代码定义了一个匿名函数，并赋值给了 $func.\r\n可以看到定义匿名函数依旧使用 function 关键字，只不过省略了函数名，直接是参数列表。\r\n然后我们又调用了 $func 所储存的匿名函数。\r\n匿名函数还可以用 use 关键字来捕捉外部变量：\r\n复制代码 代码如下:\r\n\r\n	function arrayPlus($array, $num)\r\n	{\r\n	    array_walk($array, function(&$v) use($num){\r\n		$v += $num;\r\n	    });\r\n	}\r\n\r\n上面的代码定义了一个 arrayPlus() 函数(这不是匿名函数), 它会将一个数组($array)中的每一项，加上一个指定的数字($num).\r\n在 arrayPlus() 的实现中，我们使用了 array_walk() 函数，它会为一个数组的每一项执行一个回调函数，即我们定义的匿名函数。\r\n在匿名函数的参数列表后，我们用 use 关键字将匿名函数外的 $num 捕捉到了函数内，以便知道到底应该加上多少。\r\n\r\n\r\n##魔术方法：__invoke(), __callStatic()\r\n\r\nPHP 的面向对象体系中，提供了若干“魔术方法”，用于实现类似其他语言中的“重载”，如在访问不存在的属性、方法时触发某个魔术方法。\r\n随着匿名函数的加入，PHP 引入了一个新的魔术方法 __invoke().\r\n该魔术方法会在将一个对象作为函数调用时被调用：\r\n复制代码 代码如下:\r\n\r\n	class A\r\n	{\r\n	    public function __invoke($str)\r\n	    {\r\n		print "A::__invoke(): {$str}";\r\n	    }\r\n	}\r\n\r\n	$a = new A;\r\n	$a("Hello World");\r\n\r\n输出毫无疑问是：\r\n复制代码 代码如下:\r\n\r\n	A::__invoke(): Hello World\r\n\r\n__callStatic() 则会在调用一个不存在的静态方法时被调用。\r\n\r\n##命名空间\r\n\r\nPHP的命名空间有着前无古人后无来者的无比蛋疼的语法：\r\n复制代码 代码如下:\r\n\r\n	<?php\r\n	// 命名空间的分隔符是反斜杠，该声明语句必须在文件第一行。\r\n	// 命名空间中可以包含任意代码，但只有 **类, 函数, 常量** 受命名空间影响。\r\n	namespace XXOO\\Test;\r\n\r\n	// 该类的完整限定名是 \\XXOO\\Test\\A , 其中第一个反斜杠表示全局命名空间。\r\n	class A{}\r\n\r\n	// 你还可以在已经文件中定义第二个命名空间，接下来的代码将都位于 \\Other\\Test2 .\r\n	namespace Other\\Test2;\r\n\r\n	// 实例化来自其他命名空间的对象：\r\n	$a = new \\XXOO\\Test\\A;\r\n	class B{}\r\n\r\n	// 你还可以用花括号定义第三个命名空间\r\n	namespace Other {\r\n	    // 实例化来自子命名空间的对象：\r\n	    $b = new Test2\\B;\r\n\r\n	    // 导入来自其他命名空间的名称，并重命名，\r\n	    // 注意只能导入类，不能用于函数和常量。\r\n	    use \\XXOO\\Test\\A as ClassA\r\n	}\r\n\r\n更多有关命名空间的语法介绍请参见官网 [注].\r\n命名空间时常和 autoload 一同使用，用于自动加载类实现文件：\r\n\r\n\r\n	spl_autoload_register(\r\n	    function ($class) {\r\n		spl_autoload(str_replace("\\\\", "/", $class));\r\n	    }\r\n	);\r\n\r\n当你实例化一个类 \\XXOO\\Test\\A 的时候，这个类的完整限定名会被传递给 autoload 函数，autoload 函数将类名中的命名空间分隔符(反斜杠)替换为斜杠，并包含对应文件。\r\n这样可以实现类定义文件分级储存，按需自动加载。\r\n注：http://www.php.net/manual/zh/language.namespaces.php\r\n\r\n\r\n##后期静态绑定\r\n\r\nPHP 的 OPP 机制，具有继承和类似虚函数的功能，例如如下的代码：\r\n复制代码 代码如下:\r\n\r\n	class A\r\n	{\r\n	    public function callFuncXXOO()\r\n	    {\r\n		print $this->funcXXOO();\r\n	    }\r\n\r\n	    public function funcXXOO()\r\n	    {\r\n		return "A::funcXXOO()";\r\n	    }\r\n	}\r\n\r\n	class B extends A\r\n	{\r\n	    public function funcXXOO()\r\n	    {\r\n		return "B::funcXXOO";\r\n	    }\r\n	}\r\n\r\n	$b = new B;\r\n	$b->callFuncXXOO();\r\n\r\n输出是：\r\n复制代码 代码如下:\r\n\r\n	B::funcXXOO\r\n\r\n可以看到，当在 A 中使用 $this->funcXXOO() 时，体现了“虚函数”的机制，实际调用的是 B::funcXXOO().\r\n然而如果将所有函数都改为静态函数：\r\n复制代码 代码如下:\r\n\r\n	class A\r\n	{\r\n	    static public function callFuncXXOO()\r\n	    {\r\n		print self::funcXXOO();\r\n	    }\r\n\r\n	    static public function funcXXOO()\r\n	    {\r\n		return "A::funcXXOO()";\r\n	    }\r\n	}\r\n\r\n	class B extends A\r\n	{\r\n	    static public function funcXXOO()\r\n	    {\r\n		return "B::funcXXOO";\r\n	    }\r\n	}\r\n\r\n	$b = new B;\r\n	$b->callFuncXXOO();\r\n\r\n情况就没这么乐观了，输出是：\r\n复制代码 代码如下:\r\n\r\n	A::funcXXOO()\r\n\r\n这是因为 self 的语义本来就是“当前类”，所以 PHP5.3 给 static 关键字赋予了一个新功能：后期静态绑定：\r\n复制代码 代码如下:\r\n\r\n	class A\r\n	{\r\n	    static public function callFuncXXOO()\r\n	    {\r\n		print static::funcXXOO();\r\n	    }\r\n\r\n	    // ...\r\n	}\r\n\r\n	// ...\r\n\r\n这样就会像预期一样输出了：\r\n复制代码 代码如下:\r\n\r\n	B::funcXXOO\r\n\r\n\r\n##Heredoc 和 Nowdoc\r\n\r\nPHP5.3 对 Heredoc 以及 Nowdoc 进行了一些改进，它们都用于在 PHP 代码中嵌入大段字符串。\r\nHeredoc 的行为类似于一个双引号字符串：\r\n复制代码 代码如下:\r\n\r\n	$name = "MyName";\r\n	echo <<< TEXT\r\n	My name is "{$name}".\r\n	TEXT;\r\n\r\nHeredoc 以三个左尖括号开始，后面跟一个标识符(TEXT), 直到一个同样的顶格的标识符(不能缩进)结束。\r\n就像双引号字符串一样，其中可以嵌入变量。\r\n\r\nHeredoc 还可以用于函数参数，以及类成员初始化：\r\n复制代码 代码如下:\r\n\r\n	var_dump(<<<EOD\r\n	Hello World\r\n	EOD\r\n	);\r\n\r\n	class A\r\n	{\r\n	    const xx = <<< EOD\r\n	Hello World\r\n	EOD;\r\n\r\n	    public $oo = <<< EOD\r\n	Hello World\r\n	EOD;\r\n	}\r\n\r\nNowdoc 的行为像一个单引号字符串，不能在其中嵌入变量，和 Heredoc 唯一的区别就是，三个左尖括号后的标识符要以单引号括起来：\r\n复制代码 代码如下:\r\n\r\n	$name = "MyName";\r\n	echo <<< ''TEXT''\r\n	My name is "{$name}".\r\n	TEXT;\r\n\r\n输出：\r\n复制代码 代码如下:\r\n\r\n	My name is "{$name}".\r\n\r\n\r\n\r\n##用 const 定义常量\r\n\r\nPHP5.3 起同时支持在全局命名空间和类中使用 const 定义常量。\r\n旧式风格：\r\n复制代码 代码如下:\r\n\r\n	define("XOOO", "Value");\r\n\r\n新式风格：\r\n\r\n	const XXOO = "Value";\r\n\r\nconst 形式仅适用于常量，不适用于运行时才能求值的表达式：\r\n复制代码 代码如下:\r\n\r\n	// 正确\r\n	const XXOO = 1234;\r\n	// 错误\r\n	const XXOO = 2 * 617;\r\n\r\n\r\n##三元运算符简写形式\r\n\r\n旧式风格：\r\n复制代码 代码如下:\r\n\r\n	echo $a ? $a : "No Value";\r\n\r\n可简写成：\r\n复制代码 代码如下:\r\n\r\n	echo $a ?: "No Value";\r\n\r\n即如果省略三元运算符的第二个部分，会默认用第一个部分代替。\r\n\r\n\r\n##Phar\r\n\r\nPhar即PHP Archive, 起初只是Pear中的一个库而已，后来在PHP5.3被重新编写成C扩展并内置到 PHP 中。\r\nPhar用来将多个 .php 脚本打包(也可以打包其他文件)成一个 .phar 的压缩文件(通常是ZIP格式)。\r\n目的在于模仿 Java 的 .jar, 不对，目的是为了让发布PHP应用程序更加方便。同时还提供了数字签名验证等功能。\r\n.phar 文件可以像 .php 文件一样，被PHP引擎解释执行，同时你还可以写出这样的代码来包含(require) .phar 中的代码：\r\n复制代码 代码如下:\r\n\r\n	require("xxoo.phar");\r\n	require("phar://xxoo.phar/xo/ox.php");\r\n\r\n更多信息请参见官网 [注].\r\n注：http://www.php.net/manual/zh/phar.using.intro.php', NULL, 0, 1),
(110, 4, 105, 'PHP5.4', '<ul>\r\n	<li><strong>Short Open Tag</strong></li>\r\n	<li><strong>数组简写形式</strong></li>\r\n	<li><strong>Traits</strong></li>\r\n	<li><strong>内置 Web 服务器</strong></li>\r\n	<li><strong>细节修改</strong></li>\r\n</ul>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>&nbsp;</p>\r\n', '##Short Open Tag\r\n\r\nShort Open Tag 自 PHP5.4 起总是可用。\r\n在这里集中讲一下有关 PHP 起止标签的问题。即：\r\n复制代码 代码如下:\r\n\r\n	<?php\r\n	// Code...\r\n	?>\r\n\r\n通常就是上面的形式，除此之外还有一种简写形式：\r\n复制代码 代码如下:\r\n\r\n	<? /* Code... */ ?>\r\n\r\n还可以把\r\n复制代码 代码如下:\r\n\r\n	<?php echo $xxoo;?>\r\n\r\n简写成：\r\n复制代码 代码如下:\r\n\r\n	<?= $xxoo;?>\r\n\r\n这种简写形式被称为 Short Open Tag, 在 PHP5.3 起被默认开启，在 PHP5.4 起总是可用。\r\n使用这种简写形式在 HTML 中嵌入 PHP 变量将会非常方便。\r\n\r\n对于纯 PHP 文件(如类实现文件), PHP 官方建议顶格写起始标记，同时 省略 结束标记。\r\n这样可以确保整个 PHP 文件都是 PHP 代码，没有任何输出，否则当你包含该文件后，设置 Header 和 Cookie 时会遇到一些麻烦 [注].\r\n\r\n注：Header 和 Cookie 必须在输出任何内容之前被发送。\r\n\r\n\r\n##数组简写形式\r\n\r\n这是非常方便的一项特征！\r\n复制代码 代码如下:\r\n\r\n	// 原来的数组写法\r\n	$arr = array("key" => "value", "key2" => "value2");\r\n	// 简写形式\r\n	$arr = ["key" => "value", "key2" => "value2"];\r\n\r\n\r\n##Traits\r\n\r\n所谓Traits就是“构件”，是用来替代继承的一种机制。PHP中无法进行多重继承，但一个类可以包含多个Traits.\r\n复制代码 代码如下:\r\n\r\n	// Traits不能被单独实例化，只能被类所包含\r\n	trait SayWorld\r\n	{\r\n	    public function sayHello()\r\n	    {\r\n		echo ''World!'';\r\n	    }\r\n	}\r\n\r\n	class MyHelloWorld\r\n	{\r\n	    // 将SayWorld中的成员包含进来\r\n	    use SayWorld;\r\n	}\r\n\r\n	$xxoo = new MyHelloWorld();\r\n	// sayHello() 函数是来自 SayWorld 构件的\r\n	$xxoo->sayHello();\r\n\r\nTraits还有很多神奇的功能，比如包含多个Traits, 解决冲突，修改访问权限，为函数设置别名等等。\r\nTraits中也同样可以包含Traits. 篇幅有限不能逐个举例，详情参见官网 [注].\r\n注：http://www.php.net/manual/zh/language.oop5.traits.php\r\n\r\n##内置 Web 服务器\r\n\r\nPHP从5.4开始内置一个轻量级的Web服务器，不支持并发，定位是用于开发和调试环境。\r\n在开发环境使用它的确非常方便。\r\n复制代码 代码如下:\r\n\r\n	php -S localhost:8000\r\n\r\n这样就在当前目录建立起了一个Web服务器，你可以通过 http://localhost:8000/ 来访问。\r\n其中localhost是监听的ip，8000是监听的端口，可以自行修改。\r\n\r\n很多应用中，都会进行URL重写，所以PHP提供了一个设置路由脚本的功能:\r\n复制代码 代码如下:\r\n\r\n	php -S localhost:8000 index.php\r\n\r\n这样一来，所有的请求都会由index.php来处理。\r\n你还可以使用 XDebug 来进行断点调试。\r\n\r\n\r\n##细节修改\r\n\r\nPHP5.4 新增了动态访问静态方法的方式：\r\n复制代码 代码如下:\r\n\r\n	$func = "funcXXOO";\r\n	A::{$func}();\r\n\r\n新增在实例化时访问类成员的特征：\r\n复制代码 代码如下:\r\n\r\n	(new MyClass)->xxoo();\r\n\r\n新增支持对函数返回数组的成员访问解析(这种写法在之前版本是会报错的)：\r\n复制代码 代码如下:\r\n\r\n	print func()[0];\r\n', NULL, 0, 1),
(111, 4, 105, 'PHP5.5', '<p><strong>yield</strong></p>\r\n\r\n<p><strong>细节修改</strong></p>\r\n', '##yield\r\n\r\nyield关键字用于当函数需要返回一个迭代器的时候, 逐个返回值。\r\n复制代码 代码如下:\r\n\r\n	function number10()\r\n	{\r\n	    for($i = 1; $i <= 10; $i += 1)\r\n		yield $i;\r\n	}\r\n\r\n该函数的返回值是一个数组：\r\n复制代码 代码如下:\r\n\r\n	[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\r\n\r\nlist() 用于 foreach\r\n可以用 list() 在 foreach 中解析嵌套的数组：\r\n复制代码 代码如下:\r\n\r\n	$array = [\r\n	    [1, 2, 3],\r\n	    [4, 5, 6],\r\n	];\r\n\r\n	foreach ($array as list($a, $b, $c))\r\n	    echo "{$a} {$b} {$c}\\n";\r\n\r\n结果：\r\n复制代码 代码如下:\r\n\r\n	1 2 3\r\n	4 5 6\r\n\r\n##细节修改\r\n\r\n不推荐使用 mysql 函数，推荐使用 PDO 或 MySQLi, 参见前文。\r\n不再支持Windows XP.\r\n可用 MyClass::class 取到一个类的完整限定名(包括命名空间)。\r\nempty() 支持表达式作为参数。\r\ntry-catch 结构新增 finally 块。', NULL, 0, 1),
(112, 4, 105, 'PHP5.6', '<ul>\r\n	<li><strong>更好的常量</strong></li>\r\n	<li><strong>更好的可变函数参数</strong></li>\r\n	<li><strong>命名空间</strong></li>\r\n</ul>\r\n', '##更好的常量\r\n\r\n定义常量时允许使用之前定义的常量进行计算：\r\n复制代码 代码如下:\r\n\r\n	const A = 2;\r\n	const B = A + 1;\r\n\r\n	class C\r\n	{\r\n	    const STR = "hello";\r\n	    const STR2 = self::STR + ", world";\r\n	}\r\n\r\n允许常量作为函数参数默认值：\r\n复制代码 代码如下:\r\n\r\n	function func($arg = C::STR2)\r\n\r\n##更好的可变函数参数\r\n\r\n用于代替 func_get_args()\r\n复制代码 代码如下:\r\n\r\n	function add(...$args)\r\n	{\r\n	    $result = 0;\r\n	    foreach($args as $arg)\r\n		$result += $arg;\r\n	    return $result;\r\n	}\r\n\r\n同时可以在调用函数时，把数组展开为函数参数：\r\n复制代码 代码如下:\r\n\r\n	$arr = [2, 3];\r\n	add(1, ...$arr);\r\n\r\n// 结果为 6\r\n\r\n##命名空间\r\n\r\n命名空间支持常量和函数：\r\n复制代码 代码如下:\r\n\r\n	namespace Name\\Space {\r\n	    const FOO = 42;\r\n	    function f() { echo __FUNCTION__."\\n"; }\r\n	}\r\n\r\n	namespace {\r\n	    use const Name\\Space\\FOO;\r\n	    use function Name\\Space\\f;\r\n\r\n	    echo FOO."\\n";\r\n	    f();\r\n	}', NULL, 0, 1);
INSERT INTO `g_booknode` (`nodeid`, `bookid`, `preid`, `title`, `nr`, `nrcode`, `type`, `sort`, `enable`) VALUES
(113, 4, 0, 'PHP魔术方法', '<p>PHP中的魔术方法总结 :__construct, __destruct , __call, __callStatic,__get, __set, __isset, __unset , __sleep, __wakeup, __toString, __set_state, __clone and __autoload</p>\r\n\r\n<p><strong>1、__get、__set</strong><br />\r\n这两个方法是为在类和他们的父类中没有声明的属性而设计的<br />\r\n__get( $property ) 当调用一个未定义的属性时访问此方法<br />\r\n__set( $property, $value ) 给一个未定义的属性赋值时调用<br />\r\n这里的没有声明包括当使用对象调用时，访问控制为proteced,private的属性（即没有权限访问的属性）<br />\r\n<br />\r\n<strong>2、__isset、__unset</strong><br />\r\n__isset( $property ) 当在一个未定义的属性上调用isset()函数时调用此方法<br />\r\n__unset( $property ) 当在一个未定义的属性上调用unset()函数时调用此方法<br />\r\n与__get方法和__set方法相同，这里的没有声明包括当使用对象调用时，访问控制为proteced,private的属性（即没有权限访问的属性）<br />\r\n<strong>3、__call</strong><br />\r\n__call( $method, $arg_array ) 当调用一个未定义的方法是调用此访求<br />\r\n这里的未定义的方法包括没有权限访问的方法</p>\r\n\r\n<p><strong>4、__autoload</strong><br />\r\n__autoload 函数，它会在试图使用尚未被定义的类时自动调用。通过调用此函数，脚本引擎在 PHP 出错失败前有了最后一个机会加载所需的类。<br />\r\n注意: 在 __autoload 函数中抛出的异常不能被 catch 语句块捕获并导致致命错误。</p>\r\n\r\n<p><strong>5、__construct、__destruct</strong><br />\r\n__construct 构造方法，当一个对象创建时调用此方法，使用此方法的好处是：可以使构造方法有一个独一无二的名称,无论它所在的类的名称是什么.这样你在改变类的名称时,就不需要改变构造方法的名称<br />\r\n__destruct 析构方法，PHP将在对象被销毁前（即从内存中清除前）调用这个方法<br />\r\n默认情况下,PHP仅仅释放对象属性所占用的内存并销毁对象相关的资源.<br />\r\n析构函数允许你在使用一个对象之后执行任意代码来清除内存.<br />\r\n当PHP决定你的脚本不再与对象相关时,析构函数将被调用.<br />\r\n在一个函数的命名空间内,这会发生在函数return的时候.<br />\r\n对于全局变量,这发生于脚本结束的时候.如果你想明确地销毁一个对象,你可以给指向该对象的变量分配任何其它值.通常将变量赋值勤为NULL或者调用unset.<br />\r\n<br />\r\n<strong>6、__clone</strong><br />\r\nPHP5中的对象赋值是使用的引用赋值，如果想复制一个对象则需要使用clone方法，在调用此方法是对象会自动调用__clone魔术方法<br />\r\n如果在对象复制需要执行某些初始化操作，可以在__clone方法实现<br />\r\n<br />\r\n<strong>7、__toString </strong><br />\r\n__toString方法在将一个对象转化成字符串时自动调用，比如使用echo打印对象时<br />\r\n如果类没有实现此方法，则无法通过echo打印对象，否则会显示：Catchable fatal error: Object of class test could not be converted to string in<br />\r\n此方法必须返回一个字符串</p>\r\n\r\n<p>在PHP 5.2.0之前，__toString方法只有结合使用echo() 或 print()时 才能生效。PHP 5.2.0之后，则可以在任何字符串环境生效（例如通过printf()，使用%s修饰符），但 不能用于非字符串环境（如使用%d修饰符）。从PHP 5.2.0，如果将一个未定义__toString方法的对象 转换为字符串，会报出一个E_RECOVERABLE_ERROR错误。<br />\r\n<br />\r\n<strong>8、__sleep、__wakeup</strong><br />\r\n__sleep 串行化的时候用<br />\r\n__wakeup 反串行化的时候调用<br />\r\nserialize() 检查类中是否有魔术名称 __sleep 的函数。如果这样，该函数将在任何序列化之前运行。它可以清除对象并应该返回一个包含有该对象中应被序列化的所有变量名的数组。<br />\r\n使用 __sleep 的目的是关闭对象可能具有的任何数据库连接，提交等待中的数据或进行类似的清除任务。此外，如果有非常大的对象而并不需要完全储存下来时此函数也很有用。<br />\r\n相反地，unserialize() 检查具有魔术名称 __wakeup 的函数的存在。如果存在，此函数可以重建对象可能具有的任何资源。<br />\r\n使用 __wakeup 的目的是重建在序列化中可能丢失的任何数据库连接以及处理其它重新初始化的任务。<br />\r\n<br />\r\n<strong>9、__set_state</strong><br />\r\n当调用var_export()时，这个静态 方法会被调用（自PHP 5.1.0起有效）。<br />\r\n本方法的唯一参数是一个数组，其中包含按array(&rsquo;property&rsquo; =&gt; value, &hellip;)格式排列的类属性。<br />\r\n<br />\r\n<strong>10、__invoke</strong><br />\r\n当尝试以调用函数的方式调用一个对象时，__invoke 方法会被自动调用。<br />\r\nPHP5.3.0以上版本有效<br />\r\n<strong>11、__callStatic</strong><br />\r\n它的工作方式类似于 __call() 魔术方法，__callStatic() 是为了处理静态方法调用，<br />\r\nPHP5.3.0以上版本有效<br />\r\nPHP 确实加强了对 __callStatic() 方法的定义；它必须是公共的，并且必须被声明为静态的。同样，__call() 魔术方法必须被定义为公共的，所有其他魔术方法都必须如此。</p>\r\n', '', NULL, 0, 1),
(114, 4, 0, 'PHP 全局变量', '<h2>PHP 全局变量 - 超全局变量</h2>\r\n\r\n<p>PHP 中的许多预定义变量都是&ldquo;超全局的&rdquo;，这意味着它们在一个脚本的全部作用域中都可用。在函数或方法中无需执行 global $variable; 就可以访问它们。</p>\r\n\r\n<p>这些超全局变量是：</p>\r\n\r\n<ul>\r\n	<li>$GLOBALS</li>\r\n	<li>$_SERVER</li>\r\n	<li>$_REQUEST</li>\r\n	<li>$_POST</li>\r\n	<li>$_GET</li>\r\n	<li>$_FILES</li>\r\n	<li>$_ENV</li>\r\n	<li>$_COOKIE</li>\r\n	<li>$_SESSION</li>\r\n</ul>\r\n', '', NULL, 0, 1),
(115, 4, 0, 'PHP缓存技术', '', '', NULL, 0, 1),
(116, 4, 115, '全页面静态化缓存', '<p>也就是将页面全部生成html静态页面，用户访问时直接访问的静态页面，而不会去走<a href="http://www.php114.net/" target="_blank">php</a>服务器解析的流程。此种方式，在CMS系</p>\r\n\r\n<p>统中比较常见，比如dedecms；</p>\r\n\r\n<p>一种比较常用的实现方式是用输出缓存：</p>\r\n\r\n<p>Ob_start()</p>\r\n\r\n<p>******要运行的代码*******</p>\r\n\r\n<p>$content = Ob_get_contents();</p>\r\n\r\n<p>****将缓存内容写入html文件*****</p>\r\n\r\n<p>Ob_end_clean();</p>\r\n', '    Ob_start()\r\n\r\n    ******要运行的代码*******\r\n\r\n    $content = Ob_get_contents();\r\n\r\n    ****将缓存内容写入html文件*****\r\n\r\n    Ob_end_clean();', NULL, 9, 1),
(117, 4, 115, '页面部分缓存', '<p>该种方式，是将一个页面中不经常变的部分进行静态缓存，而经常变化的块不缓存，最后组装在一起显示；可以使用类似于</p>\r\n\r\n<p>ob_get_contents的方式实现，也可以利用类似ESI之类的页面片段缓存策略，使其用来做动态页面中相对静态的片段部分的缓存</p>\r\n\r\n<p>(ESI技术，请baidu，此处不详讲)。</p>\r\n\r\n<p>该种方式可以用于如商城中的商品页；</p>\r\n', '', NULL, 8, 1),
(118, 4, 115, '数据缓存', '<p>顾名思义，就是缓存数据的一种方式；比如，商城中的某个商品信息，当用商品id去请求时，就会得出包括店铺信息、商品信息</p>\r\n\r\n<p>等数据，此时就可以将这些数据缓存到一个php文件中，文件名包含商品id来建一个唯一标示；下一次有人想查看这个商品时，首</p>\r\n\r\n<p>先就直接调这个文件里面的信息，而不用再去数据库查询；其实缓存文件中缓存的就是一个php数组之类；</p>\r\n\r\n<p>Ecmall商城系统里面就用了这种方式；</p>\r\n', '', NULL, 7, 1),
(119, 4, 115, '查询缓存', '<p>其实这跟数据缓存是一个思路，就是根据查询语句来缓存；将查询得到的数据缓存在一个文件中，下次遇到相同的查询时，就直</p>\r\n\r\n<p>接先从这个文件里面调数据，不会再去查数据库；但此处的缓存文件名可能就需要以查询语句为基点来建立唯一标示；</p>\r\n\r\n<p>按时间变更进行缓存</p>\r\n\r\n<p>其实，这一条不是真正的缓存方式；上面的2、3、4的缓存技术一般都用到了时间变更判断；就是对于缓存文件您需要设一个有效</p>\r\n\r\n<p>时间，在这个有效时间内，相同的访问才会先取缓存文件的内容，但是超过设定的缓存时间，就需要重新从数据库中获取数据，</p>\r\n\r\n<p>并生产最新的缓存文件；</p>\r\n\r\n<p>比如，我将我们商城的首页就是设置2个小时更新一次；</p>\r\n', '', NULL, 6, 1),
(120, 4, 115, '按内容变更进行缓存', '<p>这个也并非独立的缓存技术，需结合着用；就是当数据库内容被修改时，即刻更新缓存文件；</p>\r\n\r\n<p>比如，一个人流量很大的商城，商品很多，商品表必然比较大，这表的压力也比较重；我们就可以对商品显示页进行页面缓存；</p>\r\n\r\n<p>当商家在后台修改这个商品的信息时，点击保存，我们同时就更新缓存文件；那么，买家访问这个商品信息时，实际上访问的是</p>\r\n\r\n<p>一个静态页面，而不需要再去访问数据库；</p>\r\n\r\n<p>是想，如果对商品页不缓存，那么每次访问一个商品就要去数据库查一次，如果有10万人在线浏览商品，那服务器压力就大了；</p>\r\n', '', NULL, 5, 1),
(121, 4, 115, '内存式缓存', '<p>提到这个，可能大家想到的首先就是Memcached；memcached是高性能的分布式内存缓存服务器。 一般的使用目的是，通过缓存数</p>\r\n\r\n<p>据库查询结果，减少数据库访问次数，以提高动态Web应用的速度、 提高可扩展性。</p>\r\n\r\n<p>它就是将需要缓存的信息，缓存到系统内存中，需要获取信息时，直接到内存中取；比较常用的方式就是 key--&gt;value方式；</p>\r\n\r\n<p>&nbsp;</p>\r\n', '    <?php \r\n     $memcachehost = ''192.168.6.191'';\r\n     $memcacheport = 11211;\r\n     $memcachelife = 60;\r\n     $memcache = new Memcache;\r\n     $memcache->connect($memcachehost,$memcacheport) or die ("Could not connect");\r\n     $memcache->set(''key'',''缓存的内容'');\r\n     $get = $memcache->get($key);       //获取信息\r\n    ?>', NULL, 4, 1),
(122, 4, 115, 'apache缓存模块', '<p>apache安装完以后，是不允许被cache的。如果外接了cache或squid服务器要求进行web加速的话，就需要在htttpd.conf里进行设</p>\r\n\r\n<p>置，当然前提是在安装apache的时候要激活mod_cache的模块。<br />\r\n安装apache时：./configure --enable-cache --enable-disk-cache --enable-mem-cache</p>\r\n', '', NULL, 3, 1),
(123, 4, 115, 'php APC缓存扩展', '<p>Php有一个APC缓存扩展，windows下面为php_apc.dll，需要先加载这个模块，然后是在php.ini里面进行配置：</p>\r\n\r\n<p>[apc]&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; extension=php_apc.dll&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; apc.rfc1867 = on&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; upload_max_filesize = 100M&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; post_max_size = 100M&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; apc.max_file_size = 200M&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; upload_max_filesize = 1000M&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; post_max_size = 1000M&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; max_execution_time = 600 ;&nbsp;&nbsp; 每个PHP页面运行的最大时间值(秒)，默认30秒&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; max_input_time = 600 ;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 每个PHP页面接收数据所需的最大时间，默认60&nbsp;<br />\r\n&nbsp;&nbsp;&nbsp;&nbsp; memory_limit = 128M ;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 每个PHP页面所吃掉的最大内存，默认8M</p>\r\n', '', NULL, 2, 1),
(124, 4, 115, 'Opcode缓存', '<p>我们知道，php的执行流程可以用下图来展示：</p>\r\n\r\n<p>首先php代码被解析为Tokens，然后再编译为Opcode码，最后执行Opcode码，返回结果；所以，对于相同的php文件，第一次运行</p>\r\n\r\n<p>时可以缓存其Opcode码，下次再执行这个页面时，直接会去找到缓存下的opcode码，直接执行最后一步，而不再需要中间的步骤了。</p>\r\n\r\n<p>比较知名的是XCache、Turck MM Cache、PHP Accelerator等；</p>\r\n', '![](/Upload/20111124055235937.jpg)', NULL, 1, 1),
(125, 4, 0, '设计模式', '<ol>\r\n	<li>工厂模式</li>\r\n	<li>单元素模式</li>\r\n	<li>观察者模式</li>\r\n	<li>命令链模式</li>\r\n	<li>策略模式</li>\r\n</ol>\r\n', '', NULL, 0, 1),
(126, 11, 208, '全栈工程师 Full Stack', '<p>全栈工程师，也叫全端工程师，英文Full Stack developer。是指掌握多种技能，并能利用多种技能独立完成产品的人。</p>\r\n\r\n<h1>价值</h1>\r\n\r\n<h3>全局性思维</h3>\r\n\r\n<p>现代项目的开发，需要掌握多种技术。互联网项目，需要用到后端开发、前端开发、界面设计、产品设计、数据库、各种移 动客户端、三屏兼容、restFul API设计和OAuth等等，比较前卫的项目，还会用到Single Page Application、Web Socket、HTML5/CSS3这些技术以及像第三方开发像微信公众号微博应用等等。</p>\r\n\r\n<p>Web前端也远远不是从前的切个图用个jQuery上个AJAX兼容各种浏览器那么简单了。现代的Web前端，你需要用到模块化开发、多屏兼容、MVC，各种复杂的交互与优化，甚至你需要用到Node.js来协助前端的开发。</p>\r\n\r\n<p>所以说一个现代化的项目，是一个非常复杂的构成，我们需要一个人来掌控全局，他不需要是各种技术的资深专家，但他需要熟悉到各种技术。对于一个团队特别是互联网企业来说，有一个全局性思维的人非常非常重要。[1]<a name="ref_[1]_12434637">&nbsp;</a></p>\r\n\r\n<p><a name="1_2"></a> <a name="sub12434637_1_2"></a> <a name="沟通成本"></a></p>\r\n\r\n<h3>沟通成本</h3>\r\n\r\n<p>项目越大，沟通成本越高，做过项目管理的都知道，项目中的人力是1+1&lt;2的，人越多效率越低。因为沟通是需要成本的，不同技术的人各说各话，前端和后端是一定会掐架的。每个人都会为自己的利益而战，毫不为已的人是不存在的。</p>\r\n\r\n<p>而全栈工程师的成本几乎为零，因为各种技术都懂，胸有成竹，自己就全做了。即使是在团队协作中，与不同技术人员的沟 通也会容易得多，让一个后端和一个前端去沟通，那完全是鸡同鸭讲，更不用说设计师与后端了。但如果有一个人懂产品懂设计懂前端懂后端，那沟通的结果显然不 一样，因为他们讲的，彼此都能听得懂。</p>\r\n\r\n<p><a name="1_3"></a> <a name="sub12434637_1_3"></a> <a name="创业公司"></a></p>\r\n\r\n<h3>创业公司</h3>\r\n\r\n<p>对于创业公司来说，全栈工程师的价值是非常大的，创业公司不可能像大公司一样，各方面的人才都有。所以需要一个多面 手，各种活都能一肩挑，独挡多面的万金油。对于创业公司，不可能说DBA前端后端客户端各种人才全都备齐了，很多工作请人又不饱和，不请人又没法做，外包 又不放心质量，所以全栈工程师是省钱的一妙招。虽然说全栈工程师工资会比一般的工程师会高很多，但综合下来，成本会低很多。[1]<a name="ref_[1]_12434637">&nbsp;</a></p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<h1>困境</h1>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>技术有两个发展方向，一种是纵向一种是横向的，横向的是瑞士军刀，纵向的是削铁如泥的干将莫邪。这两个方向都没有对与错，发展到一定程度都会相互溶合，就好比中国佛家禅修的南顿北渐，其实到了最后，渐悟与顿悟是一样的，顿由渐中来。</p>\r\n\r\n<p>如果一个公司不太懂全栈工程师的价值，那么全栈工程师的地位将会很尴尬，说得不好听一点，全栈工程师就是什么都会， 什么都不会。曾经有一次面试，对方问很基础的问题，他答不上来，但他能做出产品，也知道什么是怎么一回事，他也不会犯那些错误，可他就是答不上概念，要考 倒他非常容易。所以在应聘面试的时候，有些时候会吃亏，他可能会不如那些在某一方面钻得很深的人工资拿得高。</p>\r\n\r\n<p>由于经常在各种技术穿梭，他会经常忘记代码的语法和一些API，所以他经常需要去查API甚至查语法，他觉得没有 Google我几乎没法工作。这在某些人的眼里，是技术不够的表现。他记的只是一个Key，一个如何找寻答案的索引，而不是全部，人脑不是电脑，他不可能 能记下所有的东西。[1]<a name="ref_[1]_12434637">&nbsp;</a></p>\r\n', '　　最近国内外都在流行一个词叫Full Stack，中文翻译过来叫全栈工程师，也叫全端工程师。微博上很多专业人士都在讨论全端工程师，有赞有毁的。我对全端工程师的定义是：掌握多种技能，并 能利用多种技能独立完成产品的人。打外比方，全栈工程师就是一个能独立盖一幢10层小洋楼的人，而普通工程师，则是可以和一群人盖一幢摩天大楼的人。至于 要掌握哪些技能，我觉得这个要跟从事的行业与技术方向有关，做互联网的和做软件的是不一样的，即使是做互联网的，后端也可以分为很多种技术流派。\r\n\r\n　　8/2定律在哪都适用，全栈工程师就是掌握20%常用技能的人，但这20%的技能会有80%的几率被用到，剩下那80%不常用的，让我们Google吧。\r\n\r\n　　有人说，全栈工程师在中国已经很多年了，他们叫站长。这个说话有点靠谱但又不那么靠谱，我自己也做过站长，深知作为一名站长需要掌握很多种技术。不靠谱的是，很多站长其实并没有真正写过多少代码，而是熟练利用一些建站软件来建站。\r\n\r\n　　全栈工程师的价值\r\n\r\n　　有人说了，你再牛逼，你懂五种技术，你能干五个人的活吗？全栈工程师并不是说一个人能干几个人的活，而是要从多个方面来看这个问题。\r\n\r\n　　全局性思维\r\n\r\n　　现代项目的开发，很少说只用到一两种技术的，特别是移动互联网大潮下。随便一个互联网项目中用到的技术，就会需要用到后端开发、前端开发、界面设 计、产品设计、数据库、各种移动客户端、三屏兼容、restFul API设计和OAuth等等，一些比较前卫的项目，可能会用到Single Page Application、Web Socket、HTML5/CSS3这些技术，还有像第三方开发像微信公众号微博应用等等。\r\n\r\n　　Web前端也远远不是从前的切个图用个jQuery上个AJAX兼容各种浏览器那么简单了。现代的Web前端，你需要用到模块化开发、多屏兼容、MVC，各种复杂的交互与优化，甚至你需要用到Node.js来协助前端的开发。\r\n\r\n　　所以说一个现代化的项目，是一个非常复杂的构成，我们需要一个人来掌控全局，他不需要是各种技术的资深专家，但他需要熟悉到各种技术。对于一个团队特别是互联网企业来说，有一个全局性思维的人非常非常重要。\r\n\r\n　　像如果是我经手的项目，我肯定会注意到网页优化，也会考虑到API来兼容各种客户端，更会考虑到三屏兼容的问题。不会说项目中完全使用AJAX而不顾SEO，也不会为了功能性而忽略访问速度，我会很好的把握这个平衡，因为我知道它们的权重与实现成本。\r\n\r\n　　沟通成本\r\n\r\n　　项目越大，沟通成本越高，做过项目管理的人都知道，项目中的人力是1+1<2的，人越多效率越低。因为沟通是需要成本的，不同技术的人各说各话，前端和后端是一定会掐架的。每个人都会为自己的利益而战，毫不为已的人是不存在的。\r\n\r\n　　而全栈工程师的成本几乎为零，因为各种技术都懂，胸有成竹，一不小心自己就全做了。即使是在团队协作中，与不同技术人员的沟通也会容易得多，你让一 个后端和一个前端去沟通，那完全是鸡同鸭讲，更不用说设计师与后端了。但如果有一个人懂产品懂设计懂前端懂后端，那沟通的结果显然不一样，因为他们讲的， 彼此都能听得懂。\r\n\r\n　　创业公司\r\n\r\n　　对于创业公司来说，全端工程师的价值是非常大的，创业公司不可能像大公司一样，各方面的人才都有。所以我们需要一个多面手，各种活都能一肩挑，独挡 多面的万金油。对于创业公司，不可能说DBA前端后端客户端各种人才全都备齐了，很多工作请人又不饱和，不请人又没法做，外包又不放心质量，所以全端工程 师是省钱的一妙招。虽然说全端工程师工资会比一般的工程师会高很多，但综合下来，成本会低很多。\r\n\r\n　　全栈工程师的困境\r\n\r\n　　我讲技术有两个发展方向，一种是纵向一种是横向的，横向的是瑞士军刀，纵向的是削铁如泥的干将莫邪。这两个方向都没有对与错，发展到一定程序都会相互溶合，就好比中国佛家禅修的南顿北渐，其实到了最后，渐悟与顿悟是一样的，顿由渐中来。\r\n\r\n　　如果一个公司不太懂全栈工程师的价值，那么全栈工程师的地位将会很尴尬，说得不好听一点，全栈工程师就是什么都会，都么都不会。曾经有一次面试，对 方问我很基础的问题，我答不上来，我能做出产品，也知道什么是怎么一回事，我也不会犯那些错误，但我就是答不上概念，要考倒我非常容易。所以在应聘面试的时候，有些时候会吃亏，你可能会不如哪些在某一方面钻得很深的人工资拿得高。\r\n\r\n　　由于经常在各种技术穿梭，我会经常忘记代码的语法和一些API，所以我经常需要去查API甚至查语法，我觉得没有Google我几乎没法工作。这在某些人的眼里，是技术不够的表现。我记的只是一个Key，一个如何找寻答案的索引，而不是全部，人脑不是电脑，我不可能要求我能记下所有的东西。\r\n\r\n　　有一次面试官问我一个问题，我说我不知道，但我猜大概是如此这般，对方问我，你为什么这么猜，我说凭直觉，对方笑了笑没说话。面试完后我一查，果然和我猜的差不多。没错，我就是凭直觉，但这种直觉和女人的直觉不一样，这种直觉是技术上的直觉，是你过去技术经验累积的一个反射。\r\n\r\n　　为什么我会成为全栈工程师\r\n\r\n　　我相信很多全栈型工程师会和我一样，是因为要创业才成为全栈型工程师的。我有一颗创业和做产品的心，而且我又是一个不愿意麻烦别人的人，有些人擅长整合资源，空手套白狼，但我显然不是这种人，所以我只好自己做了。\r\n\r\n　　在经历过两次孤独的创业之后，我发现我并不是一个适合独立创业的人，所以，我成为了一个全端工程师。我最初是做ASP，后来自己创业写客户端用 Delphi，然后写了三年的ASP.Net，2010年的时候因为公司需要开始做iOS开发。Web前端是一直自己在做，项目中的的 Javascript基本都是我自己在做。\r\n\r\n　　我热爱写代码，热爱重复发明轮子，热爱新技术，我想这也是我成为一个全栈工程师的重要原因。\r\n\r\n　　于我自己来说，我觉得全端工程师的乐趣要比一般工程师来得多，因为你知道一个产品的形态，你可以去设计一个产品，你是从全局的视野来做事情，你得到的成就感会更多一些。', NULL, 0, 1),
(127, 11, 208, 'Quick and Dirty', '', '', NULL, 0, 1),
(128, 11, 202, ' Single Page Application', '', '', NULL, 0, 1),
(129, 11, 202, 'NodeJs', '', '', NULL, 0, 1),
(130, 11, 202, 'WBS', '<p>WBS：<a href="http://baike.baidu.com/view/1219261.htm" target="_blank">工作分解结构</a>（Work Breakdown Structure） 创建WBS：创建WBS是把项目可交付成果和项目工作分解成较小的，更易于管理的组成部分的过程。</p>\r\n\r\n<p>WBS 是项目管理重要的专业术语之一。WBS的基本定义 ：以可交付成果为导向对项目要素进行的分组，它归纳和定义了项目的整个工作范围每下降一层代表对项目工作的更详细定义。无论在项目管理实践中，还是在 PMP，IPMP考试中，工作分解结构（WBS）都是最重要的内容之一。WBS总是处于计划过程的中心，也是制定进度计划、资源需求、成本预算、风险管理 计划和采购计划等的重要基础。WBS同时也是控制<a href="http://baike.baidu.com/view/245239.htm" target="_blank">项目变更</a>的重要基础。<a href="http://baike.baidu.com/view/1946632.htm" target="_blank">项目范围</a>是由WBS定义的，所以WBS也是一个项目的综合工具。</p>\r\n', '', NULL, 0, 1),
(131, 11, 200, 'UI （用户界面）', '<p>UI即User Interface（<a href="http://baike.baidu.com/view/362528.htm" target="_blank">用户界面</a>） 的简称。UI设计则是指对软件的人机交互、操作逻辑、界面美观的整体设计。好的UI设计不仅是让软件变得有个性有品味，还要让软件的操作变得舒适、简单、 自由、充分体现软件的定位和特点。UI还有其它的意义，如Unit Interval，Univ of Iowa，Unlock Instruction，Urgent Interrupt。</p>\r\n', '', NULL, 0, 1),
(132, 11, 200, 'UE （用户体验） ', '', '', NULL, 0, 1),
(133, 11, 202, 'UGC', '', '', NULL, 0, 1),
(134, 11, 202, 'RPC远程过程调用协议', '', '', NULL, 0, 1),
(135, 11, 202, 'ORM对象关系映射', '', '', NULL, 0, 1),
(136, 11, 202, 'MVC', '', '', NULL, 0, 1),
(137, 11, 200, '视差滚动（Parallax Scrolling）', '', '', NULL, 0, 1),
(138, 11, 200, '瀑布流', '', '', NULL, 0, 1),
(139, 11, 201, 'UML模型图', '', '', NULL, 0, 1),
(140, 11, 201, 'ER图', '', '', NULL, 0, 1),
(141, 11, 201, '甘特图（Gantt chart）', '', '', NULL, 0, 1),
(142, 11, 201, '思维导图 ', '', '', NULL, 0, 1),
(143, 11, 202, 'IDE(Integrated Development Environment,集成开发环境)', '', '', NULL, 0, 1),
(144, 11, 202, '匿名函数 ', '', '', NULL, 0, 1),
(145, 11, 202, 'namespace ', '', '', NULL, 0, 1),
(146, 11, 202, 'LAMP (LNMP / WAMP)', '', '', NULL, 0, 1),
(147, 11, 202, '析构函数 (PHP)', '', '', NULL, 0, 1),
(148, 11, 202, '构造函数 (PHP)', '', '', NULL, 0, 1),
(149, 11, 202, 'PHP', '', '', NULL, 0, 1),
(150, 11, 202, '类', '', '', NULL, 0, 1),
(151, 11, 202, '对象', '', '', NULL, 0, 1),
(152, 11, 202, '函数', '', '', NULL, 0, 1),
(153, 11, 202, 'Session', '', '', NULL, 0, 1),
(154, 11, 202, 'Cookie', '', '', NULL, 0, 1),
(155, 11, 202, '常量', '', '', NULL, 0, 1),
(156, 11, 202, '变量', '', '', NULL, 0, 1),
(157, 11, 202, '引用', '', '', NULL, 0, 1),
(158, 11, 202, 'FastCGI  ', '', '', NULL, 0, 1),
(159, 11, 202, 'CDN', '', '', NULL, 0, 1),
(160, 11, 202, 'swoole', '', '', NULL, 0, 1),
(161, 11, 202, 'HMVC', '', '', NULL, 0, 1),
(162, 11, 202, '组件式框架 (PHP)', '', '', NULL, 0, 1),
(163, 11, 202, 'HOOK', '', '', NULL, 0, 1),
(164, 11, 202, '持久化的缓存', '', '', NULL, 0, 1),
(165, 11, 202, 'NoSQL', '', '', NULL, 0, 1),
(166, 11, 202, 'Key-Value数据库', '', '', NULL, 0, 1),
(167, 11, 202, 'Hadoop', '', '', NULL, 0, 1),
(168, 11, 202, 'HDFS', '', '', NULL, 0, 1),
(169, 11, 202, 'MapReduce', '', '', NULL, 0, 1),
(170, 11, 202, 'ACE', '', '', NULL, 0, 1),
(171, 11, 202, 'SAE', '', '', NULL, 0, 1),
(172, 11, 202, 'PM', '', '', NULL, 0, 1),
(173, 11, 201, 'Deadline', '', '', NULL, 0, 1),
(174, 11, 201, 'KPI', '', '', NULL, 0, 1),
(175, 11, 201, '头脑风暴', '', '', NULL, 0, 1),
(176, 11, 201, '鱼骨图', '', '', NULL, 0, 1),
(177, 11, 202, 'URI', '', '', NULL, 0, 1),
(178, 11, 202, 'URL', '', '', NULL, 0, 1),
(179, 11, 202, 'URN', '', '', NULL, 0, 1),
(180, 11, 202, 'REST', '', '', NULL, 0, 1),
(181, 11, 202, 'RESTful', '', '', NULL, 0, 1),
(182, 11, 202, 'SOA', '', '', NULL, 0, 1),
(183, 11, 202, 'SOAP', '', '', NULL, 0, 1),
(184, 11, 202, 'Token', '', '', NULL, 0, 1),
(185, 11, 202, 'Hash', '', '', NULL, 0, 1),
(186, 11, 202, '对称加密 ', '', '', NULL, 0, 1),
(187, 11, 202, '排序算法 ', '', '', NULL, 0, 1),
(188, 11, 202, 'SDK', '', '', NULL, 0, 1),
(189, 11, 202, 'PAAS ', '', '', NULL, 0, 1),
(190, 11, 200, 'Ember.js', '', '', NULL, 0, 1),
(191, 11, 200, 'AngularJS', '', '', NULL, 0, 1),
(192, 11, 200, 'backboneJS', '', '', NULL, 0, 1),
(193, 11, 200, 'foundation', '', '', NULL, 0, 1),
(194, 11, 202, 'Sass', '', '', NULL, 0, 1),
(195, 11, 202, 'SCSS', '', '', NULL, 0, 1),
(196, 11, 200, 'Less', '', '', NULL, 0, 1),
(197, 11, 202, 'KVM', '', '', NULL, 0, 1),
(198, 11, 200, 'Sencha Touch', '', '', NULL, 0, 1),
(199, 11, 202, 'symfony2', '', '', NULL, 0, 1),
(200, 11, 0, '前端', '', '', NULL, 0, 1),
(201, 11, 0, '项目管理', '', '', NULL, 0, 1),
(202, 11, 0, '开发', '', '', NULL, 0, 1),
(203, 11, 202, 'Single Page Site', '', '', NULL, 0, 1),
(204, 11, 202, '中间件', '', '', NULL, 0, 1),
(205, 11, 202, 'MVCS', '', '', NULL, 0, 1),
(206, 11, 202, 'CRUD', '', '', NULL, 0, 1),
(207, 11, 208, '牙刷测试', '', '', NULL, 0, 1),
(208, 11, 0, '概念', '', '', NULL, 0, 1);

-- --------------------------------------------------------

--
-- 表的结构 `g_group`
--

CREATE TABLE IF NOT EXISTS `g_group` (
  `groupid` int(11) NOT NULL AUTO_INCREMENT,
  `groupname` varchar(32) DEFAULT NULL,
  `groupchr` varchar(16) DEFAULT NULL,
  `sort` int(5) NOT NULL DEFAULT '0',
  `enable` tinyint(1) NOT NULL DEFAULT '0',
  PRIMARY KEY (`groupid`)
) ENGINE=MyISAM  DEFAULT CHARSET=utf8 AUTO_INCREMENT=35 ;

--
-- 转存表中的数据 `g_group`
--

INSERT INTO `g_group` (`groupid`, `groupname`, `groupchr`, `sort`, `enable`) VALUES
(33, '12224', '12324', 12424, 1),
(34, '管理员组', 'admin', 99, 1);

-- --------------------------------------------------------

--
-- 表的结构 `g_log`
--

CREATE TABLE IF NOT EXISTS `g_log` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `code` varchar(16) DEFAULT '0',
  `msg` varchar(16) DEFAULT NULL,
  `controller` varchar(16) DEFAULT NULL,
  `action` varchar(16) DEFAULT NULL,
  `time` text,
  `_GET` text,
  `_POST` text,
  `_FILE` text,
  `router` text,
  `sign` text,
  PRIMARY KEY (`id`)
) ENGINE=MyISAM  DEFAULT CHARSET=utf8 AUTO_INCREMENT=70 ;

--
-- 转存表中的数据 `g_log`
--

INSERT INTO `g_log` (`id`, `code`, `msg`, `controller`, `action`, `time`, `_GET`, `_POST`, `_FILE`, `router`, `sign`) VALUES
(38, '', '', 'friend', 'search', 'a:2:{s:6:"timebe";d:1438758289.3618391;s:6:"timecu";i:1438758289;}', 'a:0:{}', 'a:2:{s:8:"username";s:6:"user02";s:8:"type_cv1";s:16:"javascript_debug";}', 'a:0:{}', 'a:7:{s:6:"Module";s:1:"v";s:10:"Controller";s:6:"friend";s:6:"Action";s:6:"search";s:10:"Action_ext";s:4:"post";s:6:"ispost";s:4:"post";s:5:"_path";s:15:"v/friend/search";s:7:"params_";s:0:"";}', 'a:6:{s:4:"salt";s:4:"SALT";s:9:"timestamp";N;s:8:"deviceid";N;s:9:"signature";N;s:4:"user";N;s:4:"sign";b:0;}'),
(39, '', '', 'friend', 'search', 'a:2:{s:6:"timebe";d:1438758291.0909369;s:6:"timecu";i:1438758291;}', 'a:0:{}', 'a:2:{s:8:"username";s:6:"user02";s:8:"type_cv1";s:16:"javascript_debug";}', 'a:0:{}', 'a:7:{s:6:"Module";s:1:"v";s:10:"Controller";s:6:"friend";s:6:"Action";s:6:"search";s:10:"Action_ext";s:4:"post";s:6:"ispost";s:4:"post";s:5:"_path";s:15:"v/friend/search";s:7:"params_";s:0:"";}', 'a:6:{s:4:"salt";s:4:"SALT";s:9:"timestamp";N;s:8:"deviceid";N;s:9:"signature";N;s:4:"user";N;s:4:"sign";b:0;}'),
(40, '', '', 'friend', 'search', 'a:2:{s:6:"timebe";d:1438758395.745923;s:6:"timecu";i:1438758395;}', 'a:0:{}', 'a:2:{s:8:"username";s:6:"user02";s:8:"type_cv1";s:16:"javascript_debug";}', 'a:0:{}', 'a:7:{s:6:"Module";s:1:"v";s:10:"Controller";s:6:"friend";s:6:"Action";s:6:"search";s:10:"Action_ext";s:4:"post";s:6:"ispost";s:4:"post";s:5:"_path";s:15:"v/friend/search";s:7:"params_";s:0:"";}', 'a:6:{s:4:"salt";s:4:"SALT";s:9:"timestamp";N;s:8:"deviceid";N;s:9:"signature";N;s:4:"user";N;s:4:"sign";b:0;}'),
(41, '', '', 'friend', 'search', 'a:2:{s:6:"timebe";d:1438759490.9473841;s:6:"timecu";i:1438759490;}', 'a:0:{}', 'a:2:{s:8:"username";s:6:"user02";s:8:"type_cv1";s:16:"javascript_debug";}', 'a:0:{}', 'a:7:{s:6:"Module";s:1:"v";s:10:"Controller";s:6:"friend";s:6:"Action";s:6:"search";s:10:"Action_ext";s:4:"post";s:6:"ispost";s:4:"post";s:5:"_path";s:15:"v/friend/search";s:7:"params_";s:0:"";}', 'a:6:{s:4:"salt";s:4:"SALT";s:9:"timestamp";N;s:8:"deviceid";N;s:9:"signature";N;s:4:"user";N;s:4:"sign";b:0;}'),
(42, '', '', 'friend', 'search', 'a:2:{s:6:"timebe";d:1438759491.91944;s:6:"timecu";i:1438759491;}', 'a:0:{}', 'a:2:{s:8:"username";s:6:"user02";s:8:"type_cv1";s:16:"javascript_debug";}', 'a:0:{}', 'a:7:{s:6:"Module";s:1:"v";s:10:"Controller";s:6:"friend";s:6:"Action";s:6:"search";s:10:"Action_ext";s:4:"post";s:6:"ispost";s:4:"post";s:5:"_path";s:15:"v/friend/search";s:7:"params_";s:0:"";}', 'a:6:{s:4:"salt";s:4:"SALT";s:9:"timestamp";N;s:8:"deviceid";N;s:9:"signature";N;s:4:"user";N;s:4:"sign";b:0;}'),
(43, '', '', 'user', 'register', 'a:2:{s:6:"timebe";d:1438764629.070668;s:6:"timecu";i:1438764629;}', 'a:0:{}', 'a:3:{s:8:"username";s:0:"";s:3:"pwd";s:0:"";s:8:"type_cv1";s:16:"javascript_debug";}', 'a:0:{}', 'a:7:{s:6:"Module";s:1:"v";s:10:"Controller";s:4:"user";s:6:"Action";s:8:"register";s:10:"Action_ext";s:4:"post";s:6:"ispost";s:4:"post";s:5:"_path";s:15:"v/user/register";s:7:"params_";s:0:"";}', 'a:6:{s:4:"salt";s:4:"SALT";s:9:"timestamp";N;s:8:"deviceid";N;s:9:"signature";N;s:4:"user";N;s:4:"sign";b:0;}'),
(44, '', '', 'user', 'register', 'a:2:{s:6:"timebe";d:1438764651.0927739;s:6:"timecu";i:1438764651;}', 'a:0:{}', 'a:3:{s:8:"username";s:0:"";s:3:"pwd";s:0:"";s:8:"type_cv1";s:16:"javascript_debug";}', 'a:0:{}', 'a:7:{s:6:"Module";s:1:"v";s:10:"Controller";s:4:"user";s:6:"Action";s:8:"register";s:10:"Action_ext";s:4:"post";s:6:"ispost";s:4:"post";s:5:"_path";s:15:"v/user/register";s:7:"params_";s:0:"";}', 'a:6:{s:4:"salt";s:4:"SALT";s:9:"timestamp";N;s:8:"deviceid";N;s:9:"signature";N;s:4:"user";N;s:4:"sign";b:0;}'),
(45, '', '', 'user', 'register', 'a:2:{s:6:"timebe";d:1438764654.8132401;s:6:"timecu";i:1438764654;}', 'a:0:{}', 'a:3:{s:8:"username";s:0:"";s:3:"pwd";s:0:"";s:8:"type_cv1";s:16:"javascript_debug";}', 'a:0:{}', 'a:7:{s:6:"Module";s:1:"v";s:10:"Controller";s:4:"user";s:6:"Action";s:8:"register";s:10:"Action_ext";s:4:"post";s:6:"ispost";s:4:"post";s:5:"_path";s:15:"v/user/register";s:7:"params_";s:0:"";}', 'a:6:{s:4:"salt";s:4:"SALT";s:9:"timestamp";N;s:8:"deviceid";N;s:9:"signature";N;s:4:"user";N;s:4:"sign";b:0;}'),
(46, '', '', 'user', 'register', 'a:2:{s:6:"timebe";d:1438764659.9646339;s:6:"timecu";i:1438764659;}', 'a:0:{}', 'a:3:{s:8:"username";s:0:"";s:3:"pwd";s:0:"";s:8:"type_cv1";s:16:"javascript_debug";}', 'a:0:{}', 'a:7:{s:6:"Module";s:1:"v";s:10:"Controller";s:4:"user";s:6:"Action";s:8:"register";s:10:"Action_ext";s:4:"post";s:6:"ispost";s:4:"post";s:5:"_path";s:15:"v/user/register";s:7:"params_";s:0:"";}', 'a:6:{s:4:"salt";s:4:"SALT";s:9:"timestamp";N;s:8:"deviceid";N;s:9:"signature";N;s:4:"user";N;s:4:"sign";b:0;}'),
(47, '', '', 'user', 'register', 'a:2:{s:6:"timebe";d:1438764664.1258719;s:6:"timecu";i:1438764664;}', 'a:0:{}', 'a:3:{s:8:"username";s:0:"";s:3:"pwd";s:0:"";s:8:"type_cv1";s:16:"javascript_debug";}', 'a:0:{}', 'a:7:{s:6:"Module";s:1:"v";s:10:"Controller";s:4:"user";s:6:"Action";s:8:"register";s:10:"Action_ext";s:4:"post";s:6:"ispost";s:4:"post";s:5:"_path";s:15:"v/user/register";s:7:"params_";s:0:"";}', 'a:6:{s:4:"salt";s:4:"SALT";s:9:"timestamp";N;s:8:"deviceid";N;s:9:"signature";N;s:4:"user";N;s:4:"sign";b:0;}'),
(48, '', '', 'user', 'register', 'a:2:{s:6:"timebe";d:1438764675.247508;s:6:"timecu";i:1438764675;}', 'a:0:{}', 'a:3:{s:8:"username";s:0:"";s:3:"pwd";s:0:"";s:8:"type_cv1";s:16:"javascript_debug";}', 'a:0:{}', 'a:7:{s:6:"Module";s:1:"v";s:10:"Controller";s:4:"user";s:6:"Action";s:8:"register";s:10:"Action_ext";s:4:"post";s:6:"ispost";s:4:"post";s:5:"_path";s:15:"v/user/register";s:7:"params_";s:0:"";}', 'a:6:{s:4:"salt";s:4:"SALT";s:9:"timestamp";N;s:8:"deviceid";N;s:9:"signature";N;s:4:"user";N;s:4:"sign";b:0;}'),
(49, '', '', 'user', 'register', 'a:2:{s:6:"timebe";d:1438764689.2773099;s:6:"timecu";i:1438764689;}', 'a:0:{}', 'a:3:{s:8:"username";s:0:"";s:3:"pwd";s:0:"";s:8:"type_cv1";s:16:"javascript_debug";}', 'a:0:{}', 'a:7:{s:6:"Module";s:1:"v";s:10:"Controller";s:4:"user";s:6:"Action";s:8:"register";s:10:"Action_ext";s:4:"post";s:6:"ispost";s:4:"post";s:5:"_path";s:15:"v/user/register";s:7:"params_";s:0:"";}', 'a:6:{s:4:"salt";s:4:"SALT";s:9:"timestamp";N;s:8:"deviceid";N;s:9:"signature";N;s:4:"user";N;s:4:"sign";b:0;}'),
(50, '', '', 'user', 'register', 'a:2:{s:6:"timebe";d:1438764717.437921;s:6:"timecu";i:1438764717;}', 'a:0:{}', 'a:3:{s:8:"username";s:0:"";s:3:"pwd";s:0:"";s:8:"type_cv1";s:16:"javascript_debug";}', 'a:0:{}', 'a:7:{s:6:"Module";s:1:"v";s:10:"Controller";s:4:"user";s:6:"Action";s:8:"register";s:10:"Action_ext";s:4:"post";s:6:"ispost";s:4:"post";s:5:"_path";s:15:"v/user/register";s:7:"params_";s:0:"";}', 'a:6:{s:4:"salt";s:4:"SALT";s:9:"timestamp";N;s:8:"deviceid";N;s:9:"signature";N;s:4:"user";N;s:4:"sign";b:0;}'),
(51, '', '', 'user', 'register', 'a:2:{s:6:"timebe";d:1438764740.898263;s:6:"timecu";i:1438764740;}', 'a:0:{}', 'a:3:{s:8:"username";s:0:"";s:3:"pwd";s:0:"";s:8:"type_cv1";s:16:"javascript_debug";}', 'a:0:{}', 'a:7:{s:6:"Module";s:1:"v";s:10:"Controller";s:4:"user";s:6:"Action";s:8:"register";s:10:"Action_ext";s:4:"post";s:6:"ispost";s:4:"post";s:5:"_path";s:15:"v/user/register";s:7:"params_";s:0:"";}', 'a:6:{s:4:"salt";s:4:"SALT";s:9:"timestamp";N;s:8:"deviceid";N;s:9:"signature";N;s:4:"user";N;s:4:"sign";b:0;}'),
(52, '', '', 'user', 'register', 'a:2:{s:6:"timebe";d:1438764744.1494491;s:6:"timecu";i:1438764744;}', 'a:0:{}', 'a:3:{s:8:"username";s:0:"";s:3:"pwd";s:0:"";s:8:"type_cv1";s:16:"javascript_debug";}', 'a:0:{}', 'a:7:{s:6:"Module";s:1:"v";s:10:"Controller";s:4:"user";s:6:"Action";s:8:"register";s:10:"Action_ext";s:4:"post";s:6:"ispost";s:4:"post";s:5:"_path";s:15:"v/user/register";s:7:"params_";s:0:"";}', 'a:6:{s:4:"salt";s:4:"SALT";s:9:"timestamp";N;s:8:"deviceid";N;s:9:"signature";N;s:4:"user";N;s:4:"sign";b:0;}'),
(53, '', '', 'user', 'register', 'a:2:{s:6:"timebe";d:1438764761.8394611;s:6:"timecu";i:1438764761;}', 'a:0:{}', 'a:3:{s:8:"username";s:0:"";s:3:"pwd";s:0:"";s:8:"type_cv1";s:16:"javascript_debug";}', 'a:0:{}', 'a:7:{s:6:"Module";s:1:"v";s:10:"Controller";s:4:"user";s:6:"Action";s:8:"register";s:10:"Action_ext";s:4:"post";s:6:"ispost";s:4:"post";s:5:"_path";s:15:"v/user/register";s:7:"params_";s:0:"";}', 'a:6:{s:4:"salt";s:4:"SALT";s:9:"timestamp";N;s:8:"deviceid";N;s:9:"signature";N;s:4:"user";N;s:4:"sign";b:0;}'),
(54, '', '', 'user', 'register', 'a:2:{s:6:"timebe";d:1438764779.7744861;s:6:"timecu";i:1438764779;}', 'a:0:{}', 'a:3:{s:8:"username";s:0:"";s:3:"pwd";s:0:"";s:8:"type_cv1";s:16:"javascript_debug";}', 'a:0:{}', 'a:7:{s:6:"Module";s:1:"v";s:10:"Controller";s:4:"user";s:6:"Action";s:8:"register";s:10:"Action_ext";s:4:"post";s:6:"ispost";s:4:"post";s:5:"_path";s:15:"v/user/register";s:7:"params_";s:0:"";}', 'a:6:{s:4:"salt";s:4:"SALT";s:9:"timestamp";N;s:8:"deviceid";N;s:9:"signature";N;s:4:"user";N;s:4:"sign";b:0;}'),
(55, '', '', 'user', 'register', 'a:2:{s:6:"timebe";d:1438764823.8300059;s:6:"timecu";i:1438764823;}', 'a:0:{}', 'a:3:{s:8:"username";s:0:"";s:3:"pwd";s:0:"";s:8:"type_cv1";s:16:"javascript_debug";}', 'a:0:{}', 'a:7:{s:6:"Module";s:1:"v";s:10:"Controller";s:4:"user";s:6:"Action";s:8:"register";s:10:"Action_ext";s:4:"post";s:6:"ispost";s:4:"post";s:5:"_path";s:15:"v/user/register";s:7:"params_";s:0:"";}', 'a:6:{s:4:"salt";s:4:"SALT";s:9:"timestamp";N;s:8:"deviceid";N;s:9:"signature";N;s:4:"user";N;s:4:"sign";b:0;}'),
(56, '', '', 'user', 'register', 'a:2:{s:6:"timebe";d:1438764835.469672;s:6:"timecu";i:1438764835;}', 'a:0:{}', 'a:3:{s:8:"username";s:0:"";s:3:"pwd";s:0:"";s:8:"type_cv1";s:16:"javascript_debug";}', 'a:0:{}', 'a:7:{s:6:"Module";s:1:"v";s:10:"Controller";s:4:"user";s:6:"Action";s:8:"register";s:10:"Action_ext";s:4:"post";s:6:"ispost";s:4:"post";s:5:"_path";s:15:"v/user/register";s:7:"params_";s:0:"";}', 'a:6:{s:4:"salt";s:4:"SALT";s:9:"timestamp";N;s:8:"deviceid";N;s:9:"signature";N;s:4:"user";N;s:4:"sign";b:0;}'),
(57, '', '', 'user', 'register', 'a:2:{s:6:"timebe";d:1438765020.0232279;s:6:"timecu";i:1438765020;}', 'a:0:{}', 'a:3:{s:8:"username";s:0:"";s:3:"pwd";s:0:"";s:8:"type_cv1";s:16:"javascript_debug";}', 'a:0:{}', 'a:7:{s:6:"Module";s:1:"v";s:10:"Controller";s:4:"user";s:6:"Action";s:8:"register";s:10:"Action_ext";s:4:"post";s:6:"ispost";s:4:"post";s:5:"_path";s:15:"v/user/register";s:7:"params_";s:0:"";}', 'a:6:{s:4:"salt";s:4:"SALT";s:9:"timestamp";N;s:8:"deviceid";N;s:9:"signature";N;s:4:"user";N;s:4:"sign";b:0;}'),
(58, '', '', 'user', 'register', 'a:2:{s:6:"timebe";d:1438765030.3028159;s:6:"timecu";i:1438765030;}', 'a:0:{}', 'a:3:{s:8:"username";s:0:"";s:3:"pwd";s:0:"";s:8:"type_cv1";s:16:"javascript_debug";}', 'a:0:{}', 'a:7:{s:6:"Module";s:1:"v";s:10:"Controller";s:4:"user";s:6:"Action";s:8:"register";s:10:"Action_ext";s:4:"post";s:6:"ispost";s:4:"post";s:5:"_path";s:15:"v/user/register";s:7:"params_";s:0:"";}', 'a:6:{s:4:"salt";s:4:"SALT";s:9:"timestamp";N;s:8:"deviceid";N;s:9:"signature";N;s:4:"user";N;s:4:"sign";b:0;}'),
(59, '', '', 'user', 'register', 'a:2:{s:6:"timebe";d:1438765041.847476;s:6:"timecu";i:1438765041;}', 'a:0:{}', 'a:3:{s:8:"username";s:0:"";s:3:"pwd";s:0:"";s:8:"type_cv1";s:16:"javascript_debug";}', 'a:0:{}', 'a:7:{s:6:"Module";s:1:"v";s:10:"Controller";s:4:"user";s:6:"Action";s:8:"register";s:10:"Action_ext";s:4:"post";s:6:"ispost";s:4:"post";s:5:"_path";s:15:"v/user/register";s:7:"params_";s:0:"";}', 'a:6:{s:4:"salt";s:4:"SALT";s:9:"timestamp";N;s:8:"deviceid";N;s:9:"signature";N;s:4:"user";N;s:4:"sign";b:0;}'),
(60, '', '', 'user', 'register', 'a:2:{s:6:"timebe";d:1438765048.1328361;s:6:"timecu";i:1438765048;}', 'a:0:{}', 'a:3:{s:8:"username";s:0:"";s:3:"pwd";s:0:"";s:8:"type_cv1";s:16:"javascript_debug";}', 'a:0:{}', 'a:7:{s:6:"Module";s:1:"v";s:10:"Controller";s:4:"user";s:6:"Action";s:8:"register";s:10:"Action_ext";s:4:"post";s:6:"ispost";s:4:"post";s:5:"_path";s:15:"v/user/register";s:7:"params_";s:0:"";}', 'a:6:{s:4:"salt";s:4:"SALT";s:9:"timestamp";N;s:8:"deviceid";N;s:9:"signature";N;s:4:"user";N;s:4:"sign";b:0;}'),
(61, '', '', 'user', 'register', 'a:2:{s:6:"timebe";d:1438765134.996959;s:6:"timecu";i:1438765134;}', 'a:0:{}', 'a:3:{s:8:"username";s:0:"";s:3:"pwd";s:0:"";s:8:"type_cv1";s:16:"javascript_debug";}', 'a:0:{}', 'a:7:{s:6:"Module";s:1:"v";s:10:"Controller";s:4:"user";s:6:"Action";s:8:"register";s:10:"Action_ext";s:4:"post";s:6:"ispost";s:4:"post";s:5:"_path";s:15:"v/user/register";s:7:"params_";s:0:"";}', 'a:6:{s:4:"salt";s:4:"SALT";s:9:"timestamp";N;s:8:"deviceid";N;s:9:"signature";N;s:4:"user";N;s:4:"sign";b:0;}'),
(62, '', '', 'user', 'register', 'a:2:{s:6:"timebe";d:1438765634.6302791;s:6:"timecu";i:1438765634;}', 'a:0:{}', 'a:3:{s:8:"username";s:0:"";s:3:"pwd";s:0:"";s:8:"type_cv1";s:16:"javascript_debug";}', 'a:0:{}', 'a:7:{s:6:"Module";s:1:"v";s:10:"Controller";s:4:"user";s:6:"Action";s:8:"register";s:10:"Action_ext";s:4:"post";s:6:"ispost";s:4:"post";s:5:"_path";s:15:"v/user/register";s:7:"params_";s:0:"";}', 'a:6:{s:4:"salt";s:4:"SALT";s:9:"timestamp";N;s:8:"deviceid";N;s:9:"signature";N;s:4:"user";N;s:4:"sign";b:0;}'),
(63, '', '', 'user', 'register', 'a:2:{s:6:"timebe";d:1438765650.1180811;s:6:"timecu";i:1438765650;}', 'a:0:{}', 'a:3:{s:8:"username";s:0:"";s:3:"pwd";s:0:"";s:8:"type_cv1";s:16:"javascript_debug";}', 'a:0:{}', 'a:7:{s:6:"Module";s:1:"v";s:10:"Controller";s:4:"user";s:6:"Action";s:8:"register";s:10:"Action_ext";s:4:"post";s:6:"ispost";s:4:"post";s:5:"_path";s:15:"v/user/register";s:7:"params_";s:0:"";}', 'a:6:{s:4:"salt";s:4:"SALT";s:9:"timestamp";N;s:8:"deviceid";N;s:9:"signature";N;s:4:"user";N;s:4:"sign";b:0;}'),
(64, '', '', 'user', 'register', 'a:2:{s:6:"timebe";d:1438765653.555932;s:6:"timecu";i:1438765653;}', 'a:0:{}', 'a:3:{s:8:"username";s:0:"";s:3:"pwd";s:0:"";s:8:"type_cv1";s:16:"javascript_debug";}', 'a:0:{}', 'a:7:{s:6:"Module";s:1:"v";s:10:"Controller";s:4:"user";s:6:"Action";s:8:"register";s:10:"Action_ext";s:4:"post";s:6:"ispost";s:4:"post";s:5:"_path";s:15:"v/user/register";s:7:"params_";s:0:"";}', 'a:6:{s:4:"salt";s:4:"SALT";s:9:"timestamp";N;s:8:"deviceid";N;s:9:"signature";N;s:4:"user";N;s:4:"sign";b:0;}'),
(65, '', '', 'user', 'register', 'a:2:{s:6:"timebe";d:1438765712.397841;s:6:"timecu";i:1438765712;}', 'a:0:{}', 'a:3:{s:8:"username";s:0:"";s:3:"pwd";s:0:"";s:8:"type_cv1";s:16:"javascript_debug";}', 'a:0:{}', 'a:7:{s:6:"Module";s:1:"v";s:10:"Controller";s:4:"user";s:6:"Action";s:8:"register";s:10:"Action_ext";s:4:"post";s:6:"ispost";s:4:"post";s:5:"_path";s:15:"v/user/register";s:7:"params_";s:0:"";}', 'a:6:{s:4:"salt";s:4:"SALT";s:9:"timestamp";N;s:8:"deviceid";N;s:9:"signature";N;s:4:"user";N;s:4:"sign";b:0;}'),
(66, '', '', 'user', 'register', 'a:2:{s:6:"timebe";d:1438765729.5117011;s:6:"timecu";i:1438765729;}', 'a:0:{}', 'a:3:{s:8:"username";s:0:"";s:3:"pwd";s:0:"";s:8:"type_cv1";s:16:"javascript_debug";}', 'a:0:{}', 'a:7:{s:6:"Module";s:1:"v";s:10:"Controller";s:4:"user";s:6:"Action";s:8:"register";s:10:"Action_ext";s:4:"post";s:6:"ispost";s:4:"post";s:5:"_path";s:15:"v/user/register";s:7:"params_";s:0:"";}', 'a:6:{s:4:"salt";s:4:"SALT";s:9:"timestamp";N;s:8:"deviceid";N;s:9:"signature";N;s:4:"user";N;s:4:"sign";b:0;}'),
(67, '', '', 'user', 'register', 'a:2:{s:6:"timebe";d:1438765790.990726;s:6:"timecu";i:1438765790;}', 'a:0:{}', 'a:3:{s:8:"username";s:0:"";s:3:"pwd";s:0:"";s:8:"type_cv1";s:16:"javascript_debug";}', 'a:0:{}', 'a:7:{s:6:"Module";s:1:"v";s:10:"Controller";s:4:"user";s:6:"Action";s:8:"register";s:10:"Action_ext";s:4:"post";s:6:"ispost";s:4:"post";s:5:"_path";s:15:"v/user/register";s:7:"params_";s:0:"";}', 'a:6:{s:4:"salt";s:4:"SALT";s:9:"timestamp";N;s:8:"deviceid";N;s:9:"signature";N;s:4:"user";N;s:4:"sign";b:0;}'),
(68, '', '', 'user', 'register', 'a:2:{s:6:"timebe";d:1438765817.7203071;s:6:"timecu";i:1438765817;}', 'a:0:{}', 'a:3:{s:8:"username";s:9:"123123123";s:3:"pwd";s:9:"123123123";s:8:"type_cv1";s:16:"javascript_debug";}', 'a:0:{}', 'a:7:{s:6:"Module";s:1:"v";s:10:"Controller";s:4:"user";s:6:"Action";s:8:"register";s:10:"Action_ext";s:4:"post";s:6:"ispost";s:4:"post";s:5:"_path";s:15:"v/user/register";s:7:"params_";s:0:"";}', 'a:6:{s:4:"salt";s:4:"SALT";s:9:"timestamp";N;s:8:"deviceid";N;s:9:"signature";N;s:4:"user";N;s:4:"sign";b:0;}'),
(69, '', '', 'user', 'register', 'a:2:{s:6:"timebe";d:1438766218.4196351;s:6:"timecu";i:1438766218;}', 'a:0:{}', 'a:3:{s:8:"username";s:9:"123123123";s:3:"pwd";s:9:"123123123";s:8:"type_cv1";s:16:"javascript_debug";}', 'a:0:{}', 'a:7:{s:6:"Module";s:1:"v";s:10:"Controller";s:4:"user";s:6:"Action";s:8:"register";s:10:"Action_ext";s:4:"post";s:6:"ispost";s:4:"post";s:5:"_path";s:15:"v/user/register";s:7:"params_";s:0:"";}', 'a:6:{s:4:"salt";s:4:"SALT";s:9:"timestamp";N;s:8:"deviceid";N;s:9:"signature";N;s:4:"user";N;s:4:"sign";b:0;}');

-- --------------------------------------------------------

--
-- 表的结构 `g_mea`
--

CREATE TABLE IF NOT EXISTS `g_mea` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `tm` int(11) NOT NULL,
  `user` varchar(32) NOT NULL,
  `fname` varchar(64) NOT NULL,
  `enable` int(1) NOT NULL DEFAULT '1',
  `jx` int(2) NOT NULL DEFAULT '0',
  PRIMARY KEY (`id`)
) ENGINE=MyISAM  DEFAULT CHARSET=utf8 AUTO_INCREMENT=16 ;

--
-- 转存表中的数据 `g_mea`
--

INSERT INTO `g_mea` (`id`, `tm`, `user`, `fname`, `enable`, `jx`) VALUES
(10, 1438239955, 'miss', './A/upload/v6/miss/201507/1438239955.mea', 1, 0),
(11, 1438239966, 'zhaiyingpeng', './A/upload/v6/zhaiyingpeng/201507/1438239966.mea', 1, 0),
(8, 1437542521, 'Cccc', './A/upload//v6/Cccc/201507/1437542521.mea', 1, 1),
(9, 1437542563, 'Cccc', './A/upload/v6/Cccc/201507/1437542563.mea', 1, 0),
(12, 1438246644, 'zhaiyingpeng', './A/upload/v6/zhaiyingpeng/201507/1438246644.mea', 1, 0),
(13, 1438394810, 'zhaiyingpeng', './A/upload/v6/zhaiyingpeng/201508/1438394810.mea', 1, 0),
(14, 1438757485, 'zhaiyingpeng', './A/upload/v6/zhaiyingpeng/201508/1438757485.mea', 1, 0),
(15, 1438758553, 'zhaiyingpeng', './A/upload/v6/zhaiyingpeng/201508/1438758553.mea', 1, 0);

-- --------------------------------------------------------

--
-- 表的结构 `g_relation`
--

CREATE TABLE IF NOT EXISTS `g_relation` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `uname1` varchar(11) NOT NULL,
  `uname2` varchar(11) NOT NULL,
  PRIMARY KEY (`id`),
  KEY `uname1` (`uname1`),
  KEY `uname2` (`uname2`)
) ENGINE=MyISAM  DEFAULT CHARSET=utf8 AUTO_INCREMENT=48 ;

--
-- 转存表中的数据 `g_relation`
--

INSERT INTO `g_relation` (`id`, `uname1`, `uname2`) VALUES
(1, 'Cccc', 'Cccc'),
(7, 'Cccc', 'Bbbb'),
(11, 'user01', 'user02'),
(12, 'Xxxx', 'Bbbb'),
(13, 'Bbbb', 'Kkkkk'),
(14, 'Cccc', 'Mmmm'),
(15, 'Baba', 'Cccc'),
(16, 'Cccc', 'Lp'),
(17, 'Lp', 'Ml'),
(18, 'Ml', 'Kl'),
(19, 'Lz', 'Cccc'),
(20, 'user01', 'user02'),
(21, '123', 'Yanmin'),
(22, 'Bbbb', 'Fffff'),
(23, 'dog', 'Cccc'),
(24, 'Zp', 'Cccc'),
(25, 'Zp', 'Lz'),
(26, 'Lz', 'Mmmm'),
(27, 'Cccc', 'Aq'),
(28, 'Cccc', 'Aq'),
(29, 'Cccc', 'Aq'),
(30, 'Aq', 'Cccc'),
(31, 'Aq', 'Cccc'),
(32, 'Rr', 'Cccc'),
(33, 'Ti', 'Ty'),
(34, 'Cccc', 'Ti'),
(35, 'Ti', 'Mmmm'),
(36, 'Ti', 'Mmmm'),
(37, 'Ti', 'Mmmm'),
(38, 'Ti', 'Mmmm'),
(39, 'Mmmm', 'Ti'),
(40, 'Ti', 'Mmmm'),
(41, 'Ti', 'Mmmm'),
(42, 'Ti', 'Mmmm'),
(43, 'Ti', 'Mmmm'),
(44, 'Ti', 'Mmmm'),
(45, 'Wangquan', 'Cccc'),
(46, 'user01', 'user02'),
(47, 'user01', 'user02');

-- --------------------------------------------------------

--
-- 表的结构 `g_rulelib`
--

CREATE TABLE IF NOT EXISTS `g_rulelib` (
  `rule_id` int(11) NOT NULL AUTO_INCREMENT,
  `rule_group` varchar(64) NOT NULL,
  `rule_name` varchar(64) NOT NULL,
  `rule_dis` text,
  `rule_module` varchar(64) NOT NULL,
  `rule_controller` varchar(64) NOT NULL,
  `rule_action` varchar(64) NOT NULL,
  `sort` int(3) NOT NULL DEFAULT '0',
  `enable` int(1) NOT NULL DEFAULT '1',
  PRIMARY KEY (`rule_id`)
) ENGINE=MyISAM  DEFAULT CHARSET=utf8 AUTO_INCREMENT=2 ;

--
-- 转存表中的数据 `g_rulelib`
--

INSERT INTO `g_rulelib` (`rule_id`, `rule_group`, `rule_name`, `rule_dis`, `rule_module`, `rule_controller`, `rule_action`, `sort`, `enable`) VALUES
(1, '', '', NULL, 's', 'home', 'main', 0, 1);

-- --------------------------------------------------------

--
-- 表的结构 `g_userapi`
--

CREATE TABLE IF NOT EXISTS `g_userapi` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(32) DEFAULT NULL,
  `v` varchar(32) DEFAULT NULL,
  `api` varchar(128) DEFAULT NULL,
  `dis` varchar(256) DEFAULT NULL,
  `request` text,
  `response` text,
  `enable` tinyint(1) NOT NULL,
  `debug` tinyint(1) NOT NULL,
  `sort` int(11) NOT NULL DEFAULT '0',
  `type` varchar(16) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=MyISAM  DEFAULT CHARSET=utf8 AUTO_INCREMENT=39 ;

--
-- 转存表中的数据 `g_userapi`
--

INSERT INTO `g_userapi` (`id`, `name`, `v`, `api`, `dis`, `request`, `response`, `enable`, `debug`, `sort`, `type`) VALUES
(1, '查找好友', 'v', 'friend/search', '模块: 查找好友\n说明 :用户根据用户id查找好友，返回具有改id的用户\n参数 :username用户名\n成功 :\n失败 :', '{\n    "username": "user02"\n}', '{\n    "code": 200,\n    "msg": "succeed",\n    "data": {\n        "username": "li",\n        "userid": "li",\n        "portrait": "http://hebei.sinaimg.cn/2013/0104/U7459P1275DT20130104173656.jpg"\n    }\n}', 1, 0, 9999, 'GET'),
(2, '添加好友', 'v', 'friend/add', '模块 :添加好友\n说明 :\n参数 :targetid将要添加的好友的id,message添加好友附加的内容\n成功 :如果该好友列表中没有这个好友则发出好友添加请求，并反馈“添加好友请求发送成功”，否则其他提醒内容\n失败 :', '{"username":"user01",\n    "targetname":"user02"\n}', '{\n    "code": 200,\n    "msg": "succeed",\n    "data": "添加好友请求发送成功"\n}', 0, 0, 9999, 'GET'),
(3, '获取好友列表', 'v', 'friend/getfriends', '模块 :获取好友列表\n说明 :\n参数 :\n成功 :\n失败 :', '{\n    "username": "user01"\n}', '{\n    "code": 200,\n    "msg": "succeed",\n    "data": [\n         {\n            "userid": "zhang",\n            "username": "zhang",\n            "portrait": "http://img.zjolcdn.com/pic/0/06/58/52/6585256_962155.jpg"\n        },\n        {\n            "userid": "user03",\n            "username": "王五",\n            "portrait": "http://img.zjolcdn.com/pic/0/06/58/52/6585256_962155.jpg"\n        },\n        {\n            "userid": "user04",\n            "username": "麻子",\n            "portrait": "http://img.zjolcdn.com/pic/0/06/58/52/6585255_749157.jpg"\n        },\n        {\n            "userid": "user05",\n            "username": "高雷",\n            "portrait": "http://pic.159.com/desk/user/2012/10/26/Jiker201295211551156.jpg"\n        },\n        {\n            "userid": "user06",\n            "username": "苏醒",\n            "portrait": "http://img2.3lian.com/2014/f4/201/d/85.jpg"\n        },\n        {\n            "userid": "user07",\n            "username": "沙宝亮",\n            "portrait": "http://img.dapixie.com/uploads/allimg/111211/1-111211141406.jpg"\n        }\n    ]\n}', 1, 0, 9999, 'GET'),
(4, '获取用户token值', 'v', 'user/gettoken', '模块 :\n说明 :\n参数 :\n成功 :\n失败 :', '{\n    "username": "user01"\n}', '{\n    "code": 200,\n    "msg": "succeed",\n      "token": "nd787DeXGtYlJG9hc4enUQPdsFArjkVwRsE5q/VVOWVrtOYDQ0sqxJZogb1+7GEeueYpEnn25Dw="\n    \n}', 1, 1, 9, 'GET'),
(5, '用户获取消息队列', 'v', 'user/getmessage', '模块 :\n说明 :\n参数 :\n成功 :\n失败 :', '', '{\n    "code": 200,\n    "msg": "succeed",\n    "data": [\n        {\n            "msgtype": "1",\n            "username": "李四",\n            "userid": "user02",\n            "portrait": "http://dmimg.5054399.com/allimg/xztuku/130924007.jpg"\n        }\n    ]\n}', 1, 0, 9, 'GET'),
(6, 'friend.test', 'v', 'friend/test', '模块 :\n说明 :\n参数 :\n成功 :\n失败 :', '', '{"code":4104,"msg":"ok: wait for design ","data":"","getpost":{}}', 1, 1, -999, 'POST'),
(7, '请求对应科室的医生数据', 'v', 'docnav/hos_spec', '模块 :求医导航\n说明 :求医导航具体医院的专科医生信息\n参数 :hos_id医院id,spec_id专科id\n成功 :\n失败 :', '', '{\n    "code": 200,\n    "msg": "succeed",\n    "data": {\n"id":"0",\n"doc":[{"name":"张三","job":"专家","url":"xxxx"},{"name":"李四","job":"专家","url":"zzz"},{"name":"李四","job":"专家","url":"zzz"},{"name":"李四","job":"专家","url":"zzz"},{"name":"李四","job":"专家","url":"zzz"},{"name":"李四","job":"专家","url":"zzz"},{"name":"李四","job":"专家","url":"zzz"},{"name":"李四","job":"专家","url":"zzz"},{"name":"李四","job":"专家","url":"zzz"},{"name":"李四","job":"专家","url":"zzz"},{"name":"李四","job":"专家","url":"zzz"},{"name":"李四","job":"专家","url":"zzz"},{"name":"李四","job":"专家","url":"zzz"}]\n}\n    \n    \n}', 1, 1, -9, 'GET'),
(8, '获取专科医院排名的科室索引', 'v', 'docnav/special_list', '模块 :求医问药\n说明 :求医问药模块专科排行榜的科室索引\n参数 :\n成功 :\n失败 :', '', '{\n"code":200,\n"msg":"succeed",\n"data":{\n"department":["aa","bb","cc",\n"aa","bb","cc",\n"aa","bb","cc",\n"aa","bb","cc",\n"aa","bb","cc",\n"aa","bb","cc",\n"aa","bb","cc",\n"aa","bb","cc",\n"aa","bb","cc",\n"aa","bb","cc"]\n}\n}', 1, 1, -9, 'GET'),
(9, '获取对应科室的详细数据', 'v', 'docnav/spec_detail', '模块 :求医导航\n说明 :求医导航模块专科排名的对应科室的详细数据\n参数 :index表示对应科室的id\n成功 :\n失败 :', '', '{\n    "code": 200,\n    "msg": "succeed",\n    "data": {\n        "last": {\n            "id": "11",\n            "hospital_name": [\n                "北京大学附属肿瘤医院",\n                "第三医院"\n            ],\n            "hospital_rank": "11"\n        },\n        "rank": [\n            {\n                "id": "0",\n                "hospital_name": "复旦大学附属肿瘤医院",\n                "hospital_rank": "1",\n                "hospital_state": "不变",\n                "hospital_score": "8.8888"\n            },\n            {\n                "id": "1",\n                "hospital_name": "复旦大学附属肿瘤医院",\n                "hospital_rank": "2",\n                "hospital_state": "不变",\n                "hospital_score": "8.8888"\n            },\n            {\n                "id": "1",\n                "hospital_name": "复旦大学附属肿瘤医院",\n                "hospital_rank": "2",\n                "hospital_state": "不变",\n                "hospital_score": "8.8888"\n            },\n            {\n                "id": "1",\n                "hospital_name": "复旦大学附属肿瘤医院",\n                "hospital_rank": "2",\n                "hospital_state": "不变",\n                "hospital_score": "8.8888"\n            },\n            {\n                "id": "1",\n                "hospital_name": "复旦大学附属肿瘤医院",\n                "hospital_rank": "3",\n                "hospital_state": "不变",\n                "hospital_score": "8.8888"\n            },\n            {\n                "id": "1",\n                "hospital_name": "复旦大学附属肿瘤医院",\n                "hospital_rank": "5",\n                "hospital_state": "不变",\n                "hospital_score": "8.8888"\n            },\n            {\n                "id": "1",\n                "hospital_name": "复旦大学附属肿瘤医院",\n                "hospital_rank": "6",\n                "hospital_state": "不变",\n                "hospital_score": "8.8888"\n            },\n            {\n                "id": "1",\n                "hospital_name": "复旦大学附属肿瘤医院",\n                "hospital_rank": "2",\n                "hospital_state": "不变",\n                "hospital_score": "8.8888"\n            }\n        ]\n    }\n}', 1, 1, -9, 'GET'),
(10, '获取最佳医院排名', 'v', 'docnav/best_hosptail_list', '模块 :求医导航模块\n说明 :获取最佳医院排名及对应医院的科室排名\n参数 :缺省为获取最佳医院排名\n成功 :\n失败 :', '', '{\n"code":200,\n"msg":"succeed",\n"data":\n\n[{\n"id":"0",\n"hospital_name":"复旦大学附属肿瘤医院",\n"hospital_rank":"1",\n"hospital_spec":"5.5",\n"hospital_edu":"11",\n"hospital_score":"8.8888"\n\n},\n{\n"id":"0",\n"hospital_name":"复旦大学附属肿瘤医院",\n"hospital_rank":"2",\n"hospital_spec":"5.5",\n"hospital_edu":"11",\n"hospital_score":"8.8888"\n},\n{\n"id":"0",\n"hospital_name":"复旦大学附属肿瘤医院",\n"hospital_rank":"2",\n"hospital_spec":"5.5",\n"hospital_edu":"11",\n"hospital_score":"8.8888"\n},\n{\n"id":"0",\n"hospital_name":"复旦大学附属肿瘤医院",\n"hospital_rank":"2",\n"hospital_spec":"5.5",\n"hospital_edu":"11",\n"hospital_score":"8.8888"\n},\n{\n"id":"0",\n"hospital_name":"复旦大学附属肿瘤医院",\n"hospital_rank":"2",\n"hospital_spec":"5.5",\n"hospital_edu":"11",\n"hospital_score":"8.8888"\n},\n{\n"id":"0",\n"hospital_name":"复旦大学附属肿瘤医院",\n"hospital_rank":"2",\n"hospital_spec":"5.5",\n"hospital_edu":"11",\n"hospital_score":"8.8888"\n},\n{\n"id":"0",\n"hospital_name":"复旦大学附属肿瘤医院",\n"hospital_rank":"2",\n"hospital_spec":"5.5",\n"hospital_edu":"11",\n"hospital_score":"8.8888"\n},\n{\n"id":"0",\n"hospital_name":"复旦大学附属肿瘤医院",\n"hospital_rank":"2",\n"hospital_spec":"5.5",\n"hospital_edu":"11",\n"hospital_score":"8.8888"\n},\n{\n"id":"0",\n"hospital_name":"复旦大学附属肿瘤医院",\n"hospital_rank":"2",\n"hospital_spec":"5.5",\n"hospital_edu":"11",\n"hospital_score":"8.8888"\n},\n{\n"id":"0",\n"hospital_name":"复旦大学附属肿瘤医院",\n"hospital_rank":"2",\n"hospital_spec":"5.5",\n"hospital_edu":"11",\n"hospital_score":"8.8888"\n},\n{\n"id":"0",\n"hospital_name":"复旦大学附属肿瘤医院",\n"hospital_rank":"2",\n"hospital_spec":"5.5",\n"hospital_edu":"11",\n"hospital_score":"8.8888"\n}]\n}', 1, 1, -9, 'GET'),
(11, '请求某个最佳医院的详细信息', 'v', 'docnav/best_hosptail', '模块 :求医导航\n说明 :请求某个医院的详细信息.\n参数 :spec_index,为发起请求的医院id\n成功 :\n失败 :', '', '{\n    "code": 200,\n    "msg": "succeed",\n    "data": {\n        "id": "0",\n        "content": [\n            {\n                "rank_name": "第一名",\n                "rank_content": [\n                    "风湿病",\n                    "妇产科",\n                    "普通外科"\n                ]\n            },\n            {\n                "rank_name": "第二名",\n                "rank_content": [\n                    "病理科",\n                    "呼吸科",\n                    "麻醉科",\n                    "内分泌科"\n                ]\n            }\n        ]\n    }\n}', 1, 1, -9, 'GET'),
(12, '求医问药问题库', 'v', 'docnav/ask/', '模块 :求医问药\n说明 :求医问药模块问题库按照疾病名字请求数据\n参数 :diseaseName,疾病名称\n成功 :\n失败 :', '', '{\n"code":200,\n"msg":"succeed",\n"data":{\n"name":"青春痘",\n"symptom":"起了好多痘痘",\n"cause":"年青",\n"prevented":"变老",\n"asked":[\n{"question":"如何治疗0",\n"to":"不要放弃治疗0"\n},{"question":"如何治疗1",\n"to":"不要放弃治疗1"\n},{"question":"如何治疗2",\n"to":"不要放弃治疗2"\n},{"question":"如何治疗3",\n"to":"不要放弃治疗3"\n}\n]\n}\n}', 1, 1, -9, 'GET'),
(13, '院内导诊获取所有医院名字', 'v', 'docnav/hospitalguidelist', '模块 :求医导航之院内导诊\n说明 :获取所有有导航数据的医院的名字\n参数 :\n成功 :\n失败 :', '', '{\n    "code": 200,\n    "msg": "succeed",\n    "data": [\n        {\n            "name": "1北京人民医院",\n            "id": "1"\n        },\n        {\n            "name": "2北京人民医院",\n            "id": "1"\n        },\n        {\n            "name": "3北京人民医院",\n            "id": "1"\n        },\n        {\n            "name": "4北京人民医院",\n            "id": "1"\n        },\n        {\n            "name": "5北京人民医院",\n            "id": "1"\n        },\n        {\n            "name": "6北京人民医院",\n            "id": "1"\n        },\n        {\n            "name": "7北京人民医院",\n            "id": "1"\n        },\n        {\n            "name": "8北京人民医院",\n            "id": "1"\n        },\n        {\n            "name": "北京人民医院",\n            "id": "1"\n        },\n        {\n            "name": "2北京人民医院",\n            "id": "1"\n        },\n        {\n            "name": "3北京人民医院",\n            "id": "1"\n        },\n        {\n            "name": "4北京人民医院",\n            "id": "1"\n        },\n        {\n            "name": "5北京人民医院",\n            "id": "1"\n        },\n        {\n            "name": "6北京人民医院",\n            "id": "1"\n        },\n        {\n            "name": "7北京人民医院",\n            "id": "1"\n        },\n        {\n            "name": "8北京人民医院",\n            "id": "1"\n        },\n\n        {\n            "name": "北京人民医院",\n            "id": "1"\n        }, {\n            "name": "人民医院",\n            "id": "1"\n        }\n    ]\n}', 1, 1, -9, 'GET'),
(14, '获取院区分布图', 'v', 'docnav/hospitalmap', '模块 :求医导航院内导诊\n说明 :获取院区分布图\n参数 ::name医院名称\n成功 :\n失败 :', '', '{\n"code":200,\n"msg":"succeed",\n"data":{"route":"从南到北方","image":"http:192.168.0.200/mm"}\n}', 1, 1, -9, 'GET'),
(15, '获取门诊分布图', 'v', 'docnav/outpatientmap', '模块 :求医导航院内导诊\n说明 :获取门诊分布图\n参数 ::name医院名称\n成功 :\n失败 :', '', '{\n"code":200,\n"msg":"succeed",\n"data":{"route":"从南到北方","image":"http:192.168.0.200/mm"}\n}', 1, 1, -9, 'GET'),
(16, '登录', 'v', 'user/login', '模块 :登录模块\n说明 :\n参数 :username登录用户名,pwd用户密码\n成功 :\n失败 :', '{"username":"",\n"pwd":""\n}', '{\n"code":200,\n"msg":"succeed",\n"data":""\n}', 0, 0, 11111, 'GET'),
(17, '注册', 'v', 'user/register', '模块 :用户注册\n说明 :\n参数 :username用户名pwd用户密码\n成功 :\n失败 :', '{\n"username":"",\n"pwd":""\n\n}', '{"code":200,\n"msg":"succeed",\n"data":""\n}', 0, 0, 11111, 'GET'),
(18, '获取最新版本号', 'v', 'user/updateApp', '模块 :更新版本\n说明 :获取最新的app版本,url为最新版本的下载地址,version为最新版本号\n参数 :\n成功 :\n失败 :', '', '{"code":200,\n"msg":"succeed",\n"data":\n{\n"path":"http://gdown.baidu.com/data/wisegame/bd47bd249440eb5f/shenmiaotaowang2.apk",\n"version":"2.0",\n"description":"可以中大奖"\n}\n\n\n}', 1, 1, -999, 'GET'),
(19, '--------------------------------', 'v', '--------------------------------', '模块 :\n说明 :\n参数 :\n成功 :\n失败 :', '{\n"name":"zhangbo",\n"age":"23"\n}', '{\n"code":300,\n"msg":"898998899",\n"data":{\n"name":"zhangbo",\n"age":"23"\n}\n}', 0, 1, 10000, 'GET'),
(20, '保存以及更新用户个人信息', 'v', 'user/updateUserInfo', '模块 :个人信息设置\n说明 :保存以及更新个人信息\n参数 :\n"nickname":昵称,\n"name":姓名\n"gender":性别,\n"birth":生日,记录年月日,\n"stature":身高(单位cm),\n"weight":体重(单位kg)\n"region":地区\n"address":地址\n\n成功 :\n失败 :', '{\n"nickname":"zhai",\n"name":"name",\n"gender":"nan",\n"birth":"24",\n"stature":"1",\n"weight":"1",\n"region":"d",\n"address":"z"\n\n\n}', '{"code":200,\n"msg":"succeed",\n"data":""\n}', 1, 1, 11111, 'GET'),
(21, '意见反馈', 'v', 'user/feedback', '模块 :设置模块\n说明 :设置模块中的意见反馈\n参数 :content:用户反馈的内容\n成功 :\n失败 :', '{\n"content":"山东省地发斯蒂芬"\n}', '{"code":200,\n"msg":"succeed",\n"data":""\n}', 1, 0, -99, 'GET'),
(22, '获取用户信息', 'v', 'getUserInfo', '模块: 个人信息设置\n说明 :获取个人信息\n参数 :username用户名\n成功 :\n失败 :', '{\n"username":"张三"\n}', '{\n"code":200,\n"msg":"succeed",\n"data":{\n"nickname":"李白",\n"gender":"男",\n"birth":"1992.05",\n"stature":"180",\n"weight":"88"\n}\n}', 1, 1, 99, 'GET'),
(23, '修改用户密码', 'v', 'user/changepassword', '模块 :设置模块修改密码\n说明 :\n参数 :"username":用户名,\n"orgpwd":原来密码,\n"newpwd":新密码\n成功 :\n失败 :', '{"username":"张三",\n"orgpwd":"123456",\n"newpwd":"abcdefg"\n}\n', '{\n"code":200,\n"msg":"修改成功",\n"data":""\n}', 0, 0, 9, 'GET'),
(24, '获取养生文章', 'v', 'comm/healthknowledge', '模块 :获取养生文章\n说明 :\n参数 :"page":代表获取的第几页\n成功 :\n失败 :', '{\n"page":"1"\n}', '{\n    "code": 200,\n    "msg": "succeed",\n    "data": [\n        {\n            "article_id": "0010101",\n            "article_title": "别轻乎9个小征兆恐是心脏病前兆",\n            "article_detail": "现今由于医疗发达，健康饮食教育也更加普及，死于心脏疾病的人数已较过去少",\n            "article_url": "http://yidianzixun.com/n/08emCWIg/?s=9",\n            "article_author": "温州二手网",\n            "article_time": "2015-01-01"\n        },\n        {\n            "article_id": "0010102",\n            "article_title": "给心脏上道“康复险”",\n            "article_detail": "年龄不是心脏康复的障碍",\n            "article_url": "http://192.168.1.200/xx",\n            "article_author": "39健康网",\n            "article_time": "2015-01-01"\n        },\n        {\n            "article_id": "0010103",\n            "article_title": "老人勤刷牙_巧防心脏病",\n            "article_detail": "英国科学家日前发觉，口腔卫生状况不佳也会增加罹患心脏病的风险",\n            "article_url": "http://192.168.1.200/xx",\n            "article_author": "红牛养生堂",\n            "article_time": "2015-01-01"\n        }\n    ]\n}', 1, 1, -9, 'GET'),
(25, '获取心脏疾病列表', 'v', 'comm/heartdiseaselist', '模块 :健康科普\n说明 :获取疾病名字等信息的列表\n参数 :\n成功 :\n失败 :', '', '{\n    "code": 200,\n    "msg": "succeed",\n    "data": [\n        {\n            "disease_id": "h_001",\n            "disease_name": "冠心病",\n            "disease_detail": "许多冠心病发作是可以预防的",\n            "disease_url": "http://192.168.1.200/v3/comm/diseaseitem"\n        },\n        {\n            "disease_id": "h_002",\n            "disease_name": "心律不齐",\n            "disease_detail": "心律不齐小问题大反应",\n            "disease_url": "http://192.168.1.200/xx"\n        },\n        {\n            "disease_id": "h_003",\n            "disease_name": "心肌炎",\n    "disease_detail": "心肌,生命力的关键",\n            "disease_url": "http://192.168.1.200/xx"\n        },\n        {\n            "disease_id": "h_004",\n            "disease_name": "心血管",\n"disease_detail": "生命流通的通道",\n            "disease_url": "http://192.168.1.200/xx"\n        }\n    ]\n}', 1, 1, -9, 'GET'),
(26, '获取疾病的子条目', 'v', 'comm/diseaseitem', '模块 :知识模块\n说明 :获取疾病的详细条目\n参数 :disease_id要获取的疾病的id\n成功 :\n失败 :', '{\n"disease_id":"0001"\n}', '{\n    "code": 200,\n    "msg": "succeed",\n    "data": \n      [\n            {\n                "item_id": "01",\n                "item_title": "什么是冠心病发作？",\n                "item_url": "http://hao.360.cn/?a1004"\n            },\n            {\n                "item_id": "02",\n                "item_title": "引起冠心病发作和脑卒中的原因有哪些",\n                "item_url": "http://192.168.1.200"\n            },\n  {\n                "item_id": "02",\n                "item_title": "什么是冠心病发作的症状",\n                "item_url": "http://192.168.1.200"\n            }\n        ,\n{\n                "item_id": "02",\n                "item_title": "冠心病发作时怎样做",\n                "item_url": "http://192.168.1.200"\n            }\n        \n    ]\n}', 1, 1, -9, 'GET'),
(27, '获取糖尿病接口', 'v', 'comm/diabetes', '模块 :\n说明 :\n参数 :\n成功 :\n失败 :', '{\n"page":"1"\n}', '{\n    "code": 200,\n    "msg": "succeed",\n    "data": [\n        {\n            "article_id": "0010101",\n            "article_title": "糖尿病的早期症状",\n            "article_detail": "糖尿病是一组以高血糖为特征的代谢性疾病。",\n            "article_url": "http://baike.baidu.com/link?url=gQWynIzi6YldjmgmdAvjNfYWuF8FxT9Kc-l7eDIK_Rsy3RnCtb9kVJ0mzJi0fbph#2",\n            "article_author": "百科名医网",\n            "article_time": "2015-01-01"\n        },\n        {\n            "article_id": "0010102",\n            "article_title": "糖尿病的饮食治疗",\n            "article_detail": "糖尿病的饮食是很重要的，这也是很多患者都知道的问题.",\n            "article_url": "http://tnb.xywy.com/zhiliao/698037.html",\n            "article_author": "寻医问药社区",\n            "article_time": "2015-01-01"\n        },\n        {\n            "article_id": "0010103",\n            "article_title": "糖尿病的自我疗法",\n            "article_detail": "糖尿病的发病原因是因为患者身体内血糖过高，胰岛素是身体内控制、消耗血糖的唯一有效激素。",\n            "article_url": "http://jingyan.baidu.com/article/375c8e19a2d33b25f3a22944.html",\n            "article_author": "糖尿病",\n            "article_time": "2015-01-01"\n        },\n {\n            "article_id": "0010104",\n            "article_title": "糖尿病的最佳疗法",\n            "article_detail": "糖尿病的发病原因是因为患者身体内血糖过高，胰岛素是身体内控制、消耗血糖的唯一有效激素。",\n            "article_url":"http://tnb.xywy.com/teseliaofa/808026.html",\n            "article_author": "糖尿病",\n            "article_time": "2015-01-01"\n        }\n    ]\n}', 1, 1, -9, 'GET'),
(28, '获取糖尿病专家建议', 'v', 'comm/expertdiabetes', '模块 :\n说明 :\n参数 :\n成功 :\n失败 :', '{\n"page":"1"\n}', '{\n    "code": 200,\n    "msg": "succeed",\n    "data": [\n        {\n            "article_id": "0010101",\n            "article_title": "糖尿病并发症有哪些，怎么预防",\n            "article_detail": "关于糖尿病的危害可以说很多人都知道晚期的时候就很难治愈了，所以预防称为了糖尿病患者的主要活动项目。",\n            "article_url": "http://jingyan.baidu.com/article/e52e36158991b440c60c51f1.html",\n            "article_author": "保健养生",\n            "article_time": "2015-01-01"\n        },\n        {\n            "article_id": "0010102",\n            "article_title": "糖尿病酮症酸中毒 规范治疗五要点”",\n            "article_detail": "糖尿病酮症酸中毒是由于血糖控制差而发生的一种非常严重的情况，糖尿病患者能够充分认识到这一点，重视血糖的控制，是预防糖尿病酮症酸中毒发生的根本措施。",\n            "article_url": "http://www.haodf.com/jibing/zhuanti/tangniaobing.htm",\n            "article_author": "专家访谈",\n            "article_time": "2015-01-01"\n        },\n        {\n            "article_id": "0010103",\n            "article_title": "眼睛干涩 小心糖尿病视网膜病变",\n            "article_detail": "糖尿病视网膜病变（简称糖网）是糖尿病眼病中最严重的并发症，也是致盲的重要原因之一，在各种致盲眼病中约占8%",\n            "article_url": "http://www.haodf.com/jibing/zhuanti/tangniaobing/lable.htm?&page=2",\n            "article_author": "专家访谈",\n            "article_time": "2015-01-01"\n        }\n    ]\n}', 1, 1, -9, 'GET'),
(29, '登陆-电话', 'v', 'con/logintel', '模块 :\n说明 :\n参数 :\n成功 :\n失败 :', '{\n"usertel":"1388069199",\n"password":"Zhangbo",\n"verify":"asdfasdf"\n}', '{\n"code":"200",\n"msg":"succeed"\n}', 1, 1, -99, 'GET'),
(30, '--------------------------------', 'v', '--------------------------------', '模块 :\n说明 :\n参数 :\n成功 :\n失败 :', '', '', 0, 1, -1, 'GET'),
(31, '--------------------------------', 'v', '--------------------------------', '', '', '', 0, 1, 0, 'GET'),
(32, '知识页面获取疾病列表', 'v', 'comm/diseaselist', '模块 :知识模块\n说明 :获取知识页面的疾病列表\n参数 :\n成功 :\n失败 :', '', '{\n    "code": 200,\n    "msg": "succeed",\n    "data": [\n        {\n            "disease_id": "h_001",\n            "disease_name": "冠心病",\n          \n            "disease_url": "http://192.168.1.200/v3/comm/diseaseitem"\n        },\n        {\n            "disease_id": "h_002",\n            "disease_name": "糖尿病",\n         \n            "disease_url": "http://192.168.1.200/xx"\n        },\n        {\n            "disease_id": "h_003",\n            "disease_name": "痛风",\n        \n            "disease_url": "http://192.168.1.200/xx"\n        },\n        {\n            "disease_id": "h_004",\n            "disease_name": "高血压",\n          \n            "disease_url": "http://192.168.1.200/xx"\n        }\n    ]\n}', 1, 1, -9, 'GET'),
(33, '获取某疾病的一个条目', 'v', 'comm/diseasedetail', '模块 :\n说明 :\n参数 :\n成功 :\n失败 :', '{"disease_id":"001"\n"item_id":"001"\n}', '{\n    "code": 200,\n    "msg": "succeed",\n    "data": [\n        {\n            "disease_id": "h_001",\n"item_id":"001",\n            "item_title": "冠心病形成原因",\n          "item_content":"冠心病的形成原因是冠心病的形成原因是冠心病的形成原因是冠心病的形成原因是"\n           \n        }\n       \n        \n    ]\n}', 1, 1, -9, 'GET'),
(34, '帮助', 'v', 'user/helps', '模块 :帮助和隐私中获取帮助\n说明 :data中返回帮助页面所在的url\n参数 :\n成功 :\n失败 :', '', '{ "code": 200,\n    "msg": "succeed",\n    "data": "http://"\n}', 1, 1, -99, 'GET'),
(35, '申明', 'v', 'user/declare', '模块 :隐私和帮助模块用户获取申明内容\n说明 :data中返回申明内容所在的url\n参数 :\n成功 :\n失败 :', '', '{ "code": 200,\n    "msg": "succeed",\n    "data": "http://"\n}', 1, 1, -99, 'GET'),
(36, '--------------------------------', 'v', '--------------------------------', '模块 :\n说明 :\n参数 :\n成功 :\n失败 :', '3', '4', 0, 1, -19, 'GET'),
(37, '--------------------------------', 'v', '--------------------------------', '模块 :\n说明 :\n参数 :\n成功 :5\n失败 :', '3', '4', 0, 1, 9000, 'GET'),
(38, '上传每次测量的原始数据 ', 'v', 'heart/measure', '模块 :使用心电设备\n说明 :上传每次测量的原始数据\n参数 :\n成功 :\n失败 :', '{\n"data":"xxxx"\n}', '{ "code": 200,\n    "msg": "succeed1"\n}', 1, 1, 99999, 'GET');

/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
